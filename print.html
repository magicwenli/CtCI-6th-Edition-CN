<!DOCTYPE HTML>
<html lang="cn" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CtCI-6th-Edition-CN</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 译者序</a></li><li class="chapter-item expanded affix "><li class="part-title">目录</li><li class="chapter-item expanded "><a href="Foreword.html"><strong aria-hidden="true">2.</strong> 序</a></li><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">3.</strong> 引言</a></li><li class="chapter-item expanded "><a href="I.The_Interview_Process.html"><strong aria-hidden="true">4.</strong> I. 面试过程</a></li><li class="chapter-item expanded "><a href="II.Behind_the_Scenes.html"><strong aria-hidden="true">5.</strong> II. 幕后</a></li><li class="chapter-item expanded "><a href="III.Special_Situations.html"><strong aria-hidden="true">6.</strong> III. 特殊情况</a></li><li class="chapter-item expanded "><a href="IV.Before_the_Interview.html"><strong aria-hidden="true">7.</strong> IV. 面试之前</a></li><li class="chapter-item expanded "><a href="V.Behavioral_Questions.html"><strong aria-hidden="true">8.</strong> V. 行为问题</a></li><li class="chapter-item expanded "><a href="VI.Big_O.html"><strong aria-hidden="true">9.</strong> VI. Big O</a></li><li class="chapter-item expanded "><a href="VII.Technical_Questions.html"><strong aria-hidden="true">10.</strong> VII. 技术问题</a></li><li class="chapter-item expanded "><a href="VIII.The_Offer_and_Beyond.html"><strong aria-hidden="true">11.</strong> VIII. Offer 及其他</a></li><li class="chapter-item expanded "><a href="IX.Interview_Questions.html"><strong aria-hidden="true">12.</strong> IX. 面试问题</a></li><li class="chapter-item expanded affix "><li class="part-title">数据结构</li><li class="chapter-item expanded "><a href="Chapter_1_Arrays_and_Strings.html"><strong aria-hidden="true">13.</strong> Chapter 1 I 数组和字符串</a></li><li class="chapter-item expanded "><a href="Chapter_2_Linked_Lists.html"><strong aria-hidden="true">14.</strong> Chapter 2 I 链表</a></li><li class="chapter-item expanded "><a href="Chapter_3_Stacks_and_Queues.html"><strong aria-hidden="true">15.</strong> Chapter 3 I 栈和队列</a></li><li class="chapter-item expanded "><a href="Chapter_4_Trees_and_Graphs.html"><strong aria-hidden="true">16.</strong> Chapter 4 I 树和图</a></li><li class="chapter-item expanded affix "><li class="part-title">概念和算法</li><li class="chapter-item expanded "><a href="Chapter_5_Bit_Manipulation.html"><strong aria-hidden="true">17.</strong> Chapter 5 I 位操作</a></li><li class="chapter-item expanded "><a href="Chapter_6_Math_and_Logic_Puzzles.html"><strong aria-hidden="true">18.</strong> Chapter 6 I 数学和逻辑难题</a></li><li class="chapter-item expanded "><a href="Chapter_7_Object-Oriented_Design.html"><strong aria-hidden="true">19.</strong> Chapter 7 I 面向对象的设计</a></li><li class="chapter-item expanded "><a href="Chapter_8_Recursion_and_Dynamic_Programming.html"><strong aria-hidden="true">20.</strong> Chapter 8 I 递归和动态规划</a></li><li class="chapter-item expanded "><a href="Chapter_9_System_Design_and_Scalability.html"><strong aria-hidden="true">21.</strong> Chapter 9 I 系统设计和可扩展性</a></li><li class="chapter-item expanded "><a href="Chapter_10_Sorting_and_Searching.html"><strong aria-hidden="true">22.</strong> Chapter 10 I 排序与搜索</a></li><li class="chapter-item expanded "><a href="Chapter_11_Testing.html"><strong aria-hidden="true">23.</strong> Chapter 11 I 测试</a></li><li class="chapter-item expanded affix "><li class="part-title">基础知识</li><li class="chapter-item expanded "><a href="Chapter_12_C_and_C++.html"><strong aria-hidden="true">24.</strong> Chapter 12 I C 和 C++</a></li><li class="chapter-item expanded "><a href="Chapter_13_Java.html"><strong aria-hidden="true">25.</strong> Chapter 13 I Java</a></li><li class="chapter-item expanded "><a href="Chapter_14_Databases.html"><strong aria-hidden="true">26.</strong> Chapter 14 I 数据库</a></li><li class="chapter-item expanded "><a href="Chapter_15_Threads_and_Locks.html"><strong aria-hidden="true">27.</strong> Chapter 15 I 线程和锁</a></li><li class="chapter-item expanded affix "><li class="part-title">附加复习题</li><li class="chapter-item expanded "><a href="Chapter_16_Moderate.html"><strong aria-hidden="true">28.</strong> Chapter 16 I 中等</a></li><li class="chapter-item expanded "><a href="Chapter_17_Hard.html"><strong aria-hidden="true">29.</strong> Chapter 17 I 困难</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded "><a href="X.Solutions.html"><strong aria-hidden="true">30.</strong> X. 答案</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.</strong> XI. 进阶主题</div></li><li class="chapter-item expanded "><a href="XII.Code_Library.html"><strong aria-hidden="true">32.</strong> XII. 代码库</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.</strong> XIII. 提示</div></li><li class="chapter-item expanded "><a href="XIV.About_the_Author.html"><strong aria-hidden="true">34.</strong> XIV. 关于作者</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CtCI-6th-Edition-CN</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/magicwenli/CtCI-6th-Edition-CN/tree/master" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="破解编码面试---中文翻译"><a class="header" href="#破解编码面试---中文翻译">破解编码面试 - 中文翻译</a></h1>
<ul>
<li>作者： <a href="http://www.gayle.com/contact/">Gayle Laakmann McDowell</a></li>
<li>原书名称：<a href="https://www.amazon.com/Cracking-Coding-Interview-6th-Edition/dp/0984782850">Cracking the Coding Interview: 189 Programming Questions and Solutions</a></li>
<li>译者：<a href="https://f8f-1bearcat.github.io/about/">F8F-1BearCat</a></li>
</ul>
<div align=center><img src="img/Cover.jpg"/></div>
<h2 id="译者序"><a class="header" href="#译者序">译者序</a></h2>
<p>译者摸鱼的时候喜欢逛一亩三分地论坛，在 <code>终身学习&gt;刷题</code> 板块里偶然发现了 CtCI 这本书。本书被誉为北美码农求职面试经典书籍，因书中包含 189 道编码题，所以也被称为 CC189，更早的版本为 CC150。</p>
<p>这本书介绍了 Microsoft、Google 等一线互联网公司的面试流程，讲解了该怎样准备面试、怎样回答技术问题，还单独拿出一些篇幅教你如何评估选择 Offer 以及如何跟 HR 进行 Negotiation。 当然，有关时间复杂度、空间复杂度以及具体的面试题目才是本书的重点。</p>
<p>本书的 189 道题目以数据机构和算法为主，其题目及答案占据了本书绝大部分的内容。此外，分别有一个章节涵盖分布式系统设计、C/C++、Java、数据库、多线程等知识性的内容，但是这些内容几乎都是浅尝辄止，旨在为读者提供一个简略却系统的知识框架，让读者可以根据自己的薄弱环节有目的的去强化训练。这 189 道题涵盖了编程面试中你可能遇到的大部分题型，题目有易有难，且所有题目都给出了比较常规的解题思路和答案，其中算法题目的实现使用了 Java 语言。当然有些解法不是最优，如果你有兴趣的话可以在此基础上自己尝试给出最优解。</p>
<p>就好比考 GMAT 之前要看 OG 一样，本书是针对编程面试的入门书籍。如果你工作多年，需要重新将数据结构和算法捡起来的话，本书很适合你；但如果你是打过 ACM 等算法比赛的大牛，或者从事与算法相关的工作，那这本书就可以直接跳过了。由于是面向编码面试的，本书自然不能避免其功利性，如果纯粹是想学习算法，可以去看一看 Programming Pearls 等书。本书的题目与实际面试相比还是稍简单的，如果你想进一步提升的话，建议到 Leetcode 上刷题，并自己消化总结。</p>
<p>顺便一提，一亩三分地论坛还经常提到另一本书：<a href="https://www.amazon.com/Programming-Interviews-Exposed-Secrets-Landing/dp/1118261364/?&amp;_encoding=UTF8&amp;tag=1point3acres-20&amp;linkCode=ur2&amp;linkId=f4a9f284abef2e91bbc0bc39a9cc3967&amp;camp=1789&amp;creative=9325">Programming Interview Exposed</a>，这本书更基础一点，非科班零基础的小白可以尝试先从这本书入手。</p>
<p>最后，译者在此建议，有能力的读者最好还是去阅读本书的英文原版。</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<h4 id="序"><a class="header" href="#序"><a href="Foreword.html">序</a></a></h4>
<h4 id="引言"><a class="header" href="#引言"><a href="Introduction.html">引言</a></a></h4>
<h4 id="i-面试过程"><a class="header" href="#i-面试过程"><a href="I.The_Interview_Process.html">I. 面试过程</a></a></h4>
<h4 id="ii-幕后"><a class="header" href="#ii-幕后"><a href="II.Behind_the_Scenes.html">II. 幕后</a></a></h4>
<h4 id="iii-特殊情况"><a class="header" href="#iii-特殊情况"><a href="III.Special_Situations.html">III. 特殊情况</a></a></h4>
<h4 id="iv-面试之前"><a class="header" href="#iv-面试之前"><a href="IV.Before_the_Interview.html">IV. 面试之前</a></a></h4>
<h4 id="v-行为问题"><a class="header" href="#v-行为问题"><a href="V.Behavioral_Questions.html">V. 行为问题</a></a></h4>
<h4 id="vi-big-o"><a class="header" href="#vi-big-o"><a href="VI.Big_O.html">VI. Big O</a></a></h4>
<h4 id="vii-技术问题"><a class="header" href="#vii-技术问题"><a href="VII.Technical_Questions.html">VII. 技术问题</a></a></h4>
<h4 id="viii-offer-及其他"><a class="header" href="#viii-offer-及其他"><a href="VIII.The_Offer_and_Beyond.html">VIII. Offer 及其他</a></a></h4>
<h4 id="ix-面试问题"><a class="header" href="#ix-面试问题"><a href="IX.Interview_Questions.html">IX. 面试问题</a></a></h4>
<p><strong>数据结构</strong></p>
<ul>
<li><a href="Chapter_1_Arrays_and_Strings.html">Chapter 1 I 数组和字符串</a></li>
<li><a href="Chapter_2_Linked_Lists.html">Chapter 2 I 链表</a></li>
<li><a href="Chapter_3_Stacks_and_Queues.html">Chapter 3 I 栈和队列</a></li>
<li><a href="Chapter_4_Trees_and_Graphs.html">Chapter 4 I 树和图</a></li>
</ul>
<p><strong>概念和算法</strong></p>
<ul>
<li><a href="Chapter_5_Bit_Manipulation.html">Chapter 5 I 位操作</a></li>
<li><a href="Chapter_6_Math_and_Logic_Puzzles.html">Chapter 6 I 数学和逻辑难题</a></li>
<li><a href="Chapter_7_Object-Oriented_Design.html">Chapter 7 I 面向对象的设计</a></li>
<li><a href="Chapter_8_Recursion_and_Dynamic_Programming.html">Chapter 8 I 递归和动态规划</a></li>
<li><a href="Chapter_9_System_Design_and_Scalability.html">Chapter 9 I 系统设计和可扩展性</a></li>
<li><a href="Chapter_10_Sorting_and_Searching.html">Chapter 10 I 排序与搜索</a></li>
<li><a href="Chapter_11_Testing.html">Chapter 11 I 测试</a></li>
</ul>
<p><strong>基础知识</strong></p>
<ul>
<li><a href="Chapter_12_C_and_C++.html">Chapter 12 I C 和 C++</a></li>
<li><a href="Chapter_13_Java.html">Chapter 13 I Java</a></li>
<li><a href="Chapter_14_Databases.html">Chapter 14 I 数据库</a></li>
<li><a href="Chapter_15_Threads_and_Locks.html">Chapter 15 I 线程和锁</a></li>
</ul>
<p><strong>附加复习题</strong></p>
<ul>
<li><a href="Chapter_16_Moderate.html">Chapter 16 I 中等</a></li>
<li><a href="Chapter_17_Hard.html">Chapter 17 I 困难</a></li>
</ul>
<h4 id="x-答案"><a class="header" href="#x-答案"><a href="https://github.com/careercup/CtCI-6th-Edition">X. 答案</a></a></h4>
<h4 id="xi-进阶主题"><a class="header" href="#xi-进阶主题">XI. 进阶主题</a></h4>
<h4 id="xii-代码库"><a class="header" href="#xii-代码库"><a href="XII.Code_Library.html">XII. 代码库</a></a></h4>
<h4 id="xiii-提示"><a class="header" href="#xiii-提示">XIII. 提示</a></h4>
<h4 id="xiv-关于作者"><a class="header" href="#xiv-关于作者"><a href="XIV.About_the_Author.html">XIV. 关于作者</a></a></h4>
<p>注：本书的 <code>X. 答案</code> 部分为编码答案，本项目中不做翻译收录，需要阅读的同学可以阅读英文原版，或者 <em>CareerCup</em> 的这个项目：https://github.com/careercup/CtCI-6th-Edition 。</p>
<h2 id="法律声明"><a class="header" href="#法律声明">法律声明</a></h2>
<blockquote>
<p>《中华人民共和国著作权法》
第四节 权利的限制
第二十二条　在下列情况下使用作品，可以不经著作权人许可，不向其支付报酬，但应当指明作者姓名、作品名称，并且不得侵犯著作权人依照本法享有的其他权利：
(六)为学校课堂教学或者科学研究，翻译或者少量复制已经发表的作品，供教学或者科研人员使用，但不得出版发行;</p>
</blockquote>
<p>本项目是出于个人兴趣及学习目的而建立，仅供交流与学习研究之用，严禁公开传播发行或用于商业用途。有能力阅读英文书籍者请购买原版支持。</p>
<p><strong>APPEND</strong>：经 v2ex 网友提醒，本书官方中文版本已出版，中文名为程序员面试金典（译者在此忍不住吐槽此译名），第六版发行日期为 19 年 9 月份，难怪译者当时没找到。所以在此译者建议大家有需要的话通过官方渠道购买书籍，本项目可以做译文对比、沟通交流之用，感谢大家的支持。</p>
<h2 id="license"><a class="header" href="#license">LICENSE</a></h2>
<p>本项目中的文档是根据 CC BY-NC-SA 4.0 许可协议授权的，该协议鼓励您共享这些文档。</p>
<p>详情见：<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际  (CC BY-NC-SA 4.0)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="序-1"><a class="header" href="#序-1">序</a></h2>
<p>亲爱的读者，</p>
<p>让我们先来介绍一下。</p>
<p>我不是招聘人员。我是一名软件工程师。正因如此，我知道被要求当场拿出精彩的算法然后在白板上编写出完美的代码是什么感觉。我之所以知道，是因为我被要求做过同样的事情——在 Google、Microsoft、Apple 和 Amazon 以及其他公司的面试中。</p>
<p>不仅如此，我也曾站在桌子的另一边，要求我的候选人们也这样做。我曾经为了找到那些我认为有可能通过面试的工程师，而翻看过成堆的简历。我曾经在他们解决或试图解决具有挑战性的问题时，对他们进行评估。我也曾经在 Google's Hiring Committee 中争论过，是否某个候选人的表现足以获得这份工作。我熟悉整个招聘流程，因为我经历过其中的每一步，一遍又一遍。</p>
<p>而你，读者，可能正在为明天、下周或明年的面试做准备。我在这是为了帮助你巩固对计算机科学基础的理解，然后学习如何应用这些基础知识来破解编码面试。</p>
<p>第 6 版 <em>Cracking the Coding Interview</em> 在第 5 版的基础上进行了更新，增加了 70% 的内容：附加问题、修订后的答案、新章节介绍、更多的算法策略、所有问题的提示以及其他内容。请务必访问我们的网站 <em>CrackingTheCodinglnterview.com</em>，与其他求职者联系并发现新资源。</p>
<p>我为你和你将要发展的技能感到高兴。充分的准备将有助于你拓宽知识范围、提升沟通技巧。无论付出多大的努力，这都是值得的！建议你仔细阅读这些入门章节，在这些章节我记录下了一些重要的见解，或许最终能影响你的结果是 "hire"，还是 "no hire"。</p>
<p>同时要牢记，面试是很难的！在 Google 搞面试的这几年里，我注意到有一些面试官会问“简单”的问题，而另外一些面试官会问稍难的问题。但是你猜怎么着？简单的问题并不会让你更容易获得 offer。获得 offer 并不是要求你能完美地解决问题（很少有求职者能够做到！），而是要求你能给出比其他的求职者更好的回答。所以，当你遇到棘手的问题时，不要紧张——其他人可能都认为它很难。做不到完美也没有关系。</p>
<p>Study hard, practice-and good luck!</p>
<p>Gayle L. McDowell
创始人/CEO, CareerCup.com
<em>Cracking the PM Interview</em> 和 <em>Cracking the Tech Career</em> 作者</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="引言-1"><a class="header" href="#引言-1">引言</a></h2>
<h4 id="哪里错了"><a class="header" href="#哪里错了">哪里错了</a></h4>
<p>我们再次沮丧地走出招聘会。那天考察的 10 位候选人中，没有一位会收到 offer。我们在想，我们是不是太苛刻了？</p>
<p>我尤其感到失望。我们拒绝了我的一位候选人。他是我之前教过的一个学生。他在世界上最好的计算机科学学校之一华盛顿大学取得了 3.73 的 GPA，并在开源项目上做了大量工作。他精力充沛。他很有创造性。他很敏锐。他工作努力。他在所有方面都是一个真正的极客。</p>
<p>但我不得不同意委员会其他成员的观点：这些数据并不能说明问题。即使我强烈的推荐能够说服他们重新考虑，他也肯定会在后面的招聘流程中遭到淘汰。因为他暴露了太多的危险信号（red flag）。</p>
<p>虽然他很聪明，但是在解决面试问题时他却表现得很艰难。面试中的第一个问题是一个经典问题的变形，大多数成功的求职者都能快速做出回答，但是他却在这个问题的算法开发时遇到了麻烦。当他提出一个方案时，没有考虑到针对其他场景优化的解决方案。最终在编码时，他用最初的解决思路快速地写完了代码，但是代码中却充满了他没有留意到的错误。尽管从任何角度来看，他都不是我们所见过的最差的候选人，但是他离 “bar” （译者注，标杆）还差得很远。所以，拒绝。</p>
<p>几周后，当他在电话中询问反馈时，我很纠结不知道该怎么回答他。更聪明？不，我知道他很聪明。成为更好的 coder？不，他的技术和我见过的一些最好的不相上下。</p>
<p>像许多积极的求职者一样，他准备得很充分。他读过 K&amp;R 的经典 C 语言书籍，也复习过 CLRS 著名的算法教科书。他可以详细描述平衡树的无数种方法，而且他可以用 C 语言做一些没有任何理智的程序员会考虑做的事情。</p>
<p>我不得不告诉他一个不幸的事实：仅仅看那些书是不够的。学术书籍能让你为新奇的研究做好准备，它们可能会让你成为一名更好的软件工程师，但它们不足以应对面试。为什么？我给你个提示：你的面试官没有见过红黑树，因为他们在学校也是如此。</p>
<p>要破解编码面试，你需要准备真实的面试问题。你必须对实际问题进行练习，并学习它们的模式。最终能实现灵活开发新的算法，而不是死记硬背现有的问题。</p>
<p><strong>Cracking the Coding Interview</strong> 一书是我根据在一线公司参与面试并在之后指导求职者通过面试的第一手经验所总结的成果。它是与求职者数百次对话的成果。它是汇总候选人和面试官提出的数千个问题的成果。它也是参考了这么多公司的这么多面试问题的成果。本书收录了 189 个最好的面试问题，这是从成千上万个可能的问题中挑选出来的。</p>
<h4 id="我的方法"><a class="header" href="#我的方法">我的方法</a></h4>
<p><strong>Cracking the Coding Interview</strong> 的重点是算法、编码和设计问题。为什么？因为虽然你可以也会被问到工作经验方面的问题（behavioral question），但答案会和你的简历一样五花八门。同样，虽然许多公司会问一些所谓的 “trivia” 问题（例如，“什么是虚拟功能？”），但是通过实践这些问题而获得的技能仅限于非常具体的知识。本书将简要介绍其中的一些问题，向你展示它们是什么样的，但我选择将空间分配给需要学习更多内容的领域。</p>
<h4 id="我的爱好"><a class="header" href="#我的爱好">我的爱好</a></h4>
<p>教学是我的爱好。我喜欢帮助人们理解新概念，并为他们提供工具来帮助他们在他们爱好的领域中脱颖而出。</p>
<p>我第一次正式的教学经历是宾夕法尼亚大学，当时我在第二年成为一名计算机科学本科课程的助教。我接受了 TA 的其他几门课程，最后我在那里开设了自己的计算机科学课程，侧重于实践技能。</p>
<p>作为 Google 的工程师，培训和指导新工程师是我最喜欢的事情之一。我甚至利用我的 “20％ 时间” 在华盛顿大学教授两门计算机科学课程。</p>
<p>多年后的今天，我继续教授计算机科学的概念，但这一次的目标是让初创公司的工程师为他们的 acquisition interview 做准备。我已经看到他们的错误和努力，并且为帮助他们解决这些问题制定了技术和策略。</p>
<p><strong>Cracking the Coding Interview</strong>、<strong>Cracking the PM Interview</strong>、<strong>Cracking the Tech Career</strong> 和 <strong>CareerCup</strong>，都体现了我对教学的热爱。即使是现在，你也经常可以在 <em>CareerCup.com</em> 上看到我在 “闲逛”，以帮助那些寻求帮助的用户。</p>
<p>加入我们。</p>
<p>Gayle L. McDowell</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-面试过程-1"><a class="header" href="#i-面试过程-1">I. 面试过程</a></h1>
<p>在大多数顶级科技公司（以及许多其他公司），算法和编码问题是面试过程中最大的组成部分。这类问题都可以被视为问题解决型（problem-solving）的问题。面试官希望能通过观察你解决以前没有遇到过的算法问题的过程，来评估你的能力。</p>
<p>很多时候，在面试中你可能只会遇到一个问题。因为 45 分钟并不长，在这段时间内你很难全部回答完几个不同的问题。</p>
<p>在整个解决问题的过程中，你应该大声地说出你的方案，并解释你的思考过程。你的面试官有时会跳出来引导你，让他们这样做。这是正常的，并不意味着你做得很差。(当然，不需要提示就更好了。)</p>
<p>在面试结束后，面试官一般会对你的表现就已经有了直观的感觉。他们可能会给你的表现打分，但这并不是一个定量的评价。没有图表显示你在不同的事情上得到了多少分。面试本身就不像是那样工作。</p>
<p>相反，你的面试官对你的表现进行评估，通常是基于以下几点：</p>
<ul>
<li>
<p><strong>分析能力</strong>：你需要很多帮助来解决问题吗？你的解决方案有多优？你花了多长时间才找到解决办法？如果你必须设计/架构一个新的解决方案，你是否很好地组织了问题并考虑了不同决策的权衡？</p>
</li>
<li>
<p><strong>编码水平</strong>：你是否能够将算法成功转换为合理的代码？它干净有序吗？你是否考虑过潜在的错误？ 你的代码风格好吗？</p>
</li>
<li>
<p><strong>技术知识/计算机科学基础知识</strong>：你是否拥有计算机科学和相关技术的坚实基础？</p>
</li>
<li>
<p><strong>经验</strong>：你过去做过很好的技术决策吗？你做过有趣、有挑战性的项目吗？你是否表现出动力、主动性和其他重要因素？</p>
</li>
<li>
<p><strong>文化契合/沟通技巧</strong>：你的个性和价值观是否与公司和团队契合？你和面试官是否能够良好沟通？</p>
</li>
</ul>
<p>这些领域的权重将根据问题、面试官、角色、团队和公司的不同而有所不同。在一个标准算法问题中，它主要考察的几乎完全是前三个方面。</p>
<h3 id="why"><a class="header" href="#why">Why?</a></h3>
<p>这是求职者在开始面试时最常问的问题之一。为什么面试要设计成这样？毕竟：</p>
<ol>
<li>
<p>很多优秀的求职者在这类面试中都表现不佳。</p>
</li>
<li>
<p>如果确实出现过，你可以直接查找到答案。</p>
</li>
<li>
<p>在实际工作中，很少需要使用诸如二叉搜索树之类的数据结构。如果你确实需要，你肯定可以学习它。</p>
</li>
<li>
<p>白板编码是一种人为的环境。显然，在实际工作中你永远不会在白板上编写代码。</p>
</li>
</ol>
<p>这些抱怨不无道理。事实上，我同意他们所有人的观点，至少部分是这样。</p>
<p>与此同时，我们有理由对某些职位（而不是所有职位）采取这种做法。同意这个逻辑并不重要，但是理解为什么要问这些问题是一个好主意。它能帮助你深入了解面试官的心态。</p>
<h4 id="漏报false-negatives是可以接收的"><a class="header" href="#漏报false-negatives是可以接收的">漏报（False negatives）是可以接收的。</a></h4>
<p>这让人难过（也让候选人感到沮丧），但这却是事实。</p>
<p>从公司的角度来看，一些优秀的候选人被拒其实是可以接受的。如果这家公司打算自己培养一批优秀的员工，他们可以接受错过一些优秀的人。当然，他们也不想这么做，因为这会增加他们的招聘成本。不过，这是一个可以接受的折衷方案，只要他们仍然能够聘用到足够多的优秀人才。</p>
<p>他们更关心的是误报（false positives）：那些在面试中表现很优秀的人，但实际上并不是很优秀。</p>
<h4 id="解决问题的能力problem-solving-skills很有价值"><a class="header" href="#解决问题的能力problem-solving-skills很有价值">解决问题的能力（Problem-solving skills）很有价值。</a></h4>
<p>如果你能够解决几个难题（或许是在一定的帮助下），那么你可能非常擅长开发最优算法。换句话说，你很聪明。</p>
<p>聪明的人倾向于将事情做好，这对公司来说很有价值。当然，这不是唯一重要的，但这是一件非常好的事情。</p>
<h4 id="基本数据结构和算法知识很有用"><a class="header" href="#基本数据结构和算法知识很有用">基本数据结构和算法知识很有用。</a></h4>
<p>许多面试官会认为，基本的计算机科学知识实际上是有用的。要清楚，需要用到树、图、列表、排序和其他知识的情况隔段时间肯定会出现。如果真是这样的话，掌握书本的知识真的很有必要。</p>
<p>难道不可以遇到问题的时候根据需要有选择地学习吗？当然可以。但是如果你不知道二叉搜索树的存在，你就很难在需要的时候知道应该去使用它。如果你知道它的存在，那么你具有了基本的概念。</p>
<p>其他面试官依靠数据结构和算法相关的问题来考察求职者，是因为他们认为这是一个很好的“代理”。即使这些技能本身并不难学，但他们表示，这与成为一名优秀的开发人员是有相当大的关联的。这意味着你要么通过了计算机科学课程（在这种情况下，你已经学习并保留了相当广泛的技术知识），要么自学了这些东西。无论哪种方式，这都是一个好迹象。</p>
<p>数据结构和算法知识出现的另一个原因是：很难提出不涉及它们的问题解决型（problem-solving ）的问题。事实证明，绝大多数解决问题的问题涉及其中一些基础知识。当足够多的应聘者了解这些基本知识时，很容易进入一种向他们提问的模式。</p>
<h4 id="白板能让你专注于重要的事情"><a class="header" href="#白板能让你专注于重要的事情">白板能让你专注于重要的事情。</a></h4>
<p>在白板上编写完美的代码是非常困难的，这是绝对肯定的。幸运的是，你的面试官对此并没有苛求。实际上，每个人都有一些 bug 或轻微的语法错误。</p>
<p>白板的好处在于，在某种程度上，你可以专注于大局。你没有编译器。所以你不需要编译代码。你不需要编写整个类定义和样板代码。你可以关注代码中有趣的、“充实的”部分：该问题真正关注的功能。</p>
<p>这并不是说你应该只写伪代码或者正确性无关紧要。大多数面试官不接受伪代码，并且希望错误越少越好。</p>
<p>白板也倾向于鼓励候选人多发言，并解释他们的思维过程。当给应聘者一台电脑时，他们的沟通能力会大幅下降。</p>
<h4 id="但这并不适用于每个人每个公司或每种情况"><a class="header" href="#但这并不适用于每个人每个公司或每种情况">但这并不适用于每个人、每个公司或每种情况。</a></h4>
<p>以上部分旨在帮助你了解公司的思维过程。</p>
<p>我的个人想法？ 对于正确的情况，如果面试过程处理得当，是能够帮助对一个人解决问题能力做出的合理判断的，因为表现优秀的人往往相当聪明。</p>
<p>然而，许多面试过程体验的并不好。你可能会遇到你的面试官很差劲，或者他们问的问题也很差劲。</p>
<p>它也不适合所有的公司。有些公司应该更重视员工以前的经验，或者需要掌握特定技术的技能。那么这类问题并没有太大分量。</p>
<p>它也不能衡量一个人的职业道德或专注力。再说一次，几乎没有面试过程能真正评估这一点。</p>
<p>无论如何，这都不是一个完美的过程，但什么是完美的过程呢？事实上所有的面试过程都有其缺点。</p>
<p>我只能说：事情就是这样，所以我们只能尽自己所能。</p>
<h3 id="面试题是如何被选择的"><a class="header" href="#面试题是如何被选择的">面试题是如何被选择的</a></h3>
<p>应聘者经常会问在某家公司“最近”的面试问题是什么。仅仅问这个问题就揭示了他对问题来源的根本性误解。</p>
<p>在绝大多数公司，面试官该问的问题并没有一个清单。相反，每个面试官都会选择他们自己的问题。</p>
<p>因为就问题而言，它是“对任何人都开放的（free for all）”，所以没有什么能让一个问题成为“最近 Google 面试的问题”，除了一个碰巧在 Google 工作的面试官最近碰巧问了这个问题。</p>
<p>今年 Google 面试被问到的的问题与三年前的问题并没有太大区别。事实上， Google 提出的问题通常与在类似公司（Amazon、Facebook等）提出的问题没有什么不同。</p>
<p>不同公司之间存在着一些广泛的差异。一些公司专注于算法（通常被用于一些系统设计），而另一些公司则非常喜欢基于知识的问题。但在一个给定的问题类别中，几乎没有什么能让它“属于”一家公司，而不是另一家公司。Google 的算法问题和 Facebook 的算法问题本质上是一样的。</p>
<h3 id="一切都是相对的"><a class="header" href="#一切都是相对的">一切都是相对的</a></h3>
<p>如果没有评分系统，你是如何被评估的？面试官如何知道你的期望？</p>
<p>好问题。一旦理解了，答案就会变得很有意义。</p>
<p>面试官会通过在同一个面试官的同一个问题上的表现评估你与其他候选人的优劣。这是一个相对比较。</p>
<p>例如，假设你想出了一个很酷的新脑筋急转弯或数学问题。你问你的朋友 Alex 这个问题，他花了30分钟来解决它。你问 Bella，她花了50分钟。Chris 永远也解不出来。Dexter 需要15分钟，但你必须给他一些重要的提示，如果没有这些提示，他可能会花更长的时间。Ellie 采用了 10 种方法，并提出了一个你甚至都不知道的替代方法。Fred 需要35分钟。</p>
<p>你会走开，说道，“哇，Ellie 表现得真不错。我敢打赌她的数学一定很好。”（当然，很有可能只是她比较走运，而 Chris 不走运。你可能会问更多的问题，以确保这不是因为运气好或运气坏。）</p>
<p>面试问题也是如此。面试官通过将你与其他人进行比较，会对你的表现有所了解。当然这和她那周面试的候选人无关，而是基于她曾经问过这个问题的所有候选人的表现。</p>
<p>因此，被问到一个很难的问题并不是一件坏事。如果对你来说很难，那对每个人来说也都是很难的。这并不会降低你成功的可能性。</p>
<h3 id="faq"><a class="header" href="#faq">FAQ</a></h3>
<h4 id="我在面试后没有立即收到回复我被拒绝了吗"><a class="header" href="#我在面试后没有立即收到回复我被拒绝了吗">我在面试后没有立即收到回复。我被拒绝了吗？</a></h4>
<p>不。公司的决定可能会被推迟，原因有很多。一个非常简单的解释是，你的一位面试官还没有给出他们的反馈。很少有公司的政策是不回应他们拒绝的候选人。</p>
<p>如果你在面试后的 3~5 个工作日内没有收到任何公司的回复，礼貌地和招聘人员联系。</p>
<h4 id="我被拒绝后可以重新申请公司吗"><a class="header" href="#我被拒绝后可以重新申请公司吗">我被拒绝后可以重新申请公司吗？</a></h4>
<p>几乎都是可以的，但你通常需要等待一段时间（6 个月到 1 年）。当你重新面试时，你的第一次不良面试通常不会对你产生太大的影响。许多人曾被 Google 或 Microsoft 拒绝过，但后来都得到了他们的 offer。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ii-幕后-1"><a class="header" href="#ii-幕后-1">II. 幕后</a></h1>
<p>大多数公司的面试方式都非常相似。本章我们将概述一些公司面试的方式以及什么是他们所看重的。这些信息将指导你如何进行面试准备，以及面试中和面试后该如何表现。</p>
<p>一旦你被选中参加面试，你通常要经过一次筛选面试。这通常是通过电话进行的。而就读于名校的应届求职者将很可能是面对面现场体验这类面试的。</p>
<p>别让这个名字迷惑了你，“筛选”面试通常涉及编码和算法问题，并且面试的门槛可能和面对面面试（in-person interview）一样高。如果你不确定面试是否是技术性的，问问你的招聘协调人你的面试官所担任的职位（或面试可能涵盖的范围）。例如，如果是工程师的话，通常会进行技术面试。</p>
<p>许多公司都利用了在线同步文档编辑器，但也有一些公司希望你将代码写在纸上，然后在电话里向面试官将其读回。甚至，有些面试官会在挂电话后给你布置“家庭作业”，或者只是让你把写的代码通过电子邮件发给他们。</p>
<p>在进行现场面试（on-site）之前，你通常要经过一两个面试官的筛选。</p>
<p>在现场面试中，你通常会有 3 到 6 次面对面的面试。其中之一经常是在午餐时间。午餐面试通常不是技术性的，面试官甚至可能不会提交反馈。你可以与面试官讨论你的兴趣爱好，或者也可以询问公司的企业文化。你的其他面试大多是技术性的，涉及编码、算法、设计/架构和工作经历/经验问题的组合。</p>
<p>由于公司的优先级、规模和纯粹的随机性，上述主题范围内的问题在不同公司甚至不同团队之间的分布都不相同。面试官在面试问题上通常有很大的自由度。</p>
<p>面试后，面试官会以某种形式提供反馈。在一些公司，面试官会聚在一起讨论你的表现并做出决定。在其他公司，面试官会向招聘经理或招聘委员会提交一份建议，以做出最终决定。也有一些公司，面试官甚至不做决定，他们的反馈会被直接提交给招聘委员会，由他们来做决定。</p>
<p>大多数公司在一周后就会采取下一步行动（发offer、拒绝、进一步面试，或者只是更新流程）。一些公司的反馈速度很快（有时是同一天！），而另一些公司的反应时间要长得多。</p>
<p>如果你已经等了一个多星期，你应该跟招聘人员联系一下。如果你的招聘人员没有回应，这并不意味着你就被拒绝了（至少在任何大型科技公司以及几乎所有其他公司中都没有这种情况）。让我再重复一遍：不回复跟你的面试状态并无直接联系。换句话说，一旦做出最终决定，所有招聘人员都应当会告诉求职者。</p>
<p>延迟可能而且确实会发生。如果预计会有延迟，请与招聘人员联系，但这样做时要保持尊重。招聘人员和你一样，他们有时也会忙碌和健忘。</p>
<h3 id="microsoft-面试"><a class="header" href="#microsoft-面试">Microsoft 面试</a></h3>
<p>Microsoft 想要聪明的人、极客、热爱科技的人。你可能不会被考察 C++ AP l的输入输出，但是你需要做到在白板上编写代码。</p>
<p>在一个典型的面试中，你将在早上的某个时间出现在 Microsoft，填写一些基础资料。接着你将有一个简短的面试，招聘人员会给你一个简单的问题。招聘人员通常是为了帮你做准备，而不是盘问你技术问题。如果你被问到一些基本的技术问题，那可能是因为你的招聘人员想让你轻松地进入面试，这样当“真正的”面试开始时，你就不会那么紧张了。</p>
<p>善待你的招聘人员。你的招聘人员可能是你最大的支持者，如果你在第一次面试中遇到失误，他们甚至会敦促你重新面试。他们可以为你争取工作——或者不争取！</p>
<p>白天，你将进行四到五次面试，通常是由两个不同的团队来执行。不像许多公司，你在会议室会见面试官，在 Microsoft，你会与面试官在他们的办公室会见。这是一个很好的时机，你可以看看周围，感受一下团队文化。</p>
<p>根据团队的不同，面试官可能会也可能不会将他们对你的反馈分享给面试的其他环节。</p>
<p>当你完成对一个团队的面试时，你可能会与招聘经理交谈（通常被称为“as app”，即“as appropriate”的缩写）。如果是这样，那是一个好兆头！这很可能意味着你通过了一个特定团队的面试。现在就看招聘经理的决定了。</p>
<p>你可能会当天收到决定，也可能是一个星期。在一周没有人力资源部门的消息后，发一封友好的电子邮件询问状态更新。</p>
<p>如果你的招聘人员反应不积极，那是因为她很忙，而不是因为你被默默拒绝了。</p>
<h4 id="必要的准备"><a class="header" href="#必要的准备">必要的准备：</a></h4>
<p>“你为什么想为 Microsoft 工作？”</p>
<p>在这个问题中，Microsoft 希望看到你对技术充满热情。一个很好的回答可能是：“从我记事起，我就一直在使用 Microsoft 的软件，我对 Microsoft 如何创造出一款普遍优秀的产品印象深刻。例如，我最近一直在使用 Visual Studio 学习游戏编程，它的 APl 非常出色”。请注意，这样的答案显示了对技术的热情！</p>
<h4 id="独特之处"><a class="header" href="#独特之处">独特之处：</a></h4>
<p>只有当你表现得很优秀时，才会联系到招聘经理，因此如果你能与其谈话的话，这是一个很好的迹象！</p>
<p>此外，Microsoft 倾向于赋予团队更多的个人控制权，并且产品集是多样化的。由于不同的团队看重不同的方面，因此 Microsoft 内不同部门的体验可能会有很大差异。</p>
<h3 id="amazon-面试"><a class="header" href="#amazon-面试">Amazon 面试</a></h3>
<p>Amazon 的招聘流程通常从电话视频开始的，由一个特定的团队对候选人进行面试。在一小段时间内，候选人可能会有两次或两次以上的面试，这要么表明他们的面试官之一没有被说服，要么表明他们被考虑进入一个不同的团队或资料库。在更不寻常的情况下，例如，当一个求职者在公司当地或最近参加过另一个职位的面试时，他可能只需要做一次电话面试。</p>
<p>面试你的工程师通常会要求你通过共享的文档编辑器编写简单的代码。他们还会经常提出一系列的问题来探索你所熟悉的技术领域。</p>
<p>接下来，你要飞往西雅图（或任何你要面试的办公室），与一两个团队进行四到五次面试，这些团队根据你的简历和电话面试选择了你。首先你将必须能在白板上写代码，一些面试官还会考察其他的技能。面试官都被分配了一个特定的区域对你进行探查，而且他们之间可能看起来非常不同。在提交自己的反馈之前，他们看不到其他人的反馈，并且在招聘会议之前，他们不提倡提前对这些反馈进行讨论。</p>
<p>“挑刺者（bar raiser）”面试官负责保持面试的高标准。他们参加特殊的培训，并在负责面试的小组之外对候选人进行面试，以平衡小组的面试反馈。如果一场面试看起来非常困难且与众不同，那很可能就是 bar raiser。这个人在面试方面有丰富的经验，在招聘决定上也有否决权。但是请记住：仅仅因为你在本次面试中应对得很艰难，并不意味着你实际上的表现很差。你的表现是相对于其他候选人来判断的，它不是基于简单的“正确百分比”来评估的。</p>
<p>一旦你的面试官提交了他们的反馈，他们将开会讨论。他们将是做出招聘决定的人。</p>
<p>虽然 Amazon 的招聘人员通常非常善于跟进候选人，但偶尔也会出现延迟。如果你一周内还没有收到 Amazon 的邮件，我们建议你发送一封友好的电子邮件来询问。</p>
<h4 id="必要的准备-1"><a class="header" href="#必要的准备-1">必要的准备：</a></h4>
<p>Amazon 非常注重系统的扩展。确保你为可扩展性问题做好了准备。要回答这些问题，你并不一定需要有分布式系统方面的背景。请参阅我们在系统设计和可扩展性一章中的建议。</p>
<p>此外，Amazon 倾向于问很多关于面向对象设计的问题。建议查看面向对象设计一章的示例问题和建议。</p>
<h4 id="独特之处-1"><a class="header" href="#独特之处-1">独特之处：</a></h4>
<p>Bar Raiser 是由其他团队引进的，以保持高标准。你需要给这个人和招聘经理留下深刻的印象。</p>
<p>Amazon 比其他公司更倾向于在招聘过程中进行试验。这里描述的过程是典型的面试体验，但是由于 Amazon 的试验，它不一定是通用的。</p>
<h3 id="google-面试"><a class="header" href="#google-面试">Google 面试</a></h3>
<p>关于 Google 面试的谣言不绝于耳，但大多数都是谣言。它的面试其实与 Microsoft 或 Amazon 的面试并没有太大不同。</p>
<p>一位 Google 工程师负责第一次电话面试，因此要对棘手的技术问题有个心理准备。这些问题可能涉及编码，有时需要通过共享文档进行编码。应聘者通常被要求遵守相同的标准，在电话视频面试（phone screens）上被问到的问题与现场面试（on-site）时类似。</p>
<p>在现场面试中，你将与四到六个面试官进行面试，其中一个是午餐面试官（lunch interviewer）。每个面试官的反馈对其他面试官是保密的，所以你可以放心，每次面试开始，面试官对你的印象都是空白的。你的午餐面试官不会提交反馈，所以这是一个问诚实问题的好机会。</p>
<p>面试官通常不会被限定到特定的关注点，我们也无法“结构性”地或“系统”地来回答你什么时候会被问到什么问题。每个面试官都可以按照自己的意愿进行面试。</p>
<p>书面反馈将提交给由工程师和经理组成的招聘委员会（HC），最终决定是录用还是不录用。面试反馈通常分为四类（分析能力、编码、经验和沟通），总分从 1.0 到 4.0。HC 通常不包括你的任何面试官。如果包括的话，那纯属偶然。</p>
<p>若发放 offer，HC 希望看到至少有一位面试官是“狂热的支持者（nthusiastic endorser）”。换句话说，得分分别为 3.6、3.1、3.1 和 2.6 的简历比所有得分都是 3.1 分的简历要好。</p>
<p>你不一定需要在每次面试中都表现出色，你的电话面试表现通常也不是影响最终决定的重要因素。</p>
<p>如果 HC 建议发放 offer，你的 packet 将提交给薪酬委员会，然后再提交给执行管理委员会。由于存在许多阶段和委员会，因此返回决策可能需要数周时间。</p>
<h4 id="必要的准备-2"><a class="header" href="#必要的准备-2">必要的准备：</a></h4>
<p>作为一个基于 web 的公司，Google 关心的是如何设计一个可扩展的系统。因此，请确保你准备好了回答系统设计和可扩展性方面的问题。</p>
<p>不论经验如何，Google 都非常重视候选人的分析（算法）技能。即使你认为以前的经验值得考虑，你也应该为这些问题做好充分的准备。</p>
<h4 id="不同之处"><a class="header" href="#不同之处">不同之处：</a></h4>
<p>你的面试官不会做出雇用决定。相反，他们会将反馈信息提交给招聘委员会。招聘委员会将给出一个决定，而 Google 高管有权回绝掉这个决定，虽然他们很少这样做。</p>
<h3 id="apple-面试"><a class="header" href="#apple-面试">Apple 面试</a></h3>
<p>就像 Apple 公司本身一样，Apple 的面试程序也没有什么官僚作风。面试官将寻求优秀的技术技能，但是对职位和公司的热情也很重要。虽然求职者是否为 Mac 用户不是先决条件，但你至少应该熟悉这个系统。</p>
<p>面试过程通常从招聘人员的电话视频面试开始，了解你的基本技能，然后是一系列与团队成员进行的技术电话视频面试。</p>
<p>一旦你被邀请进入园区，通常会是招募人员来向你打招呼，并向你介绍整个招聘流程。然后，你将与申请的职位所在团队的成员，以及与你团队合作的关键人物，进行进行 6~8 次面试。</p>
<p>你需要对一对一（one-on-one）和二对一（two-on-one）的混合面试有心理预期。准备好在白板上写代码，并确保你所有的想法都清楚地传达出来。午餐是和你未来的潜在经理一起吃的，看起来比较随意，但这仍然是一次面试。每个面试官通常专注于一个不同的领域，通常不提倡与其他面试官分享反馈，除非他们想让后续面试官深入了解一些东西。</p>
<p>在一天结束时，你的面试官会互相交换意见。如果每个人都觉得你是一个可行的候选人，你将会和你申请的公司的主管和副总裁进行面试。虽然这个决定是非正式的，但如果你到了这一步，是一个很好的迹象。这一决定也会在幕后发生，如果你不通过，你就会被护送出大楼，而（直到现在）你也不会察觉。</p>
<p>如果你参加过了主管和副总裁的面试，你所有的面试官都会聚集在一个会议室里，给你一个正式的赞成（thumbs up）或反对（thumbs down）。副总裁一般不会出席，但如果他们对招聘不满意，仍然可以否决。招聘人员通常会在几天后跟进，但你可以随时联系他/她，了解最新情况。</p>
<h4 id="必要的准备-3"><a class="header" href="#必要的准备-3">必要的准备：</a></h4>
<p>如果你知道你面试的是哪个团队，确保你仔细了解了他们的产品。你喜欢它什么？你能改进什么？提供具体的建议可以显示你对这份工作的热情。</p>
<h4 id="独特之处-2"><a class="header" href="#独特之处-2">独特之处：</a></h4>
<p>Apple 经常进行二对一的面试，但是不要为此感到压力——这和一对一的面试是一样的！</p>
<p>此外，Apple 员工是 Apple 的铁杆粉丝。你应该在面试中表现出同样的热情。</p>
<h3 id="facebook-面试"><a class="header" href="#facebook-面试">Facebook 面试</a></h3>
<p>一旦被选中参加面试，应聘者通常会进行一两个电话视频面试。电话面试将是技术性的，并且会涉及编码，通常是使用线文档编辑器。</p>
<p>在电话面试之后，你可能会被要求做一个家庭作业，其中包括编码和算法的混合题目。在这里注意你的编码风格。如果你从未在一个有完整代码评审（code review）的环境中工作过，那么找一个必须评审你代码的人可能是个好主意。</p>
<p>在现场面试中，你将主要与其他软件工程师进行面试，但只要招聘经理有空，他们也会参与进来。所有的面试官都经过了全面的面试培训，与你进行面试的人是跟你获得 offer 的几率没有联系的。</p>
<p>在现场面试中，每位面试官都被赋予一个“角色”，这有助于确保没有重复的问题，并且可以全面了解候选人。这些角色是：</p>
<ul>
<li>
<p><strong>工作经历（“绝地武士（Jedi）”）</strong>：这个面试评估你在 Facebook 的环境下取得成功的能力。你能很好地适应这种文化和价值观吗？你对什么感到兴奋？你如何应对挑战？请准备好谈论你对 Facebook 的兴趣，因为 Facebook 需要的是有激情的人。在这次面试中，你可能还会被问到一些编码问题。</p>
</li>
<li>
<p><strong>编码和算法（“忍者（Ninja）”）</strong>：这些是标准编码和算法问题，就像你在本书中会发现的一样。这些问题被设计成极具有挑战性。你可以使用任何你想用的编程语言。</p>
</li>
<li>
<p><strong>设计/架构（“海盗（Pirate）”）</strong>：对于后端软件工程师，你可能会被问到系统设计问题。前端或其他专业将被问及与该学科相关的设计问题。你应该开放地讨论不同的解决方案及其权衡。</p>
</li>
</ul>
<p>通常，你需要做好进行两次“忍者”面试和一次“绝地”面试的准备。经验丰富的候选人通常也将接受一次“海盗”面试。面试结束后，面试官在互相讨论你的表现之前会提交书面反馈。这可以确保你在一次面试中的表现不会因其他面试官的反馈而产生偏见。</p>
<p>一旦每个人的反馈都被提交，你的面试团队和招聘经理会聚在一起，共同做出最终决定。他们达成共识，并向招聘委员会提交了最终的招聘建议。</p>
<h4 id="必要的准备-4"><a class="header" href="#必要的准备-4">必要的准备：</a></h4>
<p>作为“精英”科技公司中最年轻的一家，Facebook 希望开发人员具有创业精神。在面试中，你应该表现出你喜欢快速构建东西。</p>
<p>他们想知道，你可以使用任何一种选择的语言共同构建出一个优雅的、可扩展的解决方案。了解 PHP 并不是特别重要，特别是考虑到 Facebook 还使用 C++、Python、Erlang 和其他语言做了大量后端工作。</p>
<h4 id="独特之处-3"><a class="header" href="#独特之处-3">独特之处：</a></h4>
<p>Facebook “一般来说“是从整个公司层面出发来面试开发人员的，而不是为某个特定的团队。如果你被录用，你将参加一个为期六周的“训练营”，这将帮助你在庞大的代码库中不断提升。你将获得高级开发人员的指导，学习最佳实践，最终，在选择项目时，你将获得比在面试中分配到项目时更大的灵活性。</p>
<h3 id="palantir-面试"><a class="header" href="#palantir-面试">Palantir 面试</a></h3>
<p>不像有些公司会进行“合并（pooled）”面试（你是从整个公司的角度被面试的，而不是针对某个特定的团队），Palantir 是为一个特定的团队进行面试的。有时候，你的申请可能会被更改到（re-routed）到另一个更合适的团队。</p>
<p>Palantir 的面试流程通常从两次电话面试开始。这些面试大约 30 到 45 分钟，并且主要是技术性的。希望你能介绍一些你以前的经验，并将重点放在算法相关的问题上。</p>
<p>你还可能需要接受一次 HackerRank 编码评估，它将评估你编写最优算法和正确代码的能力。经验不足的求职者，比如大学毕业生，特别有可能参加这样的测试。</p>
<p>在此之后，成功的候选人将被邀请到园区，并将接受多达五人的面试。现场面试的内容涵盖了你以前的经验、相关的领域知识、数据结构和算法，以及系统设计。</p>
<p>你还可能得到 Palantir 产品的演示。问一些好的问题，并展示你对公司的热情。</p>
<p>面试结束后，面试官会和招聘经理开会讨论面试反馈结果。</p>
<h4 id="必要的准备-5"><a class="header" href="#必要的准备-5">必要的准备：</a></h4>
<p>Palantir看重雇佣优秀的工程师。许多求职者表示，Palantir的问题比他们在谷歌和其他顶级公司遇到的问题更难回答。这并不一定意味着获得一份工作更难（尽管确实可以）;这只是意味着面试官更喜欢更具挑战性的问题。如果你在面试 Palantir，你应该彻底了解核心数据结构和算法。然后，集中精力准备最难的算法问题。</p>
<p>如果你正在面试一个后端职位，也要温习一下系统设计。这是这个过程的一个重要部分。</p>
<h4 id="独特之处-4"><a class="header" href="#独特之处-4">独特之处：</a></h4>
<p>编写代码是 Palantir 面试流程中的常见部分。尽管你可以使用计算机，并且可以根据需要查找资料，但不要毫无准备地走进办公室。这些问题可能极具挑战性，并且将评估算法的效率。充分的面试准备将对你有所帮助。你也可以在 <code>HackerRank.com</code> 网站上在线练习编程挑战。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iii-特殊情况-1"><a class="header" href="#iii-特殊情况-1">III. 特殊情况</a></h1>
<p>促使某人读这本书的原因有很多。或许是你工作经验丰富，但从未进行过此类面试。或许你是一名测试人员或 PM。或许你实际上是在使用这本书来教自己如何更好地进行面试。这些“特殊情况（special situations）”都能在本章有所收获。</p>
<h3 id="有经验的候选人"><a class="header" href="#有经验的候选人">有经验的候选人</a></h3>
<p>有些人认为，你在本书中看到的算法类问题只适用于应届毕业生，这并不完全正确。</p>
<p>更有经验的工程师可能会发现面试中对算法问题的关注略有减少——但也只是略有减少。</p>
<p>如果一家公司向没有经验的候选人提出算法问题，他们往往也会向有经验的候选人提出。无论对错，他们都认为这些问题中展示的技能对所有开发人员都很重要。</p>
<p>一些面试官可能会对有经验的候选人的标准有所较低。毕竟，这些候选人已经多年没有上过算法课了。他们缺乏练习。</p>
<p>另一些人则对有经验的候选人提出了更高的标准，他们的理由是，更多的经验使候选人可以看到更多类型的问题。</p>
<p>平均而言，两种观点是平衡的。</p>
<p>这个规则的例外是系统设计和架构问题，以及有关于你简历的问题。通常情况下，学生不会学习太多系统架构的知识，所以只有在专业领域才能积累处理这方面问题的经验。你在此类面试问题中的表现将根据你的经验水平进行评估。然而，学生和应届毕业生仍然会被问到这些问题，他们应该做好准备，尽可能地解决这些问题。</p>
<p>此外，经验丰富的候选人将被要求对诸如 “你遇到的最困难的 bug 是什么？” 等问题做出更深入的、更令人印象深刻的回答。如果你经验丰富，对这些问题的回答应该可以证明这一点。</p>
<h3 id="测试人员和-sdet"><a class="header" href="#测试人员和-sdet">测试人员和 SDET</a></h3>
<p>SDET（测试中的软件设计工程师，software design engineers in test）工作中需要编写代码，但是这些代码是用来测试功能而不是构建功能的。因此，他们必须既是出色的编码人员，又是出色的测试人员。需要双倍的准备工作！</p>
<p>如果你要申请 SDET 职位，请采用以下方法来进行准备：</p>
<ul>
<li>准备核心测试问题：例如，你将如何测试一个灯泡？一支钢笔？ 一台收银机？Microsoft Word ？“测试，Testing” 一章将为你提供关于这些问题的更多背景知识。</li>
<li>练习编码问题：SDET 被拒绝的首要原因是编码能力不够。虽然 SDET 的编码标准通常低于传统开发人员，但是仍期望 SDET 能有较强的编码和算法能力。在准备时，一定要练习解决普通开发人员可能遇到的所有相同的编码和算法问题。</li>
<li>练习测试代码问题：一个非常流行的 SDET 问题格式是“编写代码以实现 X 功能”，紧接着就会被要求：“好的，现在对其进行测试。”即使问题不是特别要求这样做，你也应该问自己，“我将如何测试这个？”记住：任何问题都可能变成一个 SDET 问题！</li>
</ul>
<p>对于测试人员来说，良好的沟通技巧也非常重要，因为你的工作需要你与许多不同的人一起工作。不要忽视 “行为问题，Behavioral Questions”  这一章的内容。</p>
<h4 id="职业建议"><a class="header" href="#职业建议">职业建议</a></h4>
<p>最后，给你一个职业建议：如果你像许多候选人一样，希望通过申请 SDET 职位这种“简单”的方式进入某个公司，那你该知道的是，许多候选人发现从 SDET 职位转到开发职位非常困难。如果你计划这样做的话，请确保你的编码和算法技能非常突出，并尝试在一到两年内转换职位。否则，你可能会发现在开发面试中很难被认真对待。</p>
<p>永远不要让你的编程技能退化。</p>
<h3 id="产品和项目-经理"><a class="header" href="#产品和项目-经理">产品（和项目） 经理</a></h3>
<p>这些 “PM” 角色在不同的公司甚至在同一公司内部都有很大的差异。例如，在 Microsoft，一些 PM 本质上可能是客户传道者（customer evangelists），扮演着与市场营销沾边的面向客户的角色。不过，在整个园区里，其他 PM 可能需要花费很多时间进行编码。后一种 PM 的职位在面试时可能会对候选人在编码上进行测试，因为这是其工作功能的重要部分。</p>
<p>一般来说，负责 PM 职位的面试官希望候选人能展示以下方面的技能：</p>
<ul>
<li>处理模棱两可：这通常不是面试中最关键的部分，但你也应该知道面试官确实看重候选人这方面的能力。面试官希望看到的是，当面对一个模棱两可的情况时，你不会不知所措，也不会停滞不前。他们希望看到你能够正面处理问题：寻找新信息，优先处理最重要的部分，并以结构化的方式解决问题。这通常在面试中不会直接考察（虽然可以），但在面试问题的回答中，面试官会留意候选人这方面的特质。</li>
<li>以用户为中心（态度）：面试官希望看到你以用户为中心的态度。你认为每个人都会像你一样使用这个产品吗？或者，你是那种设身处地为客户着想，试图理解他们想如何使用产品的人？诸如 “为盲人设计一个闹钟” 之类的问题已经成熟，可以用来考察候选人这一方面的特质。当你听到这样的问题时，一定要问很多问题来了解用户是谁，以及他们如何使用产品。“测试，Testing ” 一章中涉及的技能与此密切相关。</li>
<li>以用户为中心（技术技能）：一些拥有更复杂产品的团队需要确保他们的 PM 对产品有更深刻的理解，因为在工作中很难获得这些知识。在 Android 或 Windows Phone 的团队中，可能不需要具备深入的手机技术知识（尽管这仍然是件好事），而在 Windows Security 团队中，对安全性相关知识的了解可能是必要的。希望你不会去面试一个需要特殊技能的团队，除非你至少声称自己已经拥有了必要的技能。</li>
<li>多级沟通：PM 需要能够与公司各个级别的人员沟通，跨越多个职位和技术技能范围。面试官希望看到你在沟通中拥有这种灵活性。这通常是通过诸如 “向祖母解释 TCP/IP” 之类的问题来直接检验的。也可能通过与你讨论先前项目的方式来评估你的沟通技巧。</li>
<li>对技术的热情：快乐的员工是富有生产力的员工，因此公司想要确保你会喜欢这份工作，并对你的工作内容感到兴奋。对技术的热情——最好是对公司或团队的热情——应该体现在你的回答中。你可能会被直接问到这样的问题，例如 “你为什么对微软感兴趣？”此外，面试官会在你如何谈论你以前的经历，以及你如何谈论团队的挑战时，来发现你对工作的热情。他们想看到的是，你会渴望面对工作中的挑战。</li>
<li>团队合作/领导力：这可能是面试中最重要的方面，而且，毫不奇怪，在工作中也是最重要的。所有的面试官都会考察你与他人合作的能力。最常见的评估方法是这样的：“请给出一个队友没有尽到自己职责的例子”。面试官希望看到你能很好地处理冲突，你能采取主动，你能理解他人，人们喜欢和你一起工作。你为行为问题做的准备工作在这里将非常重要。</li>
</ul>
<p>以上所有方面都是 PM 需要掌握的重要技能，因此也是面试的重点领域。这些方面的权重将与该领域在实际工作中的重要性大致匹配。</p>
<h3 id="开发主管和经理"><a class="header" href="#开发主管和经理">开发主管和经理</a></h3>
<p>开发主管职位和经理职位几乎总是需要候选人具备强大的编码技能。如果你要在工作中进行编码，请确保对代码和算法非常精通，就像开发人员一样。尤其是 Google，在编码方面对管理人员要求很高。</p>
<p>此外，准备接受以下各方面的技能检查：</p>
<ul>
<li>团队合作/领导力：任何担任管理角色的人都必须既能领导他人，又能与他人共同合作。你将在这些方面接收隐式和显式的考察。显示的评估（explicit evaluation）将以询问你如何处理之前工作中的情况的形式出现，比如你与经理意见相左的时候你怎么应对。隐式的评估（implicit evaluation）以面试官观察你如何与他们互动的形式出现。如果你太自负或太被动，面试官可能会觉得你不足以担任管理职位。</li>
<li>优先级排序：管理人员经常会面临棘手的问题，例如如何确保团队在紧张的截止日期前完成任务。你的面试官会希望你可以适当地确定项目的优先级，从而减少处理次要工作的精力。优先级排序意味着提出正确的问题，以了解什么是关键的，什么是你可以在合理预期内完成的。</li>
<li>沟通：管理人员需要与他上下级的人员进行沟通，也可能与客户或其他技术水平较低的人员进行沟通。面试官希望看到你可以进行多层次的交流，而且是以一种友好和吸引人的方式进行。在某种程度上，这也是对你个性的一种评估。</li>
<li>“把事情做好”：也许管理者可以做的最重要的事情就是“把事情做好”。这意味着在为项目做准备和实际执行之间取得适当的平衡。你需要了解如何组织一个项目，如何激励员工，这样你才能完成团队的目标。</li>
</ul>
<p>最终，这些方面的大部分都会回到你之前的经历和你的个性上来。一定要使用面试准备表格进行非常非常彻底的准备。</p>
<h3 id="初创公司"><a class="header" href="#初创公司">初创公司</a></h3>
<p>不同初创公司的申请和面试过程相差很大。我们不能逐一介绍每一家初创公司，但我们可以提供一些一般性的建议。但是，要明白，特定的初创公司的面试流程可能与此有所不同。</p>
<h4 id="申请流程"><a class="header" href="#申请流程">申请流程</a></h4>
<p>许多初创公司可能会发布招聘信息，但对于最热门的初创公司来说，通常最好的方式是通过个人推荐。这个推荐人不一定是你的密友或同事。通常情况下，只要你主动表达你的兴趣，你就能让别人拿起你的简历，看看你是否适合这份工作。</p>
<h4 id="签证和工作授权"><a class="header" href="#签证和工作授权">签证和工作授权</a></h4>
<p>不幸的是，美国许多规模较小的初创公司无法提供工作签证。他们和你一样讨厌这个制度，但无论如何你都无法说服他们雇用你。如果你需要签证并且希望在一家初创公司工作，你最好的选择是联系一位与许多初创公司合作的专业招聘人员（他们可能对哪些初创公司会处理签证问题有更好的了解），或者把搜索重点放在更大的初创公司上。</p>
<h4 id="简历筛选因素"><a class="header" href="#简历筛选因素">简历筛选因素</a></h4>
<p>初创公司往往希望工程师不仅聪明、会编程，而且还要能在创业环境中出色工作。理想情况下，你的简历应该显示出你的主动性。例如，你从头开始做过哪些项目？</p>
<p>能够“立即上手（hit the ground running）”也非常重要，他们想要那些已经了解公司语言的人。</p>
<h4 id="面试过程"><a class="header" href="#面试过程">面试过程</a></h4>
<p>大公司往往主要关注你在软件开发方面的总体能力，而初创公司则通常会密切关注你的个性、技能和先前的经验。</p>
<ul>
<li>性格契合度：性格契合度通常由你与面试官的互动方式来评估。和面试官建立一个友好的、有吸引力的对话是你获得很多工作机会的敲门砖。</li>
<li>技术栈：因为初创公司需要能够立即上手的人，所以他们很可能会用特定的编程语言来评估你的能力。如果你知道该创业公司使用的语言，一定要温习一下细节。</li>
<li>经验：初创公司可能会问你很多有关你工作经验的问题。请特别注意“行为问题”这章的内容。</li>
</ul>
<p>除上述方面外，你在本书中看到的编码和算法问题在初创公司的面试过程中也非常常见。</p>
<h3 id="收购acquisitions和收购雇佣acquihires"><a class="header" href="#收购acquisitions和收购雇佣acquihires">收购（Acquisitions）和收购雇佣（Acquihires）</a></h3>
<p>在对许多收购进行技术尽职调查（due diligence）的过程中，收购方通常会对初创公司的大部分或全部员工进行重新面试。Google、Yahoo、Facebook 和许多其他公司都将此过程作为许多收购的的标准组成部分。</p>
<h4 id="哪些初创公司会经历这种情况-又为什么呢"><a class="header" href="#哪些初创公司会经历这种情况-又为什么呢">哪些初创公司会经历这种情况？ 又为什么呢？</a></h4>
<p>进行收购面试，的部分原因是收购方认为他们的员工必须经过这个过程才能被雇佣。他们不希望收购成为这些员工进入公司的“捷径”。而且，由于被收购的方的团队是收购的核心动力，因此他们认为评估团队的技能是很有意义的。</p>
<p>当然，并非所有的收购都是这样的。著名的数十亿美元收购通常不需要经过这个过程。毕竟，这些收购通常是针对用户群和社区的，而与员工甚至技术无关。这时估团队的技能就不是那么重要了。</p>
<p>但是，这并不像 “收购雇佣需要面试而传统收购则不需要” 那么简单。雇佣收购（即人才收购）和产品收购之间存在很大的灰色地带。许多初创公司是因其团队和技术背后的想法而被收购的。因而收购完成后，收购方可能会中止原来产品的生产，但要让团队从事非常相似的工作。</p>
<p>如果你的创业公司正在经历这个过程，通常你需要做好你的团队有非常类似于普通候选人的面试经历的准备（因此，非常类似于你将在本书中看到的）。</p>
<h4 id="这些面试有多重要"><a class="header" href="#这些面试有多重要">这些面试有多重要？</a></h4>
<p>这些面试具有极大的重要性。它们在以下三种不同方面扮演着重要的角色：</p>
<ul>
<li>它们可以决定收购的成败与否。这往往是一家公司无法被收购的原因。</li>
<li>它们决定了哪些员工可以收到加入收购方公司的 offer</li>
<li>它们可以影响收购价格（部分因素是加入的员工数量）。</li>
</ul>
<p>这些面试不仅仅是走个形式。</p>
<h4 id="哪些员工需要接受面试"><a class="header" href="#哪些员工需要接受面试">哪些员工需要接受面试？</a></h4>
<p>对于科技初创公司来说，通常所有的工程师都要经过面试，因为他们是收购的核心动力之一。</p>
<p>此外，销售、客户支持、产品经理以及任何其他角色可能都必须经历这个过程。</p>
<p>通常会将初创公司的 CEO 安排在产品经理或开发经理的职位面试中，因为这通常是与 CEO 当前职责最接近的匹配项。但是，这并不是一个绝对的规则。这取决于 CEO 目前的角色和他感兴趣的是什么。在我的一些客户中，CEO  甚至选择不进行面试，而是在收购完成后离开公司。</p>
<h4 id="在面试中表现不佳的员工会怎么样"><a class="header" href="#在面试中表现不佳的员工会怎么样">在面试中表现不佳的员工会怎么样？</a></h4>
<p>表现不佳的员工通常不会收到加入收购方的 offer。（如果许多员工表现不佳，那么收购很可能不会成功。）</p>
<p>在某些情况下，出于“知识转移（knowledge transfer）”的目的，一些面试表现不佳的员工会获得合同职位。但是这些职位是临时的，预期中员工将在合同终止时离职（通常是 6 个月），尽管有时员工最终会被留下来。</p>
<p>在其他情况下，糟糕的表现是由于员工被安置在错误的位置上（mis-slotted）造成的。这种问题通常发生在两种情况下：</p>
<ul>
<li>
<p>有时候，一家初创公司会把不是“传统”软件工程师的人贴上软件工程师的标签。这经常发生在数据科学家或数据库工程师身上。这些人可能在软件工程师面试中表现不佳，因为他们的实际角色涉及其他技能。</p>
</li>
<li>
<p>在其他情况下，CEO将一名初级软件工程师向高于其实际水平的高级职位进行“推销”。这就使这名工程师在高级职位的面试中表现不佳，因为他被要求达到不公平的高标准。</p>
</li>
</ul>
<p>在这两种情况下，有时都会对员工进行重新面试以找到更合适的职位。（不过，其他时候，员工就没这么走运了。）</p>
<p>在极少数情况下，首席执行官能够推翻对一个特别优秀的员工的面试决定，即使他在面试中的表现并没有反映出有什么问题。</p>
<h4 id="你最佳和最差员工可能会让你大吃一惊"><a class="header" href="#你最佳和最差员工可能会让你大吃一惊">你“最佳”（和最差）员工可能会让你大吃一惊。</a></h4>
<p>在顶级科技公司进行的问题解决（problem-solving）/算法（algorithm）面试评估的是特定技能，而这些技能可能并不完全符合他们的经理对员工的评估。</p>
<p>我曾与许多公司合作过，他们对面试中表现最好和最差的员工感到惊讶。在这些面试中，对专业发展还有很多需要学习的初级工程师可能会成为一个很好的问题解决者。</p>
<p>除非你已经按照他们的面试官的方式对他们进行了评估，否则请不要把任何人排除在外。</p>
<h4 id="员工是否要面临与典型的候选人相同的标准"><a class="header" href="#员工是否要面临与典型的候选人相同的标准">员工是否要面临与典型的候选人相同的标准？</a></h4>
<p>本质上是的，尽管有更多的回旋余地。</p>
<p>大公司倾向于采取规避风险的招聘方式。如果对某人的是否录用持观望态度，他们往往倾向于不雇佣。</p>
<p>在收购的情况下，“保持观望（on the fence）”的员工可以由于其所在团队其他成员的出色表现而获得通过。</p>
<h4 id="员工对收购收购雇佣的消息有什么反应"><a class="header" href="#员工对收购收购雇佣的消息有什么反应">员工对收购/收购雇佣的消息有什么反应？</a></h4>
<p>这是许多初创公司 CEO 和创始人非常关心的问题。员工会对这个过程感到不安吗？或者，如果我们让他们燃起希望，但却没有实现呢？</p>
<p>我从我的客户那里看到，领导层对此担心的程度超出了必要。</p>
<p>当然，是有一些员工对这个过程感到不安。出于种种原因，他们可能不会对加入一家大公司感到兴奋。</p>
<p>不过，大多数员工对这个过程持谨慎乐观的态度。他们希望收购能完成，但他们知道，这些面试的存在意味着它也有可能不会顺利完成。</p>
<h4 id="收购之后团队会发生什么"><a class="header" href="#收购之后团队会发生什么">收购之后团队会发生什么？</a></h4>
<p>每种情况都是不同的。但是，我的大多数客户都被作为一个团队被整体保留，或者可能集成到一个现有的团队中。</p>
<h4 id="你应该如何准备团队的收购面试"><a class="header" href="#你应该如何准备团队的收购面试">你应该如何准备团队的收购面试？</a></h4>
<p>收购面试的面试准备与收购方的典型面试相当相似。不同之处在于，你的公司是作为一个团队来完成此任务的，而不是根据每个员工的优点来单独挑选他们参加面试。</p>
<p><em>你们都是一伙的。</em></p>
<p>与我合作过的一些初创公司搁置了他们的“实际”工作，并让他们的团队在接下来的两到三周时间里准备面试。</p>
<p>显然，这不是所有公司都能做出的选择，但是，从希望收购得以进行的角度来看，这确实可以大大提高你的业绩。</p>
<p>你的团队应该单独学习，或两三个人一组，或者进行模拟面试。如果可能，请使用这三种方法。</p>
<p><em>有些人可能比其他人准备得少。</em></p>
<p>许多初创公司的开发人员可能只是模糊地听说过算法复杂度（big O time）、二分搜索树、广度优先搜索和其他重要概念。他们将需要一些额外的时间来准备。</p>
<p>没有计算机科学学位的人（或很久以前获得学位的人）应该首先专注于学习本书中讨论的核心概念，尤其是 big O time（这是最重要的一个）。一个很好的第一步是从头开始实现所有核心数据结构和算法。</p>
<p>如果收购对你的公司很重要，给这些人足够的时间来准备。他们会需要它。</p>
<p><em>不要等到最后一分钟。</em></p>
<p>作为一家初创公司，你可能习惯了在没有大量计划的情况下进行工作。但如果你在收购面试时还是这种态度的话，结果往往不会很好。</p>
<p>收购面试经常是突然出现的。一家公司的 CEO 正在与一位收购方（或几个收购方）交谈，谈话变得越来越严肃。收购方提到未来某一时刻进行面试的可能性。然后，突然间，出现了一条“本周末到”的消息。</p>
<p>如果你等到一个确定的面试日期，你可能就只有几天的时间来准备了。你的工程师可能没有足够的时间来学习核心的计算机科学概念并练习面试问题。</p>
<h3 id="给面试官"><a class="header" href="#给面试官">给面试官</a></h3>
<p>自编写上一版以来，我了解到许多面试官正在使用 “Cracking the Coding Interview” 来学习如何进行面试。这并不是本书的真正意图，但我不妨为面试提供一些指导。</p>
<h4 id="实际面试中不要问本书出现的确切问题"><a class="header" href="#实际面试中不要问本书出现的确切问题">实际面试中不要问本书出现的确切问题。</a></h4>
<p>首先，本书中选择这些问题是因为它们非常适合面试准备。但是一些适合面试准备的问题并不总是适合面试。例如，本书中有一些脑筋急转弯，因为有时面试官会问这类问题。如果候选人在一家喜欢这些问题的公司面试，那么练习这些问题是值得的，尽管我个人认为这些问题很糟糕。</p>
<p>其次，你的候选人也在读这本书。你应该不想问你的候选人哪些已经解决了的问题吧。</p>
<p>你可以问类似的问题，但不要只是把问题从这里拿出来。你的目标是测试他们解决问题的能力，而不是他们的记忆能力。</p>
<h4 id="问中等和困难难度的问题"><a class="header" href="#问中等和困难难度的问题">问中等和困难难度的问题</a></h4>
<p>这些问题的目的是评估一个人解决问题的能力。当你问一些过于简单的问题时，候选人的表现就不能完全发挥。简单问题会严重影响一个人的表现。这不是一个可靠的指标。</p>
<h4 id="寻找有多个障碍的问题"><a class="header" href="#寻找有多个障碍的问题">寻找有多个障碍的问题。</a></h4>
<p>有些问题会有一个“啊哈！”的时刻。它们基于一种特殊的洞察力。如果候选人没有 get 到这个点，那么他们的表现就会很差。如果他们 get 到了这点，那么他们的表现突然就会胜过许多候选人。</p>
<p>即使这种洞察力是技能的一个指标，它仍然只是一个指标。理想情况下，你需要一个具有一系列障碍、见解或优化的问题。多个考察点胜过一个考察点。</p>
<p>这里有一个测试：如果你能给一个提示或指导，使一个候选人的表现有很大的不同，那么这可能不是一个很好的面试问题。</p>
<h4 id="使用困难的问题而不是困难的知识"><a class="header" href="#使用困难的问题而不是困难的知识">使用困难的问题，而不是困难的知识。</a></h4>
<p>有些面试官，为了把一个问题弄得很难，无意中使用到了困难的知识。果然，很少有候选人表现出色，所以统计数据看起来是正确的，但这并没有准确反映出候选人的技能水平。</p>
<p>你期望候选人拥有的知识应该是相当简单的数据结构和算法知识。希望计算机科学专业的毕业生了解 big O 和树的基本知识是合理的。大多数人不会记得 Dijkstra 算法，也不会记得 AVL 树是如何工作的。</p>
<p>如果你的面试问题需要晦涩的知识，问问自己：这真的是一项重要的技能吗？它是否做够重要，以至于我不惜减少雇佣的候选人的数量，或者减少我对候选人解决问题能力或其他技能的关注度？</p>
<p>你评估的每项新的技能或属性都会减少 offer 的发放数量，除非你通过放宽对另一项技能的要求来平衡这一点。当然，在候选人其他条件都相同的情况下，你可能更喜欢能背诵两英寸厚的算法教科书中详细内容的人。但是实际上候选人的其他条件是不一样的。</p>
<h4 id="避免出现吓人的问题"><a class="header" href="#避免出现吓人的问题">避免出现“吓人的”问题。</a></h4>
<p>有些问题会吓到候选人，因为这些问题看起来好像涉及到了一些专业知识，即使它们实际上并没有。这通常包括以下问题：</p>
<ul>
<li>数学或概率。</li>
<li>底层知识（内存分配等）。</li>
<li>系统设计或可扩展性。</li>
<li>专有系统（Google 地图等）。</li>
</ul>
<p>例如，我有时会问的一个问题是找出 1000 以下的满足 a^3 + b^3 = c^3 + d^3的所有正整数解（第68页）。</p>
<p>首先，许多候选人会认为他们必须对上面这种或其他比较高级数学做一些花哨的因式分解。其实他们并不需要这么做。他们只需要了解指数、总和与相等这些概念，仅此而已。</p>
<p>当我问这个问题时，我明确地说，“我知道这听起来像一个数学问题。别担心。它不是。这是一个算法问题。”如果他们开始沿着因式分解的道路走下去，我会阻止他们，并提醒他们这不是一个数学问题。</p>
<p>其他问题可能涉及一些概率。它可能是候选人肯定知道的东西（例如，从5个选项中选择一个，从1到5中选择一个随机数），但事实上仅仅因为它包含概率就会吓到候选人。</p>
<p>问一些听起来吓人的问题要小心。记住，面试本身对候选人来说已经是非常紧张了。加上一个“吓人的”问题可能只会让候选人感到更加慌乱，从而导致他表现不佳。</p>
<p>如果你要问一个听起来“很吓人”的问题，那么你要确保让候选人放心，这个问题并不需要他们下意识以为要使用到的知识。</p>
<h4 id="给予积极的心理强化"><a class="header" href="#给予积极的心理强化">给予积极的心理强化。</a></h4>
<p>有些面试官过于关注“正确”的问题，以至于忘了考虑自己的行为。</p>
<p>许多候选人被面试吓倒了，他们试着去理解面试官的每一个字。他们会抓住每一件听起来可能是积极或消极的事情不放。他们会把“祝你好运”这句话理解为某种意义，即使你对每个人都说了这句话，无论其表现如何。</p>
<p>你需要让候选人对面试体验、对你以及自己的表现感到满意。你要使他们感到轻松自在。一个紧张的候选人会表现得很差，但这并不意味着他们不好。此外，一个对你或公司有负面感受的优秀的候选人不太可能接受 offer——他们也可能劝阻他们的朋友不要到你这儿面试或接受 offer。</p>
<p>试着对候选人热情友好。可能有些人很容易做到这一点而有些人不行，但是要尽你最大的努力。</p>
<p>即使你不是天生热情友好的人，你也可以在整个面试过程中努力说一些积极的话：</p>
<ul>
<li>“对，没错。”</li>
<li>“很好的观点。”</li>
<li>“做的不错。”</li>
<li>“是的，这是一个非常有趣的方法。”</li>
<li>“完美。”</li>
</ul>
<p>不管候选人表现得有多差，总有一些事情是他们做对了的。想办法在面试中注入一些积极的因素。</p>
<h4 id="深入挖掘行为问题"><a class="header" href="#深入挖掘行为问题">深入挖掘行为问题。</a></h4>
<p>你问他们一个关于工作中遇到的具有挑战性的场景的问题，他们会告诉你他们团队所面临过的困境。那从你的角度看来，这位候选人并没有做太多事情。</p>
<p>不过不要那么快下结论。候选人可能只是不会专注于自己，因为他们在以往的工作中都是庆祝团队的成就，而不是吹嘘自己。这在担任领导职务的人和女性候选人中尤其常见。</p>
<p>不要仅仅因为你理解不了一个候选人做了什么，就认为他在某种情况下没有做什么事情。（委婉地）说出情况。具体询问他们是否可以告诉你他们的角色是什么。</p>
<p>如果这听起来并不是真的解决了困难的问题，那么，再一次，深入探究。让他们更详细地说明他们是如何看待这个问题的，以及他们采取了哪些不同的步骤。问问他们为什么要采取某些行动。不描述自己所采取行动的细节只能说明他们是一个有瑕疵的候选人，但不一定是一个有瑕疵的员工。</p>
<p>成为一名优秀的面试候选人本身就是一项能力（毕竟，这也是本书存在的原因之一），而且你可能不想对这项能力进行评估。</p>
<h4 id="指导你的候选人"><a class="header" href="#指导你的候选人">指导你的候选人。</a></h4>
<p>通读有关候选人如何开发良好算法的章节。这些建议中有很多是你可以提供给那些正在挣扎的候选人的。当你这样做时，你并不是在“教如何面试”，你只是把他们的面试能力与工作能力给分开了。</p>
<ul>
<li>很多候选人不会用一个例子来帮助解决面试问题（或者他们不会用一个好的例子）。这大大增加了他们给出答案的难度，但这并不一定意味着他们不是很好的问题解决者。如果候选人自己没有写一个例子，或者他们无意中写了一个特殊的用例，请指导他们。</li>
<li>有些候选人需要很长时间才能找到 bug，因为他们使用了一个非常大的用例。这并不会使他们成为一个糟糕的测试人员或开发人员。这只是意味着他们没有意识到，先从概念上分析他们的代码会更有效，或者一个小的例子几乎可以工作得一样好。引导他们。</li>
<li>如果他们在找到最优解之前就开始深入研究代码，那么把他们拉回来，把注意力集中在算法上（如果这是你想看到的）。如果是因为候选人真的没有时间，就说他从未找到或实现过最优解决方案，那绝对是不公平的。</li>
<li>如果他们感到紧张不安，不知道下一步该怎么做时，可以建议他们先使用通过蛮力（brute force）解决的方案，再寻找可以优化的方面。</li>
<li>如果他们什么都没说，而且这道题有一种相当明显的蛮力解决方法时，提醒他们先从蛮力开始是没关系的。他们的第一个解决方案不一定必须是完美的。</li>
</ul>
<p>即使你认为候选人在这些方面的能力是一个重要因素，但这并不是唯一的因素。你完全可以将某人标记为“未通过”此障碍，但同时要帮助并引导他们越过这一障碍。</p>
<p>虽然这本书的目的是指导候选人通过面试，但作为面试官，你的目标之一就是消除候选人没有准备对面试表现的影响。毕竟，有些候选人已经为面试做过准备，而有些则没有，但这可能并不能充分说明他们作为工程师的能力。</p>
<p>使用本书中的建议指导候选人（当然，要在合理的范围内——毕竟你不希望因为过多地指导候选人，以至于无法评估他们解决问题的能力）。</p>
<p>不过在这里要小心。如果你本身就使候选人生畏，那这种指导可能会让事情变得更糟。当你告诉候选人，他们在不断地创建错误的例子，没有优先考虑正确的测试方法，等等，这往往会把事情搞砸。</p>
<h4 id="如果他们想要安静就给他们安静"><a class="header" href="#如果他们想要安静就给他们安静">如果他们想要安静，就给他们安静。</a></h4>
<p>候选人最常问我的一个问题是，当他们只需要安静地思考一会儿的时候，面试官却执意要开口说话，他们该如何应对这种情况。</p>
<p>如果你的候选人需要安静，那就给他时间思考。学会区分候选人的 “我被困住了，不知道该做什么” 和 “我在默默地思考” 这两种状态。</p>
<p>这可能会帮你来决定是否要指导你的候选人，因为你的指导可能会帮助到很多候选人，但这不一定会帮助到所有的候选人。因为有些人反而需要一点时间来自己思考。给他们时间，这样当你评估他们的时候，就要考虑到他们得到的指导比其他人少。</p>
<p>####了解你的模式：常规检查、质量、专家级和指代型。</p>
<p>在非常非常高的层次上，有四种问题模式：</p>
<ul>
<li><strong>常规检查</strong>：这些通常是简单的问题解决型（problem-solving）问题或设计问题。它们被用来评估候选人解决问题的最低能力。不能通过这些问题来区分候选人的能力是 “okay” 还是 “great”。你可以在面试流程早期使用这类问题（过滤掉最差的候选人），或者当你只是需要最低程度能力的候选人时也可以使用。</li>
<li><strong>质量检查</strong>：这些都是更具挑战性的问题，通常在问题解决或设计中。这类问题被设计得比较严谨，真正需要候选人去思考。当算法/解决问题的技能非常重要时，使用这些技巧。在这种情况下，面试官犯的最大的错误是问一些实际上不是很好的问题解决型问题。</li>
<li><strong>专家级问题</strong>：这些问题用于测试特定主题的知识，例如 Java 或机器学习。一项技能，只有当一个优秀的工程师在工作中不能快速学会时，才应该使用专业问题对其进行考察。这些问题必须确实是专家级别的问题。不幸的是，我曾经遇到过这样的情况，一家公司询问刚刚完成了为期 10 周的编程训练营的候选人有关 Java 的详细问题。这又能说明什么呢？如果她有这方面的知识，那么这也只是她最近才学到、并且轻松掌握的知识。如果这项技能很容易学会，那么就没有理由以此来决定候选人是否被雇佣。</li>
<li><strong>指代型知识</strong>：这是一种不太专业的知识（事实上，你甚至可能不需要它），但是你希望与他们级别相同的候选人知道。例如，如果候选人知道CSS或HTML，这对你来说可能不是很重要。但是，如果候选人深入研究了这些技术，却不能谈论为什么表格好或不好，这就说明了一个问题。他们没有在工作中吸收核心信息。</li>
<li><strong>代理知识</strong>：这不是专家级别的知识（实际上，你甚至可能不需要它），但是你希望这种级别的候选人能够了解这些。例如，如果候选人知道 CSS 或 HTML，这对你来说可能不是很重要。但是，如果候选人已经深入研究了这些技术，却不能谈论为什么 table 好或不好，这就说明了一个问题。他们没有在工作中吸收核心信息。</li>
</ul>
<p>当一家公司面试时将这些因素混乱搭配时，就会遇到麻烦：</p>
<ul>
<li>他们向不是专家的人询问专家问题。</li>
<li>当他们不需要专家时，他们却雇佣了专家。</li>
<li>他们需要专家，但面试却只是评估了基本技能。</li>
<li>他们在询问常规检查（简单）问题，却认为自己问的是质量检查问题。因此，他们对候选人的表现给出了 “okay” 或 “great” 的评价，事实上这会使候选人微小的差别被错误地放大。</li>
</ul>
<p>实际上，在与许多大大小小的科技公司合作进行招聘时，我发现大多数公司都至少做错了其中的一件事。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iv-面试之前-1"><a class="header" href="#iv-面试之前-1">IV. 面试之前</a></h1>
<p>要想在面试中取得好成绩，你必须在面试开始前就做好准备——事实上，是在面试前的几年。下面的时间轴概述了你应该在什么时候考虑什么问题。。</p>
<p>如果你在这个过程中起步较晚，不要担心。尽可能多地“追赶”，然后集中精力做好准备。祝你好运！</p>
<h3 id="获得正确的经验"><a class="header" href="#获得正确的经验">获得正确的经验</a></h3>
<p>没有出色的简历，就没有面试机会。没有丰富的经验，就没有出色的简历。因此，进行面试的第一步是获得丰富的经验。你越早想到这一点就越好。</p>
<p>对于现在的学生来说，这可能意味着：</p>
<ul>
<li>
<p><em>参加大型项目课程</em>：寻找有大型编码项目的课程。在你有正式工作经验之前，这是获得一些实践经验的好方法。项目与现实世界越相关越好。</p>
</li>
<li>
<p><em>获得实习机会</em>：尽一切努力在学校较早地获得实习机会。它将为毕业前更好的实习铺平道路。许多顶级高科技公司都有专门为新生和大二学生设计的实习计划。你也可以看看创业公司，它们可能更灵活。</p>
</li>
<li>
<p><em>开始做一些事情</em>：自己建立一个项目，参加黑客马拉松（hackathons），或者为一个开源项目做贡献。它是什么并不重要。重要的是你正在编码。这不仅会提高你的技术技能和实践经验，而且你的主动性也会给公司留下深刻的印象。</p>
</li>
</ul>
<p>另一方面，专业人士可能已经拥有了转投理想公司的正确经验，例如，一个 Google 开发人员可能已经有足够的经验来跳槽到 Facebook。但是，如果你要从一家不知名的公司跳槽到这些“巨头”之一， 或从测试/IT 转变为开发人员角色，以下建议将很有用：</p>
<ul>
<li>
<p><em>将工作职责更多地转移到编码上</em>：在不向经理透露你正在考虑离职的情况下，你可以谈谈你对承担更大编码挑战的渴望。尽可能多地确保这些项目是“充实的”，使用相关的技术，并在简历上留下一两个要点。理想情况下，正是这些编码项目构成了你简历的主体。</p>
</li>
<li>
<p><em>利用你的夜晚和周末</em>：如果你有一些空闲时间，请用这些时间自己创建一个移动 app，一个 web app，或一个桌面软件。做这样的项目也是获得新技术经验的好方法，能够让你紧跟当今主流的公司的发展方向。这个项目的工作一定要在你的简历中列出，对于面试官来说，很少有什么事情能像一个候选人“只是为了好玩”而创作项目那样令人印象深刻。</p>
</li>
</ul>
<p>所有这些都可以归结为公司想要看到的两件大事：你很聪明，你可以编程。如果你能证明这一点，你就能得到面试机会。</p>
<p>此外，你应该提前考虑自己的职业发展方向。如果你想在未来进入管理领域，即使你目前正在寻找一个开发职位，也应该立即找到培养领导经验的方法。</p>
<h3 id="撰写出色的简历"><a class="header" href="#撰写出色的简历">撰写出色的简历</a></h3>
<p>简历筛选者和面试官寻找的东西是一样的。他们想知道你很聪明，你会编程。</p>
<p>这意味着你应该准备好简历来突出这两点。你对网球、旅行或魔术卡的热爱并不能说明什么。在你为了给业余爱好留出空间而削减更多技术线之前，一定要三思。</p>
<h4 id="适当的简历长度"><a class="header" href="#适当的简历长度">适当的简历长度</a></h4>
<p>在美国，如果你的工作经验少于 10 年，强烈建议你将简历控制在一页纸以内。而更有经验的候选人则通常有理由将长度控制在 1.5~2 页。</p>
<p>写很长的简历时要三思而后行。因为简短的简历往往更令人印象深刻。</p>
<ul>
<li>
<p>招聘人员只会花费固定的时间（约 10 秒）来查看你的简历。如果你把内容限制在最令人印象深刻的项目上，招聘人员一定会看到它们。添加额外的项目只会分散招聘人员的注意力，让他们无法看到你真正想让他们看到的东西。</p>
</li>
<li>
<p>有些人干脆拒绝阅读冗长的简历。你真的想冒着因为这个原因而丢掉你的简历的风险吗？</p>
</li>
</ul>
<p>如果你现在认为你有太多的经验，不能在一到两页纸上写全部写完，相信我，你可以。长篇简历并不代表你有丰富的经验，反而它们反映了你不知道如何对内容进行优先排序。</p>
<h4 id="工作经历"><a class="header" href="#工作经历">工作经历</a></h4>
<p>你的简历不需要，也不应该包括你曾经担任过的每个职位的完整历史记录。应只包括相关的职位——那些能让你成为更令人印象深刻的候选人的职位。</p>
<p><em>编写强力的子弹（Bullets）</em></p>
<p>对于每个角色，请尝试使用以下方法来讨论你的成就：“通过使用 Y 来完成 X，最终导致 Z 。”下面是一个示例：</p>
<ul>
<li>“通过使用分布式缓存，将对象渲染时间减少了 75%，从而减少了 10% 的登录时间。”</li>
</ul>
<p>这是另一个使用备用措词（alternate wording）的示例：</p>
<p>“通过实现一种新的基于 windiff 的比较算法，将平均匹配准确度从 1.2 提高到了 1.5。”</p>
<p>并非你所做的一切都适合这种方法，但原理是相同的：展示你做了什么，你是怎么做的，以及结果是什么。理想情况下，你应尝试以某种方式使结果“可测量（译者注，即可量化）”。</p>
<h5 id="项目"><a class="header" href="#项目">项目</a></h5>
<p>在简历中加入“项目”一栏通常是展现你更有经验的最佳方法。对于大学生或应届毕业生来说尤其如此。</p>
<p>项目经验部分应该包括你的 2~4 个最重要的项目。陈述项目是什么以及使用了什么语言或技术。你可能还需要考虑包括一些细节，例如该项目是个人项目还是团队项目，以及该项目是为课程完成还是独立完成。这些细节不是必需的，因此仅在使你看起来更好时才包括这些细节。独立项目通常比课程项目更可取，因为它显示了你的主动性。</p>
<p>不要添加太多的项目。很多候选人会犯这样的错误，把之前做的 13 个项目都加了进去，因为这些不起眼的小项目把简历整体都打乱了。</p>
<p>那么到底构建什么项目数最好的呢？老实说，这并不重要。一些雇主非常喜欢开源项目（它展示出了为大型代码库所做出贡献的经验），而另一些雇主则更喜欢独立项目（更容易理解你的个人贡献）。你可以创建一个移动 app、一个 web app，或者几乎任何东西。最重要的是你在创造一些东西。</p>
<h4 id="编程语言和软件"><a class="header" href="#编程语言和软件">编程语言和软件</a></h4>
<p><em>软件</em></p>
<p>对简历中要列出的软件保持保守，并了解什么对申请该公司是适合展示的。像 Microsoft Office 这样的软件几乎总是可以被砍掉的。而诸如 Visual Studio 和 Eclipse 之类的技术软件在某种程度上更具相关性，但是许多顶级高科技公司甚至都不在乎这一点。毕竟，学习用 Visual Studio 难倒很难吗？</p>
<p>当然，列出所有这些软件不会对你来说也没有坏处，只是这会占用宝贵的空间。你需要权衡一下。</p>
<p><em>语言</em></p>
<p>你应该列出所有你曾经用过的语言，还是在清单中只展示你最熟悉的？</p>
<p>列出你曾经使用过的所有语言是很危险的。很多面试官认为你简历上的任何东西在面试时都应该被“公平”看待。</p>
<p>另一种选择是列出你使用过的大多数语言，但要加上你的经验水平。这种方法如下所示：</p>
<ul>
<li>语言： Java （精通），C ++ （熟练），JavaScript （有经验）。</li>
</ul>
<p>使用任何措辞（“精通”，“流利”等）来有效地展示你的技术栈。</p>
<p>有些人列出了他们使用某一种语言的经验年数，但这真的很令人困惑。如果你 10 年前第一次学习 Java，并且在此期间偶尔使用它，那么你有多少年的经验呢？</p>
<p>因此，使用经验的年限对于简历而言是一个糟糕的指标。最好只用简单的英语描述你的意思。</p>
<h4 id="给非英语母语者和国际人士的建议"><a class="header" href="#给非英语母语者和国际人士的建议">给非英语母语者和国际人士的建议</a></h4>
<p>有些公司会因为错字而丢掉你的简历。所以请至少找一个母语是英语的人来帮忙校对你的简历。</p>
<p>此外，对于美国职位，不要包括年龄，婚姻状况或国籍。公司不喜欢这种个人信息，因为这会给他们带来法律责任。</p>
<h4 id="当心潜在的恶名stigma"><a class="header" href="#当心潜在的恶名stigma">当心（潜在的）恶名（stigma）</a></h4>
<p>某些语言具有与之相关的恶名。有时，这是由于语言本身引起的，但通常是由于使用该语言的地方而引起的。这里我不想为恶名辩护， 我只是让你知道。</p>
<p>你应注意的一些恶名：</p>
<ul>
<li>
<p><strong>企业语言</strong>：某些语言带有相关的恶名，并且这些语言通常用于企业开发。Visual Basic 就是一个很好的例子。如果你证明自己是 VB 的专家，则可能使人们认为你的技术水平较低。这些人中的许多人都会承认，是的，VB.NET 实际上完全能够构建复杂的应用程序。但是，人们倾向于使用它构建的应用程序种类却不是很复杂。你不太可能看到一个硅谷大牌公司会去使用 VB。</p>
<p>实际上，同样的论点（尽管不那么有力）也适用于整个 .NET 平台。如果你的主要关注点是 .NET，而你并没有申请 .NET 角色，则与背景不同的人相比，你需要做更多的工作来证明自己在技术上很强大。</p>
</li>
<li>
<p><strong>过于注重语言</strong>：当一些顶尖科技公司的招聘人员看到简历上列出了各种各样版本的 Java 语言时，他们会对应聘者的能力做出负面的假设。在许多圈子里，有一种观点认为，最好的软件工程师不会围绕一种特定的语言来定义自己。因此，当他们看到一个候选人似乎在炫耀他们所知道的某一种语言的特定版本时，招聘人员往往会把这个候选人斥为“跟我们不是一类人”。注意，这并不意味着你一定要把这种“炫耀语言”从简历中去掉。你需要了解这家公司的价值观。一些公司确实重视这一点。</p>
</li>
<li>
<p><strong>认证</strong>：软件工程师的认证可以是正面的，也可以是中性的，也可以是负面的。这同样与过于注重语言有关。那些对拥有冗长技术栈的候选人抱有偏见的公司，往往也会对认证抱有偏见。这意味着在某些情况下，你应该把这种经历从你的简历中删除。</p>
</li>
<li>
<p><strong>只懂一到两种语言</strong>：你花在编程上的时间越多，你做的东西越多，你需要使用的语言也就越多。然后，当他们看到只有一种语言的简历时，他们就会假设你没有经历太多的问题。他们还经常担心只使用一两种语言的候选人将难以学习新技术（为什么候选人没有学到更多东西？），或者只能与特定技术绑在一起（可能无法使用最佳语言来完成任务）。</p>
</li>
</ul>
<p>这些建议不仅可以帮助你处理简历，还能指导你如何积累正确的经验。如果你擅长的是 C#.NET，请尝试使用 Python 和 JavaScript 开发一些项目。如果只知道一种或两种语言，请使用其他语言来构建一些应用程序。</p>
<p>在可能的情况下，尝试真正实现多元化。像在 {Python，Ruby 和 JavaScript} 这一语言集中，这些语言在某种程度上有些相似。如果你能学习更不同的语言，例如 Python，C++ 和 Java，那就更好了。</p>
<h3 id="准备流程图"><a class="header" href="#准备流程图">准备流程图</a></h3>
<p>下图将使你了解如何应对面试准备过程。关键的一点是，这不仅仅是在准备面试时要做的，在做项目和编写代码更需要注意！</p>
<div align=center><img src="img/IV_1.png"/></div>
<div align=center><img src="img/IV_2.png"/></div>
<h3 id=""><a class="header" href="#"></a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="v-行为问题-1"><a class="header" href="#v-行为问题-1">V. 行为问题</a></h1>
<p>询问行为问题（Behavioral questions），是为了熟悉你的性格，更深入地了解你的简历，同时也让你更容易地进入面试。这些都是很重要的问题，可以做好准备。</p>
<h3 id="面试准备表格"><a class="header" href="#面试准备表格">面试准备表格</a></h3>
<p>浏览你简历中的每一个项目或组成部分，并确保你可以详细地讨论它们。填写这样的表格可能会有所帮助：</p>
<div class="table-wrapper"><table><thead><tr><th>常见问题</th><th>项目 1</th><th>项目 2</th><th>项目 3</th></tr></thead><tbody>
<tr><td>挑战（Challenges）</td><td></td><td></td><td></td></tr>
<tr><td>错误/失败（Mistakes/Failures）</td><td></td><td></td><td></td></tr>
<tr><td>享受（Enjoyed）</td><td></td><td></td><td></td></tr>
<tr><td>领导力（Leadership）</td><td></td><td></td><td></td></tr>
<tr><td>冲突（Conflicts）</td><td></td><td></td><td></td></tr>
<tr><td>你会做些什么（What You'd Do Differently）</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>在表格顶部，你应该将简历的所有主要方面写成一列，包括每个项目、工作或活动。在表格的左边，作为行，你应该列出常见的行为问题。</p>
<p>在面试前研究一下这个表格。将每个故事缩减为几个关键词可能会使表格更容易学习和回忆。在面试中，你也可以更容易地在眼前浮现出这个表格，从而使你不会分散注意力。</p>
<p>此外，确保你有一到三个项目可以详细讨论。你应该能够深入讨论这些项目用到的技术组件。当然你所列的项目必须是自己发挥核心作用的项目。</p>
<h4 id="你的缺点是什么"><a class="header" href="#你的缺点是什么">你的缺点是什么?</a></h4>
<p>当被问到你的缺点时，给出一个真正的缺点！像 “我最大的缺点是工作太努力” 这样的回答会让你的面试官觉得你很自大，或者不愿承认自己的错误。一个好的回答应该是你给出了一个自己的真实的、合理的缺点，并且强调了你是如何克服它的。</p>
<p>例如：</p>
<blockquote>
<p>“有时候，我不太注意细节。虽然这很好，因为它让我可以快速执行，但这也意味着我有时会犯一些粗心的错误。正因为如此，我会确保始终让别人仔细检查一下我的工作。”</p>
</blockquote>
<h4 id="你应该问面试官什么问题"><a class="header" href="#你应该问面试官什么问题">你应该问面试官什么问题？</a></h4>
<p>大多数面试官都会给你机会向他们提问。你所提出的问题的质量，无论是下意识的还是有意识的，都将是影响面试官决定的因素。所以，请带着一些疑问进入面试。</p>
<p>你可以考虑以下三种常见类型的问题。</p>
<p><em>真实的问题</em></p>
<p>这些都是你真正想知道答案的问题。以下是一些对许多候选人都有价值的问题：</p>
<ol>
<li>“测试人员、开发人员和程序经理的比例是多少？交互是什么样的？团队中的项目计划如何进行？”</li>
<li>“是什么使你来到这家公司的？对你而言最具挑战性的是什么？”</li>
</ol>
<p>这些问题会让你对公司的日常生活有一个很好的了解。</p>
<p><em>有深度的问题</em></p>
<p>这些问题表明了你对技术的熟悉或理解程度。</p>
<ol>
<li>“我注意到你使用的是 X 技术。你是如何处理 Y 问题的？”</li>
<li>“为什么产品选择使用 X 协议而不是 Y 协议？我知道它有 A、B、C 等好处，但很多公司因为问题 D 而选择不使用它。”</li>
</ol>
<p>提出这样的问题通常需要事先对公司进行深入研究。</p>
<p><em>热情问题</em></p>
<p>这些问题旨在展示你对科技的热情。它们会表现出你对学习的兴趣，并且表现了你会对公司做出巨大的贡献的潜力。</p>
<ol>
<li>“我对可扩展性非常感兴趣，我很想了解更多有关可扩展性的信息。这家公司有什么机会能让我学习这些呢？”</li>
<li>“我不熟悉 X 技术，但它听起来是一个非常有趣的解决方案。你能告诉我更多有关它的工作原理吗？”</li>
</ol>
<h3 id="了解你的技术项目"><a class="header" href="#了解你的技术项目">了解你的技术项目</a></h3>
<p>作为准备工作的一部分，你应该专注于两三个你应该深入掌握的技术项目。选择最符合以下条件的项目：</p>
<ul>
<li>项目存在具有挑战性的组件（不仅仅是“学到很多”）。</li>
<li>你扮演了核心角色（理想情况下是在具有挑战性的组件上）。</li>
<li>你可以在技术层面上深入讨论。</li>
</ul>
<p>对于这些项目，以及你所有的项目，都要可以谈论挑战、错误、技术决策、技术选择（以及这些技术的权衡），以及你将采取的不同措施。</p>
<p>你还可以考虑后续问题，例如如何扩展应用程序。</p>
<h3 id="回答行为问题"><a class="header" href="#回答行为问题">回答行为问题</a></h3>
<p>行为问题能让面试官更好地了解你和你之前的经历。回答问题时要记住以下建议。</p>
<h4 id="要具体不要傲慢"><a class="header" href="#要具体不要傲慢">要具体，不要傲慢</a></h4>
<p>傲慢是一个危险信号，但是你仍然想让自己听起来令人印象深刻。那么，如何让自己听起来不那么自大呢？通过将描述具体化！</p>
<p>具体化意味着只给出事实，让面试官自己得出一个结论。例如，与其说你“做了所有困难的部分”，还不如具体描述你做了哪些具有挑战性的工作。</p>
<h4 id="限制细节"><a class="header" href="#限制细节">限制细节</a></h4>
<p>当候选人喋喋不休地谈论一个问题时，对于不是很精通这个话题或项目的面试官来说，要理解它是很困难的。</p>
<p>保持对细节的关注，但同时应该只陈述重点。如果可能的话，试着解释它或者至少说明其影响。你通常可以给面试官提供进一步深入了解的机会。</p>
<blockquote>
<p>“通过研究最常见的用户行为，并应用 Rabin-Karp 算法，我设计了一个新的算法，可以在 90% 的情况下，将搜索从 O(n) 减少到 O(log n)。如果你有其他问题，我可以详细介绍。”</p>
</blockquote>
<p>这样描述不仅可以展示重点，并且允许面试官在需要时可以询问更多细节。</p>
<h4 id="专注于自己而不是团队"><a class="header" href="#专注于自己而不是团队">专注于自己，而不是团队</a></h4>
<p>面试从根本上说是个人评估。不幸的是，当你倾听许多候选人（尤其是那些担任领导职务的候选人）的回答时，他们的答案往往是关于“我们”和“团队”的。面试官离开的时候对候选人的实际影响一无所知，可能会得出这样的结论：候选人没有做任何事情。</p>
<p>注意你的答案。听一听相对于“我”，你说了多少次“我们”。所以请假设每个问题都是关于你的角色的，然后再说出来。</p>
<h4 id="给出有条理的答案"><a class="header" href="#给出有条理的答案">给出有条理的答案</a></h4>
<p>有两种常见的方法来考虑如何组织对行为问题的回答：金块优先（Nugget First），和S.A.R. 。这些技术可以单独使用，也可以一起使用。</p>
<p><em>金块优先（Nugget First）</em></p>
<p>“金块优先”是指从一个“金块”开始你的回答，该“金块”简洁地描述了你的回答是关于什么的。</p>
<p>例如：</p>
<ul>
<li><strong>面试官</strong>：“请给出一个你说服一群人做出巨大改变的例子。”</li>
<li><strong>候选人</strong>：“好的，让我来告诉你一次我说服学校让本科生自己教授自己课程的经历。起初，我们学校有一条规定……”</li>
</ul>
<p>这种技巧能抓住面试官的注意力，让你的故事内容一目了然。它还能帮助你更专注于你的交流，因为你已经非常清楚地告诉自己你回答的要点是什么。</p>
<p>S.A.R. 这种方法意味着你首先要概述情况，然后解释所采取的行动，最后描述结果。</p>
<p>例子：“跟我说说你和同事之间富有挑战性的交流。”</p>
<ul>
<li>
<p><strong>情况（Situation）</strong>：在我的操作系统项目中，我被分配与另外三个人一起工作。尽管两个人很棒，但是第三名团队成员却贡献不大。他在会议期间保持沉默，很少在电子邮件讨论中介入，而且很难完成自己部分的工作。不仅因为这把更多的工作转移到我们身上，而且因为我们不知道是否可以指望他。</p>
</li>
<li>
<p><strong>行动（Action）</strong>：我还不想完全否定他，所以我试图解决这种情况。我做了三件事。</p>
<p>首先，我想了解他为什么这样做。懒惰吗？ 他在忙别的吗？ 我与他进行了交谈，然后问他关于他感觉如何的开放性问题。有趣的是，不知从何而起，他说他想承担起写作工作，这是最耗时的工作之一。这告诉我，这不是懒惰，而是因为他觉得自己不擅长编写代码。</p>
<p>其次，既然我了解了原因，我就试着让他明白他不应该担心搞砸。我向他讲述了我犯的一些更大的错误，并承认我对项目的很多部分也不是很清楚。</p>
<p>第三，也是最后，我请他帮我分析一下这个项目的一些组成部分。我们一起坐下来，为其中一个大型组件设计了一个完整的规范，比以前更加详细。当他看到所有的片段时，他明白了这个项目并不像他想象的那么可怕。</p>
</li>
<li>
<p><strong>结果（Result）</strong>：随着他的信心增强，他现在主动提出愿意承担一些较小的编码工作，然后是一些核心的部分。他按时完成了所有工作，并在讨论中做出了更多贡献。我们很高兴和他在未来的项目上合作。</p>
</li>
</ul>
<p>情况和结果应该简洁。你的面试官通常不需要很多细节来理解发生了什么，事实上，他们可能会被这些细节弄糊涂。</p>
<p>通过使用带有清晰情况、行动和结果的 S.A.R. 模型，面试官能够很容易地识别出你是如何产生影响的，以及它为什么重要。</p>
<p>考虑把你的故事放到下面的格子里：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Nugget</th><th>Situation</th><th>Action(s)</th><th>Result</th><th>What It Says</th></tr></thead><tbody>
<tr><td>Story 1</td><td></td><td></td><td>1. ...<br/>2. ...<br/>3. ...</td><td></td><td></td></tr>
<tr><td>Story 2</td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<h4 id="探究行动"><a class="header" href="#探究行动">探究行动</a></h4>
<p>在几乎所有情况下，“行动”都是故事中最重要的部分。不幸的是，有太多的人却只是在喋喋不休地谈论出现的情况，而对采取的行动只是轻描淡写。</p>
<p>相反，请深入描述你的行动。尽可能将行动分解为多个部分。例如：“我做了三件事。首先，我……” 这样表述将使你的回答足够有深度。</p>
<h4 id="想想它说了什么"><a class="header" href="#想想它说了什么">想想它说了什么</a></h4>
<p>重新阅读第 35 页的故事（译者注，即上面例子）。候选人表现出了哪些性格特点？</p>
<ul>
<li><strong>主动性/领导力</strong>：候选人试图通过正面处理来解决问题。</li>
<li><strong>同理心</strong>：候选人试图理解这个人发生了什么。在知道如何解决队友的不安全感时，这位候选人也表现出了同理心。</li>
<li><strong>同情</strong>：虽然同事伤害了团队，但候选人并不生同事的气。他的同理心使他产生了同情心。</li>
<li><strong>谦虚</strong>：候选人能够承认自己的缺点（不仅对同事，而且对面试官）。</li>
<li><strong>团队合作/乐于助人</strong>：候选人与同事合作，将项目分成可管理的几个部分。</li>
</ul>
<p>你应该从这个角度来思考你的故事。分析你采取的行动和你的反应。你的反应说明了什么性格特征?</p>
<p>在很多情况下，答案是“没有”。这通常意味着你需要重新设计该如何描述故事，以使其更能表现你的性格特征。你不需要明确地说，“我之所以做 X 是因为我有同理心”，但你可以更进一步。例如：</p>
<ul>
<li><strong>缺少明确的属性</strong>：“我打电话给客户，告诉他发生了什么事。”</li>
<li><strong>更多明确的属性（同理心和勇气）</strong>：“我确保亲自给客户打电话，因为我知道他会很高兴直接从我这里听到。”</li>
</ul>
<p>如果你仍然不能把性格特征明确地表现出来，那么你可能需要想出一个全新的故事。</p>
<h3 id="说说你自己吧"><a class="header" href="#说说你自己吧">说说你自己吧……</a></h3>
<p>许多面试官会让你简单介绍一下自己，或者让你浏览一下自己的简历，以此开始面试。这本质上是一个“基调（pitch）”。这是面试官对你的第一印象，所以你一定要抓住这个机会。</p>
<h4 id="结构"><a class="header" href="#结构">结构</a></h4>
<p>对于很多人来说，一个典型的结构基本上是按时间顺序排列的，开头的句子描述了他们目前的工作，结尾讨论了他们在工作之外的相关兴趣爱好（如果有的话）。</p>
<ol start="3">
<li><strong>当前职位[仅限摘要]</strong>：“我是 Microworks 的一名软件工程师，在过去的五年里，我一直领导着该公司的 Android 团队。”</li>
<li><strong>学校</strong>：我的专业是计算机科学。我在伯克利读本科时，有几个暑假在初创公司工作，其中包括我尝试创办自己的企业的那一年。</li>
<li><strong>大学毕业及以后</strong>：大学毕业后，我想接触一些更大的公司，所以我加入了 Amazon，成为一名开发人员。这是一次很棒的经历。我学到了很多关于大型系统设计的知识，并且推动了 AWS 关键部分的发布。这实际上让我明确了，我十分想在一个更有创业精神的环境中。</li>
<li><strong>当前职位[详细信息]</strong>：我在 Amazon 的一位老领导招募我加入她的初创公司，这就是我进入Microworks 的原因。在这里，我做了最初的系统架构，随着我们的快速增长，它的扩展性非常好。然后我抓住机会领导了 Android 团队。我管理着一个三人团队，但我的角色主要是技术领导：架构、编码等等。</li>
<li><strong>工作以外</strong>：在工作之外，我参加了一些黑客马拉松——主要是在那里进行iOS开发，以便更深入地学习。我还积极在有关 Android 开发的在线论坛上担任版主。</li>
<li><strong>总结</strong>：我正在找新工作，你的公司吸引了我的注意。我一直很喜欢与用户的联系，我也很想回到一个更小的环境中。</li>
</ol>
<p>这种结构对 95% 的候选人都很有效。对于有更多经验的候选人，你可以浓缩其中的一部分。十年后，候选人最初的陈述可能会变成：“从伯克利获得计算机科学学位后，我在 Amazon 工作了几年，然后加入了一家初创公司，在那里我领导着 Android 团队。”</p>
<h4 id="爱好"><a class="header" href="#爱好">爱好</a></h4>
<p>仔细考虑你的爱好。你可能想讨论，也可能不想讨论。</p>
<p>通常它们只是无足轻重的。如果你的爱好只是一些普通的活动，比如滑雪或者和你的狗狗玩耍，你可以跳过它。</p>
<p>然而，有时候，描述你的爱好可能是会有用的。这通常在以下情况下发生：</p>
<ul>
<li>爱好是非常独特的（例如，喷火）。它可能会帮助你们开启一段对话，并以一种更亲切的语调开始面试。</li>
<li>爱好是技术性的。这不仅可以补充你的实际的技术栈，还可以显示出你对技术的热情。</li>
<li>爱好表现出积极的个性特征。诸如“自己改造房屋”之类的爱好显示了一种学习新事物、承担一些风险和动手（字面上和比喻上）的动力。</li>
</ul>
<p>提起爱好很少会有什么坏处，所以当你疑惑该不该说时，不妨提一下。</p>
<p>不过，考虑一下如何最好地构筑自己的爱好。你是否有任何成功或具体的工作可以展示（例如，在戏剧中扮演角色）？ 这个爱好有表现出什么性格特征吗？</p>
<h4 id="轻描淡写地展示成功"><a class="header" href="#轻描淡写地展示成功">轻描淡写地展示成功</a></h4>
<p>在上面的沟通中，候选人随意地提到了他的一些重要背景。</p>
<ul>
<li>他特别提到他是被他的老领导从 Microworks 招聘来的，这表明他在 Amazon 很成功。</li>
<li>他还提到想要在一个较小的环境中工作，这显示了一些他与当前企业文化契合的元素（假设这是他正在申请的创业公司）。</li>
<li>他提到了自己取得的一些成功，比如发布了 AWS 的关键部分，并构建了一个可扩展的系统。</li>
<li>他提到了他的爱好，这两项都显示出学习的动力。</li>
</ul>
<p>当你考虑你的陈述时，考虑一下你的背景将如何影响面试官对你有哪些不同的评价。你能不动声色地展示自己的成功吗（获奖、晋升、被之前的同事招募、发布等等）？ 你想传达什么关于自己的信息？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vi-big-o-1"><a class="header" href="#vi-big-o-1">VI. Big O</a></h1>
<p>这是一个非常重要的概念，我们为此专门写了整整一章。</p>
<p>Big O time 是我们用来描述算法效率的语言和指标。在开发算法时，如果不能完全理解它可能会对你造成严重的伤害。你不仅可能因为没有真正理解 big O 而受到严厉地批评，而且也很难判断你的算法是变快了还是变慢了。</p>
<p>掌握这个概念。</p>
<h3 id="一个类比"><a class="header" href="#一个类比">一个类比</a></h3>
<p>想象一下这样的场景：你的硬盘上有一个文件，需要把它发送给住在全国各地的朋友。你需要尽快将文件发送给你的朋友。你应该如何发送？</p>
<p>大多数人首先想到的是电子邮件、FTP或其他电子传输方式。这种想法是合理的，但只对了一半。</p>
<p>如果它是一个小文件，你当然是对的。到机场搭乘飞机，然后把它送到你的朋友那里，要花 5 到 10 个小时。</p>
<p>但是如果文件非常非常大呢？通过飞机运送是不是可能会更快呢？</p>
<p>实际上，是的。一个 1TB 的文件通过电子方式传输可能需要一天以上的时间。但如果让它通过飞机运送到全国，速度会快得多。如果你的文件很紧急（而且成本不是问题），你可能只想这么做。</p>
<p>如果没有航班，你不得不开车穿越整个国家呢？即使这样，对于一个非常大的文件，开车运送的速度也是较快的。</p>
<h3 id="时间复杂度"><a class="header" href="#时间复杂度">时间复杂度</a></h3>
<p>这就是渐近运行时（asymptotic runtime）概念，或者说 big O time，的含义。我们可以将数据传输“算法”运行时描述为：</p>
<ul>
<li>
<p>电子传输：O(s)，其中 s 为文件大小。这意味着传输文件的时间随文件的大小线性增加。(是的，这有点简化了，但是就当前的问题而言是可以接受的。)</p>
</li>
<li>
<p>飞机传输：O(1)，即使是考虑了文件的大小。随着文件大小的增加，将文件发送给你的朋友将不会花费更多的时间。时间是一个常数。</p>
</li>
</ul>
<p>不管常数有多大，线性增长有多慢，线性增长总会在某个点上超过常数。</p>
<div align=center><img src="img/VI_1.png"/></div>
除此之外，还有更多的运行时。最常见的有 O(log N)、O(N log N)、O(N)、O(N^2) 和 O(2^N)。但是，没有一个固定的内容为可能的运行时的列表。
<p>你还可以在运行时中包含多个变量。例如，粉刷一个 w 米宽 h 米高的栅栏的时间可以被描述为 O(wh)。如果你需要刷 p 层油漆，那么你可以说时间是 O(whp)。</p>
<h4 id="big-obig-theta-和-big-omega"><a class="header" href="#big-obig-theta-和-big-omega">Big O、Big Theta 和 Big Omega</a></h4>
<p>如果你从来没有在学术场合讨论过大O，你可以跳过这一小节。因为它更可能的是会让你感到困惑，而不是有所帮助。这个“供参考（FYI）”主要是为那些以前学过big O的人消除在措辞上的歧义，这样他们就不会说，“但是我以为 big O 的意思是……”</p>
<p>x学术上使用 big O, big Θ (theta), and big Ω (omega) 来描述运行时。</p>
<ul>
<li>
<p><strong>O (big O)</strong>：在学术界，big O 表示时间的上限。打印数组中所有值的算法可以被描述为 O(N)，但也可以被描述为 O(N^2)、O(N^3) 或 O(2^N)（或许多其他的 big O time）。这个算法至少和这些 big O time 中任意一个一样快，因此说它们是运行时的上限。这类似于一种“小于或等于”的关系。如果 Bob 是 X 岁（我假设没有人超过130岁），那么你可以说 X &lt;= 130。说 X &lt;= 1,000 或 X &lt;= 1,000,000 也将是正确的。因为在技术上，这都为真（尽管不是特别有用）。同样，打印数组中的值的简单算法的运行时是 O(N)，也可以是 O(N^3) 或任何大于 O(N) 的运行时。</p>
</li>
<li>
<p><strong>Ω (big omega)</strong>： 在学术界，Ω是对等的概念，但是适用于下限。打印数组中的值是Ω(N)，也可以是 Ω(log N) 和 Ω(1)。毕竟，你知道它不会比那些运行时快。</p>
</li>
<li>
<p><strong>Θ (big theta)</strong>： 在学术界，Θ 同时表示 O 和 Ω。也就是说，如果算法既是 O(N) 又是 Ω(N)，则算法为 Θ(N)。Θ 给出了严格限制的运行时。</p>
</li>
</ul>
<p>在行业中（因此也是在面试中），人们似乎将 Θ 和 O 合并在一起。big O 的行业含义更接近于学术界所说的 Θ，因为将打印数组描述为 O(N^2) 被认为是不正确的。行业上只会说这是 O(N)。</p>
<p>在本书中，我们将以业界倾向于使用的方式使用 big O：始终尝试提供运行时最精确的描述。</p>
<h4 id="最佳情况最坏情况和预期情况"><a class="header" href="#最佳情况最坏情况和预期情况">最佳情况，最坏情况和预期情况</a></h4>
<p>实际上，我们可以用三种不同的方式描述算法的运行时。</p>
<p>让我们从快速排序的角度来看一下。快速排序选择一个随机元素作为“基准（pivot）”，然后交换数组中的值，以使小于基准的元素出现在大于基准的元素之前。这给出了“部分排序”，然后使用类似的过程递归地对左右两边排序。</p>
<ul>
<li>
<p><strong>最佳情况</strong>：如果所有元素都相等，那么快速排序平均将只遍历数组一次。这是 O(N)。（这实际上在某种程度上取决于快速排序的实现。但是，有些实现将在有序数组上非常快地运行。）</p>
</li>
<li>
<p><strong>最坏的情况</strong>：如果我们真的很不幸，选取的基准屡次是数组中的最大元素，该怎么办？ （实际上，这很容易发生。如果选择子数组中的第一个元素为基准，并且以相反的顺序对数组进行排序，就会遇到这种情况。）在这种情况下，我们的递归不会将数组分成两半，而是在每一半上递归。它只是将子数组缩小了一个元素。这将退化为O(N^2) 运行时。</p>
</li>
<li>
<p><strong>预期情况</strong>：尽管如此，通常这些完美或糟糕的情况不会发生。当然，有时基准会非常低或非常高，但不会一次又一次地发生。我们可以期望运行时间为 O(N log N)。</p>
</li>
</ul>
<p>我们很少讨论最佳情况下的时间复杂度，因为这不是一个非常有用的概念。毕竟，我们可以用任何算法，在特殊情况下的一些输入，然后在最佳情况下得到 O(1) 的时间。</p>
<p>对于大多数算法，最坏情况和期望情况是相同的。但是，有时它们是不同的，我们需要描述这两种运行时。</p>
<p><em>最佳/最差/预期情况与 big O/theta/omega 之间有什么关系？</em></p>
<p>候选人很容易混淆这些概念（可能是因为两者都有“较高”，“较低”和“完全正确”的概念），但是这些概念之间没有特定的关系。</p>
<p>最佳，最差和预期情况描述了特定输入或场景的 big O（或 big theta）时间。</p>
<p>Big O、big omega 和 big theta 描述了运行时的上限，下限和严格范围。</p>
<h3 id="空间复杂度"><a class="header" href="#空间复杂度">空间复杂度</a></h3>
<p>时间不是算法中唯一重要的东西。我们还可能关心算法所需的内存或空间。</p>
<p>空间复杂度是一个与时间复杂度平行的概念。如果我们需要创建一个大小为 n 的数组，这将需要 O(n) 空间。如果我们需要一个大小为 n x n 的二维数组，则将需要 O(n^2) 空间。</p>
<p>递归调用中的堆栈空间也很重要。例如，这样的代码将占用 O(n) 时间和 O(n) 空间。</p>
<pre><code class="language-java">1 	int sum(int n) { /* Ex 1. */
2 		if (n &lt;= 0) {
3 			return 0;
4 		}
5 		return n + sum(n-1);
6 	}
</code></pre>
<p>每个调用都会向堆栈添加一层。</p>
<pre><code>1 sum(4)
2 	-&gt; sum(3)
3 		-&gt; sum(2)
4 			-&gt; sum(1)
5 				-&gt; sum(0)
</code></pre>
<p>每个调用都被添加到调用堆栈，并占用实际内存。</p>
<p>但是，仅仅因为你总共有 n 次调用并不意味着它占用了 O(n) 空间。考虑下面的函数，它将 0 到 n 内相邻元素的相加：</p>
<pre><code class="language-java">1 	int pairSumSequence(int n) {/* Ex 2.*/
2 		int sum = 0;
3 		for (int i = 0; i &lt; n; i++) {
4 			sum += pairSum(i, i + 1);
5 		}
6 		return sum;
7 	}
8 
9 	int pairSum(int a, int b) {
10 		return a + b;
11 	}
</code></pre>
<p>对 pairSum 大约会有 O(n) 次调用。但是，这些调用不会同时存在于调用堆栈中，因此你只需要 O(1) 空间。</p>
<h3 id="删除常量"><a class="header" href="#删除常量">删除常量</a></h3>
<p>对于特定的输入，O(N) 的代码很可能比 O(1) 的代码运行得快。Big O 只是表示增长率。</p>
<p>因此，我们删除了运行时中常量。一个可能曾被描述为 O(2N) 的算法事实上我们现在用 O(N) 表示。</p>
<p>许多人拒绝这样做。他们在看到具有两个（非嵌套）for 循环的代码时，会继续坚持认为这是 O(2N)。他们认为这样表述更加“精确”。其实不是。</p>
<p>考虑下面的代码：</p>
<p><strong>Min and Max 1</strong></p>
<pre><code class="language-java">1 	int min = Integer.MAX_VALUE; 
2 	int max = Integer.MIN_VALUE; 
3 	for (int x ： array) {
4 		if (x &lt; min) min x; 
5 		if (x &gt; max) max = x;
6 	}
</code></pre>
<p><strong>Min and Max 2</strong></p>
<pre><code class="language-java">1 	int min = Integer.MAX_VALUE;
2 	int max = Integer.MIN_VALUE;
3 	for (int x ： array) {
4 		if (x &lt; min) min = x;
5 	}
6 	for (int x ： array) {
7 		if (x &gt; max) max = x;
8 	}
</code></pre>
<p>哪一个更快？第一个执行一个 for 循环，另一个执行两个 for 循环。但是，第一个方案每个 for 循环有两行代码，而不是一行。</p>
<p>如果你要计算指令的数量，那么你必须去到汇编层，考虑乘法比加法需要更多的指令，编译器将如何优化某些内容以及各种其他细节。</p>
<p>这将是极其复杂的事情，所以甚至不要走这条路。Big O 使我们能够表达运行时如何扩展。我们只需要明白，并不意味着 O(N) 总是比 O(N^2) 好。</p>
<h3 id="删除非主导项"><a class="header" href="#删除非主导项">删除非主导项</a></h3>
<p>如何处理 O(N^2 + N) 这样的表达式？第二个 N 并不是一个常数，但它并不特别重要。</p>
<p>我们已经说过删掉常数。因此，O(N^2 + N^2)  就是 O(N^2)。如果我们不关心后面的 N^2 项，我们为什么要关心 N 呢？所以实际上我们没有。</p>
<p>你应该删除非主导项</p>
<ul>
<li>O(N^2 + N) 变成 O(N^2)。</li>
<li>O(N + log N) 变成 O(N)。</li>
<li>O(5*2^N + 1000N^100) 变成 O(2^N)。</li>
</ul>
<p>我们可能在运行时表达式中仍保留一个和式。例如，表达式 O(B^2 + A) 不能被简化（在没有一些关于 A 和 B 的特殊说明时）。</p>
<p>下图描述了一些常见的 big O time 的增长率。</p>
<div align=center><img src="img/VI_2.png"/></div>
可以看到，O(x^2) 比 O(x) 差得多，但远不及 O(2^x) 或 O(x!) 差。还有很多比 O(x!) 更糟糕的运行时，比如 O(x^x) 或 O(2^x * x!)。
<h3 id="多部分算法加-vs-乘"><a class="header" href="#多部分算法加-vs-乘">多部分算法：加 vs. 乘</a></h3>
<p>假设你有一个算法，它有两个步骤。什么时候将运行时相乘，什么时候将它们相加？</p>
<p>这是使候选人感到困惑的一个常见的原因。</p>
<p><strong>Add the Runtimes</strong>： O(A + B)</p>
<pre><code class="language-java">1 	for (int a ： arrA) { 
2 		print(a);
3 	}
4
5 	for (int b ： arrB) {
6 		print(b);
7 	}
</code></pre>
<p><strong>Multiply the Runtimes</strong>： O(A*B)</p>
<pre><code class="language-java">1 	for (int a ： arrA) {
2 		for (int b ： arrB) {
3 			print(a + "," + b);
4 		}
5 	}
</code></pre>
<p>在前一个的示例中，我们先执行 A 代码块工作，然后执行 B 代码块工作。因此，总工作量为 O(A + B)。</p>
<p>在后一个的示例中，我们对 A 中的每个元素执行 B 代码块的操作，因此总工作量为 O(A * B)。</p>
<p>换一种说法：</p>
<ul>
<li>
<p>如果你的算法是这样的形式：“执行这个操作，然后，当你完成了，执行那个操作”，那么你需要将运行时相加。</p>
</li>
<li>
<p>如果你的算法是这样的形式：“每次执行那个操作时，执行这个操作”，那么你需要将运行时相乘。</p>
</li>
</ul>
<p>在面试中很容易把这个搞砸，所以要小心。</p>
<h3 id="平摊时间amortized-time"><a class="header" href="#平摊时间amortized-time">平摊时间（Amortized Time）</a></h3>
<p>一个ArrayList，或者一个动态调整大小的数组，允许你在拥有大小灵活性的同时享受数组的好处。你不会耗尽 Arraylist 中的空间，因为它的容量会随着你插入元素而增长。</p>
<p>Arraylist 是用数组实现的。当数组达到容量限制时，Arraylist 类将创建一个容量加倍的新数组，并将所有元素复制到新数组。</p>
<p>如何描述插入的运行时间？这是一个棘手的问题。</p>
<p>数组可能是满的。如果数组包含 N 个元素，那么插入一个新元素将花费 O(N) 时间。你将不得不创建一个大小为 2N 的新数组，然后复制 N 个元素。因此该插入时间复杂度为 O(N)。</p>
<p>然而，我们也知道这并不经常发生。绝大多数的插入都在 O(1) 时间内进行。</p>
<p>我们需要一个兼顾两者的概念。这就是平摊时间（amortized time）的作用。我们得承认，确实，最坏的情况偶尔就会发生一次。但是一旦它发生了，它在很长一段时间内就不会再发生，所以其代价就被“平摊”了。</p>
<p>在这种情况下，平摊时间是多少？</p>
<p>插入元素时，我们将在数组大小为 2 的幂时将容量翻倍。即，在 插入 X 个元素之后，我们分别在数组大小为 1, 2, 4, 8, 16, ..., X 时，对容量进行了翻倍。每次翻倍分别需要 1, 2, 4, 8, 16, 32, 64, ..., X 次复制。</p>
<p>1 + 2 + 4 + 8 + 16 + ... + X 的总和是多少？如果你从左到右读这个和式，会发现它从1开始加倍，直到达到 X。如果你从右到左读，它从 X 开始，然后减半，直到 1。</p>
<p>那么 X + X / 2 + X / 4 + X / 8 + ... + 1 的总和是多少？ 这大约是 2X。</p>
<p>因此，X 次插入需要 O(2X) 的时间。每次插入的平摊时间是 O(1)。</p>
<h3 id="log-n-运行时"><a class="header" href="#log-n-运行时">Log N 运行时</a></h3>
<p>我们通常在运行时中看到 O(log N)。这是怎么来的？</p>
<p>让我们以二分查找为例。在二分查找中，我们要在一个 N 个元素的有序数组中查找元素 x。首先我们将 x 与数组的中点进行比较。如果 x == middle，则直接 return。如果 x &lt; middle，则在数组的左侧搜索。如果 x &gt; middle，则我们在数组的右侧搜索。</p>
<pre><code class="language-java">search 9 within {1, 5, 8, 9, 11, 13, 15, 19, 21} 
	compare 9 to 11 -&gt; smaller.
	search 9 within {1, 5, 8, 9, 11}
		compare 9 to 8 -&gt; bigger
		search 9 within {9, 11}
			compare 9 to 9
			return
</code></pre>
<p>我们从一个 N 元素数组开始搜索。然后，只需一步，就剩下 N/2 个元素了。再走一步，我们就减少到 N/4 个元素。当我们找到值或只剩下一个元素时，我们就会停止。</p>
<p>然后，总运行时间取决于我们可以执行多少步骤（每次将 N 除以2），直到 N 变为 1。</p>
<pre><code>N = 16
N = 8 	/* divide by 2 */ 
N = 4 	/* divide by 2 */ 
N = 2 	/* divide by 2 */ 
N = 1 	/* divide by 2 */ 
</code></pre>
<p>我们可以反过来看（从 1到 16 而不是 16 到 1）。将 1 乘以多少次 2 才能得到 N？</p>
<pre><code>N = 1 
N = 2 	/* multiply by 2 */
N = 4 	/* multiply by 2 */
N = 8 	/* multiply by 2 */
N = 16 	/* multiply by 2 */
</code></pre>
<p>表达式 2 ^ k = N 中的 k 是多少？ 这正是 log 所表达的。</p>
<pre><code>2^4 = 16 -&gt; log₂16 = 4
log₂N = k -&gt; 2^k = N
</code></pre>
<p>这是一个很好的技巧。当你看到一个问题时，如果问题空间（problem space）中的元素数量每次减半，那么运行时可能就是 O(log N)。</p>
<p>这也是为什么在平衡二叉搜索树中找到一个元素的时间是 O(log N) 的原因。每次比较时，我们都向左或向右移动。每边有一半的节点，所以我们每次将问题空间减半。</p>
<blockquote>
<p>log 的底是多少？问得好！简短的回答是，对于 big O 而言，这无关紧要。较长的解释可以在 630 页的 “Bases of Logs” 中找到。</p>
</blockquote>
<h3 id="递归运行时"><a class="header" href="#递归运行时">递归运行时</a></h3>
<p>这是一个棘手的问题。这段代码的运行时间是多少？</p>
<pre><code class="language-java">1 	int f(int n) {
2 		if (n &lt;= 1) {
3 			return 1;
4 		}
5  		return f(n - 1) + f(n - 1);
6 	}
</code></pre>
<p>很多人会因为某些原因，看到对f的两次调用，然后跳到O(N^2)这是完全错误的。</p>
<p>与其做假设，不如通过遍历代码来获得运行时。假设我们调用 f(4)，这个函数调用了两次 f(3)，而对 f(3) 的每次调用又都会调用 f(2)，直到 f(1) 为止。</p>
<div align=center><img src="img/VI_3.png"/></div>
这个树上有多少次调用？（不要直接数！）
<p>该树的深度（depth ）为 N。每个节点（即函数调用）有两个子节点。因此，每一层的调用次数都是上一层的两倍。每层节点数为：</p>
<div align=center><img src="img/VI_4.png"/></div>
因此，将有2 ^ 0 + 2 ^ 1 + 2 ^ 2 + 2 ^ 3 + 2 ^ 4 + ... + 2 ^ N（即2 ^（N + 1）-1）个节点。（请参阅第630页上的“ 2的幂的和”。）
<p>尝试记住这种模式。当你有一个进行多次调用的递归函数时，运行时通常（但不总是）看起来像 O(branches^depth)，其中 branch 是每个递归调用分支的次数。在这种情况下，我们得到O(2^N)。</p>
<blockquote>
<p>你可能还记得，对于 big O 而言，log 的底数并不重要，因为不同底数的 log 仅相差一个常数。但是，这不适用于指数。指数的基数很重要。比较 2^n 和 8^n。展开 8^n，得到 (2^3)^n，等于 2^3n，等于 2^2n * 2^n。可以看到，8^n和 2^n 相差 2^2n。这不是一个常数！</p>
</blockquote>
<p>该算法的空间复杂度为 O(N)。虽然树中总共有 O(2^N) 个节点，但在任何给定时间只有 O(N) 个节点存在。因此，我们只需要 O(N) 可用的内存即可。</p>
<h3 id="示例和练习"><a class="header" href="#示例和练习">示例和练习</a></h3>
<p>Big O time 刚开始的确是一个困难的概念。然而，一旦你“通窍”了，它就变得相当容易。相同的模式一遍又一遍地出现，而且其他的你也可以推导出来。</p>
<p>我们将从简单的开始，逐步加大难度。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例 1</a></h4>
<p>以下代码的运行时间是多少？</p>
<pre><code class="language-java">1 	void foo(int[] array) {
2 		int sum = 0;
3 		int product = 1;
4 		for (int i = 0; i &lt; array.length; i++) {
5 			sum =+ array[i);
6 		}
7 		for (int i = 0; i &lt; array.length; i++) {
8 			product *= array[i];
9 		}
10 		System.out.println(sum + ", " + product);
11 	}
</code></pre>
<p>这将花费 O(N) 时间。我们遍历数组两次的事实并不重要。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例 2</a></h4>
<p>以下代码的运行时间是多少？</p>
<pre><code class="language-java">1 	void printPairs(int[] array) {
2 		for (int i = 0; i &lt; array.length; i++) {
3 			for (int j = 0; j &lt; array.length; j++) {
4 				System.out.println(array[i] + "," + array[j]);
5 			}
6 		}
7 	}
</code></pre>
<p>内部的 for 循环有 O(N) 次迭代，它被调用 N 次。因此，运行时间是 O(N^2)。</p>
<p>另一种方法是检查代码的“含义”。它正在打印所有的对（两个
元素序列）。有 O(N^2) 对，因此，运行时间是 O(N^2)。</p>
<h4 id="示例-3"><a class="header" href="#示例-3">示例 3</a></h4>
<p>这与上面的示例非常相似，但是现在内部的 for 循环从 i + 1 开始。</p>
<pre><code class="language-java">1 	void printUnorderedPairs(int[] array) {
2 		for (int i = 0; i &lt; array.length; i++) {
3 			for (int j = i + 1; j &lt; array.length; j++) {
4 				System.out.println(array[i] + "," + array[j]);
5 			}
6 		}
7 	}
</code></pre>
<p>我们可以用几种方法推导出运行时间。</p>
<blockquote>
<p>这种for循环的模式非常常见。了解运行时并深入理解它是很重要的。你不能仅仅依靠记住常见的运行时。深入理解很重要。</p>
</blockquote>
<p><em>计算迭代次数</em></p>
<p>第一次通过 j 运行 N-1 步。第二次是 N-2 步。然后 N-3 步。以此类推。</p>
<p>因此，总步数为：</p>
<pre><code>(N-1) + (N-2) + (N-3) + ... + 2 + 1
	= 1 + 2 + 3 + ... + N-1 
	= sum of 1 through N-1
</code></pre>
<p>1 到 N-1 的和是 N(N-1) / 2 （参见 630 页 “Sum of  Integers 1 through N”），所以运行时是 O(N^2)。</p>
<p><em>它的含义是什么</em></p>
<p>或者，我们可以通过思考代码的“含义”来确定运行时。它遍历 (i,  j) 中 j 大于 i 的每一对值。</p>
<p>总共有 N^2 对。其中约有一半是 i &lt; j，另一半是 i &gt; j，这段代码大概遍历了 N^2/2 对，所以它的运行时为 O(N^2)。</p>
<p><em>观察它怎么工作</em></p>
<p>当 N = 8 时，代码遍历以下 (i,  j) 对：</p>
<pre><code>(0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7)
	   (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) 
			  (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) 
					 (3, 4) (3, 5) (3, 6) (3, 7) 
							(4, 5) (4, 6) (4, 7) 
								   (5, 6) (5, 7) 
										  (6, 7)
</code></pre>
<p>这看起来像是 NxN 矩阵的一半，其大小（大约）为 N^2/2。因此，它需要 O(N^2) 的时间。</p>
<p><em>平均工作时间</em></p>
<p>我们知道外层循环运行 N 次。内层循环运行多少次？它随迭代而变化，但我们可以考虑平均迭代。</p>
<p><code>1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code> 的平均值是多少？平均值在中间，大概是 5。(当然，我们可以给出更精确的答案，但对于 big O 而言，不需要这么做。)</p>
<p>那对于 <code>1, 2, 3, ... , N</code> 呢？这个序列的平均值是 N/2。</p>
<p>因此，由于内层循环平均执行 N/2 次工作并且运行 N 次，因此总工作量为 N^2/2，即 O(N^2)。</p>
<h4 id="示例-4"><a class="header" href="#示例-4">示例 4</a></h4>
<p>这与上面的类似，但是现在我们有两个不同的数组。</p>
<pre><code class="language-java">1 	void printUnorderedPairs(int[] arrayA, int[] arrayB) {
2 		for (int i = 0; i &lt; arrayA.length; i++) {
3 			for (int j = 0; j &lt; arrayB.length; j++) {
4 				if (arrayA[i] &lt; arrayB[j]) {
5 					System.out.println(arrayA[i] + "," + arrayB[j]);
6 				}
7 			}
8 		}
9 	}
</code></pre>
<p>我们可以拆开来分析。j 的 for 循环中的 if 语句是 O(1) 时间，因为它只是一个常量时间语句的序列。</p>
<p>我们现在有了这个：</p>
<pre><code class="language-java">1 	void printUnorderedPairs(int[] arrayA, int[] arrayB) {
2 		for (int i= 0; i &lt; arrayA.length; i++) {
3 			for (int j = 0; j &lt; arrayB.length; j++) {
4 				/* O(1) work */
5 			}
6 		}
7 	}
</code></pre>
<p>对于 arrayA 的每个元素，内部的 for 循环都会进行 b 次迭代，其中 b = arrayB.length。如果 a = arrayA.length，则运行时间为 O(ab)。</p>
<p>如果你说 O(N^2)，那今后请你记住这个错误。它不是O(N^2)，因为有两个不同的输入。两者都重要。这是一个非常常见的错误。</p>
<h4 id="示例-5"><a class="header" href="#示例-5">示例 5</a></h4>
<p>那么这段奇怪的代码呢？</p>
<pre><code class="language-java">1 	void printUnorderedPairs(int[] arrayA, int[] arrayB) {
2 		for (int i = 0; i &lt; arrayA.length; i++) {
3 			for (int j = 0; j &lt; arrayB.length; j++) {
4 				for (int k = 0; k &lt; 100000; k++) {
5 					System.out.println(arrayA[i] + "," + arrayB[j]);
6 				}
7 			}
8 		}
9 	}
</code></pre>
<p>这里并没有什么实质性的改变。100,000 个单位话费的时间仍然是常数，所以运行时间还是 O(ab)。</p>
<h4 id="示例-6"><a class="header" href="#示例-6">示例 6</a></h4>
<p>下面的代码反转一个数组。它的运行时间是多少？</p>
<pre><code class="language-java">1 	void reverse(int[] array) {
2 		for (int i = 0; i &lt; array.length / 2; i++) {
3 			int other = array.length - i - 1;
4 			int temp = array[i];
5 			array[i] = array[other];
6 			array[other] = temp;
7 		}
8 	}
</code></pre>
<p>该算法运行时间为 O(N)。它仅遍历数组的一半（就迭代而言）这一事实并不会影响 big O time。</p>
<h4 id="示例-7"><a class="header" href="#示例-7">示例 7</a></h4>
<p>以下哪项哪一个等价于 O(N)？为什么？</p>
<ul>
<li>
<p>O(N + P), where P &lt; N/2</p>
</li>
<li>
<p>O(2N)</p>
</li>
<li>
<p>O(N + log N)</p>
</li>
<li>
<p>O(N + M)</p>
</li>
</ul>
<p>让我们来看看这些。</p>
<ul>
<li>
<p>如果 P &lt; N/2，那么我们知道 N 是主导项所以我们可以去掉 O(P)。</p>
</li>
<li>
<p>O(2N) 等于 O(N)，因为我们丢弃了常数。</p>
</li>
<li>
<p>O(N) 主导 O(log N)，所以我们可以去掉 O(log N)。</p>
</li>
<li>
<p>N 和 M 之间没有确定的关系，所以我们必须保留两个变量。</p>
</li>
</ul>
<p>因此，除了最后一个，其余的都等价于O(N)。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例 8</a></h4>
<p>假设我们有一个算法，它接收一个字符串数组，对每个字符串进行排序，然后对整个数组进行排序。运行时间是多少？</p>
<p>很多候选人会得出这样的结论：对每个字符串排序是 O(N log N)，并且我们必须对每个字符串进行排序，因此就是 O(N*N log N)。我们还必须对这个数组进行排序，所以这是一个额外的 O(N log N) 的工作。因此，总的运行时间是 O(N²log N + N log N)，也就是 O(N²log N)。</p>
<p>这是完全错误的。你发现错误了吗？</p>
<p>问题在于我们以两种不同的方式使用 N。在一种情况下，它是字符串的长度（哪个字符串？）。在另一种情况下，它是数组的长度。</p>
<p>在面试中，你可以完全不使用变量“ N”，或者仅在对 N 可以表示什么没有歧义时才使用它，以防止出现此错误。</p>
<p>实际上，我甚至不会在这里使用 a 和 b，或者 m 和 n。因为很容易忘记哪个是哪个，然后把它们完全搞混了。O(a^2) 运行时与 O(a*b) 运行时完全不同。</p>
<p>让我们定义新的术语，并使用符合逻辑的名称。</p>
<ul>
<li>
<p>设 s 为最长字符串的长度。</p>
</li>
<li>
<p>设 a 为数组的长度。</p>
</li>
</ul>
<p>现在我们可以通过以下几个部分来解决这个问题：</p>
<ul>
<li>
<p>排序每个字符串为 O(s log s)。</p>
</li>
<li>
<p>我们必须对每个字符串（这里是字符串 a）执行此操作，所以是 O(a*s log s)。</p>
</li>
<li>
<p>现在我们要对所有的字符串排序。有字符串 a，所以你可能会说这要花费 O(a log a) 时间。这是大多数候选人会说的话。你还应该考虑到需要比较字符串。每个字符串比较需要 O(s) 的时间。存在 O(a log a) 个比较，因此这将花费 O(a*s log a) 的时间。</p>
</li>
</ul>
<p>如果把这两部分相加，就得到 O(a*s(log a + log s))。</p>
<p>就是这个。没有办法进一步减少它。</p>
<h4 id="示例-9"><a class="header" href="#示例-9">示例 9</a></h4>
<p>下面的简单代码将平衡二叉搜索树中所有节点的值相加。它的运行时间是多少？</p>
<pre><code class="language-java">1 	int sum(Node node) {
2 		if (node == null) {
3 			return 0;
4 		}
5 		return sum(node.left) + node.value + sum(node.right);
6 	}
</code></pre>
<p>仅仅因为它是一个二叉搜索树并不意味着它的运行时间里面有一个 <code>log</code>！</p>
<p>我们可以从两个方面来看。</p>
<p><em>它的含义是什么</em></p>
<p>最直接的方法是思考这段代码的含义什么。这段代码接触树中的每个节点一次，并对每个“接触”执行固定时间量的工作（不包括递归调用）。</p>
<p>因此，运行时就节点数而言将是线性的。如果有 N 个节点，则运行时间为 O(N)。</p>
<p><em>递归模式</em></p>
<p>在第 44 页，我们讨论了具有多个分支的递归函数的运行时的模式。让我们在这里尝试下这种方法。</p>
<p>我们说过，具有多个分支的递归函数的运行时间通常是 O(branches^depth)。每个调用有两个分支，所以我们得到 O(2^depth)。</p>
<p>在这一点上，许多人可能会认为，因为我们有一个指数算法，所以有些地方出了问题——我们的逻辑有缺陷，或者我们无意中创造了一个指数时间算法（呀!）</p>
<p>第二句话是正确的。我们确实有一个指数时间算法，但是它并不像人们想象的那样糟糕。考虑它关于哪个变量是指数的。</p>
<p>深度是多少？这是一棵平衡的二叉搜索树。因此，如果总共有 N 个节点，那么深度大约是 log N。</p>
<p>根据上面的方程，我们得到 O(2^log N)。</p>
<p>回顾一下 log₂ 的含义：</p>
<pre><code>2^P = Q -&gt; log₂Q = P
</code></pre>
<p>2^log N是多少？2 和 log 之间存在关系，因此我们可以化简一下。</p>
<p>令 P = 2 log N。根据 log₂ 的定义，我们可以写成 log₂P = log₂N。这意味着 P =N。</p>
<pre><code>Let P = 2^log N
	-&gt; log₂P = log₂N 
	-&gt; P = N 
	-&gt; 2^logN = N
</code></pre>
<p>因此，这段代码的运行时间是 O(N)，其中 N 是节点的数量。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例 10</a></h4>
<p>以下方法来检查一个数字是否为质数，具体是通过检查小于它的数字的可除性。它只需要向上到 n 的平方根，因为如果 n 能被一个比它平方根大的数整除，那么它就能被比它小的数整除。</p>
<p>例如，虽然 33 可以被 11 整除（11大于33的平方根），与 11 的“对应”的因数为 3（3 * 11 = 33）。因此在使用 3 时已经将 33 排除为质数了。</p>
<p>该函数的时间复杂度是多少？</p>
<pre><code class="language-java">1 	boolean isPrime(int n) {
2 		for (int x = 2; x * x &lt;= n; x++) {
3 			if (n % X == 0) {
4 				return false;
5 			}
6 		}
7 		return true;
8 	}
</code></pre>
<p>很多人把这个问题想错了。但如果你仔细考虑你的逻辑，这是相当容易的。</p>
<p>for 循环内部的工作是常数。因此，我们只需要知道在最坏的情况下 for 循环要执行多少次迭代。</p>
<p>for循环将在 x = 2 时开始，在 x*x = n 时结束。换句话说，当 x =√n 时（x等于n的平方根），for 循环停止。</p>
<p>这个 for 循环实际上是这样的：</p>
<pre><code class="language-java">1 	boolean isPrime(int n) {
2 		for (int x = 2; x =&lt; sqrt(n); x++) { 
3 			if (n % x == 0) {
4 				return false;
5 			}
6 		}
7 		return true;
8 	}
</code></pre>
<p>这需要 O(√n) 的时间。</p>
<h4 id="示例-11"><a class="header" href="#示例-11">示例 11</a></h4>
<p>下面的代码计算 n!（n的阶乘）。它的时间复杂度是多少？</p>
<pre><code class="language-java">1 	int factorial(int n) {
2 		if (n &lt; 0) {
3 			return -1;
4 		} else if (n == 0) { 
5 			return 1;
6 		} else {
7 			return n * factorial(n - 1);
8 		}
9 	}
</code></pre>
<p>这是一个从 n 到 n-1 到 n-2 一直到 1 的递归。这将花费 O(n) 时间。</p>
<h4 id="示例-12"><a class="header" href="#示例-12">示例 12</a></h4>
<p>这段代码计算字符串的所有排列。</p>
<pre><code class="language-java">1 	void permutation(String str) {
2 		permutation(str, "");
3 	}
4 
5 	void permutation(String str, String prefix) {
6 		if (str.length() == 0) {
7 			System.out.println(prefix);
8 		} else {
9 			for (int i = 0; i &lt; str.length(); i++) {
10 				String rem = str.substring(0, i) + str.substring(i + 1);
11 				permutation(rem, prefix + str.charAt(i));
12 			}
13 		}
14 	}
</code></pre>
<p>这是一个（非常！）棘手的问题。我们可以通过调用 permutation 方法的次数和每次调用的时间来考虑这个问题。我们的目标是尽可能缩小上限。</p>
<p><em>permutation 方法在基本情况下被调用多少次？</em></p>
<p>如果要生成一个排列，则需要为每个“槽（slot）”选择字符。假设字符串中有 7 个字符。在第一个槽中，我们有 7 个选择。选好字母后，下一个槽有 6 个选择。（请注意，这是前面 7 个选项中的每一个的 6 个选项。）然后，对于下一个槽，有 5 个选择，依此类推。</p>
<p>因此，选项的总数为 <code>7 * 6 * 5 * 4 * 3 * 2 * 1</code>，也表示为<code>7!</code>（7d 阶乘）。</p>
<p>这告诉我们有 <code>n!</code> 个排列。因此，在基本情况下 permutation 方法被调用了 <code>n!</code> 次（当 prefix 是全排列时）。</p>
<p><em>permutation 方法在基本情况之前被调用多少次？</em></p>
<p>但是，当然，我们还需要考虑第 9 行到第 12 行被命中的次数。绘制一个表示所有调用的大型调用树。有 <code>n!</code> 个叶子，如上所示。每个叶子都连接到一个长度为 n 的路径上。因此，我们知道不会超过 <code>n * n!</code> 个该树中的节点（函数调用）。</p>
<p><em>每个函数调用需要多长时间？</em></p>
<p>执行第 7 行需要 O(n) 时间，因为每个字符都需要打印。</p>
<p>由于字符串连接，第 10 行和第 11 行也将花费 O(n) 时间。注意 rem、prefix 和 str. charAt(i) 的长度之和始终为 n。</p>
<p>因此，调用树中的每个节点都对应 O(n) 的工作。</p>
<p><em>总运行时间是多少？</em></p>
<p>因为我们调用了 O(n * n!) 次（作为上限）permutation 方法，每次调用都需要 O(n)次，所以总的运行时不会超过 O(n^2 * n!)。</p>
<p>通过更复杂的数学，我们可以推导出一个更紧凑的运行时方程（尽管不一定是一个漂亮的封闭表达式）。几乎可以肯定，这超出了任何普通面试的范围。</p>
<h4 id="示例-13"><a class="header" href="#示例-13">示例 13</a></h4>
<p>下面的代码计算第 N 个斐波那契数。</p>
<pre><code class="language-java">1 	int fib(int n) {
2 		if (n &lt;= 0) return 0;
3 		else if (n == 1) return 1; 
4 		return fib(n - 1) + fib(n - 2);
5 	}
</code></pre>
<p>我们可以使用之前为递归调用建立的模式：O(branches^depth)。</p>
<p>每个调用有 2 个分支，我们深度到 N，因此运行时是 O(2^N)。</p>
<blockquote>
<p>通过一些非常复杂的数学运算，我们实际上可以获得更紧凑的运行时。时间确实是指数的，但实际上更接近 O(1.6^N)。它不是 O(2^N) 的原因是，在调用堆栈的底部，有时只有一个调用。事实证明，许多节点都位于底部（大多数树都是这样），因此，单次调用与两次调用实际上会产生很大的差异。但是，说 O(2^N) 在面试范围内就足够了（并且，如果你阅读了有关第 39 页的 big theta 的说明，就会知道这从技术上讲也是正确的）。你可能会得到“额外的分数”，如果你能意识到它实际上会比这少。</p>
</blockquote>
<p>一般来说，当你看到一个具有多个递归调用的算法时，你需要考虑指数运行时。</p>
<h4 id="示例-14"><a class="header" href="#示例-14">示例 14</a></h4>
<p>下面的代码打印从 0 到 n 的所有斐波那契数。它的时间复杂度是多少？</p>
<pre><code class="language-java">1 	void allFib(int n) {
2 		for (int i = 0; i &lt; n; i++) {
3 			System.out.println(i + "： "+ fib(i));
4 		}
5 	}
6 
7 	int fib(int n) {
8 		if (n &lt;= 0) return 0;
9 		else if (n == 1) return 1;
10 		return fib(n - 1) + fib(n - 2);
11 	}
</code></pre>
<p>许多人会急于得出这样的结论，因为 fib(n) 需要 O(2^n) 的时间，被调用 n 次，那么它就是 O(n2^n)。</p>
<p>不要这么快下结论。你能找出逻辑上的错误吗？</p>
<p>错误是 n 是在变化的。的确，fib(n) 需要 O(2^n) 的时间，但重要的是 n 的值是多少。</p>
<p>相反，让我们遍历每个调用。</p>
<pre><code>fib(1) -&gt; 2^1 steps 
fib(2) -&gt; 2^2 steps 
fib(3) -&gt; 2^3 steps 
fib(4) -&gt; 2^4 steps
...
fib(n) -&gt; 2^n steps

</code></pre>
<p>因此，总工作量为：</p>
<pre><code>2^1 + 2^2 + 2^3 + 2^4 + ... + 2^n
</code></pre>
<p>正如我们在第 44 页上展示的那样，这是 2^(n+1)。因此，计算前 n 个斐波那契数的运行时间（使用这个糟糕的算法）仍然是 O(2^n)。</p>
<h4 id="示例-15"><a class="header" href="#示例-15">示例 15</a></h4>
<p>下面的代码打印从 0 到 n 的所有斐波那契数。但是，这一次，它将先前计算出的值存储（即缓存）在整数数组中。如果已经计算过，它将仅返回缓存。它的运行时间是多少？</p>
<pre><code class="language-java">1 	void allFib(int n) {
2 		int[] memo = new int[n + 1];
3 		for (int i = 0; i &lt; n; i++) {
4 			System.out.println(i + "： " + fib(i, memo));
5 		}
6 	}
7 
8 	int fib(int n, int[] memo) {
9 		if (n &lt;= 0) return 0;
10 		else if (n == 1) return 1;
11 		else if (memo[n] &gt; 0) return memo[n];
12 
13 		memo[n]= fib(n - 1, memo) + fib(n - 2, memo);
14 		return memo[n];
15 	}
</code></pre>
<p>让我们来看看这个算法是怎么工作的。</p>
<pre><code>fib(1) -&gt; return 1
fib(2)
	fib(1) -&gt; return 1 
	fib(0) -&gt; return 0 
	store 1 at memo[2]
fib(3)
	fib(2) -&gt; lookup memo[2] -&gt; return 1 
	fib(1) -&gt; return 1
	store 2 at memo[3]
fib(4)
	fib(3) -&gt; lookup memo[3] -&gt; return 2 
	fib(2) -&gt; lookup memo[2] -&gt; return 1 
	store 3 at memo[4]
fib(5)
	fib(4) -&gt; lookup memo[4] -&gt; return 3 
	fib(3) -&gt; lookup memo[3] -&gt; return 2 
	store 5 at memo[5]
...
</code></pre>
<p>在每次调用 fib(i) 时，我们都已经计算并存储了 fib(i-1) 和 fib(i-2) 的值。我们只需查找这些值，对它们求和，存储新结果，然后返回。这只需要固定的时间。</p>
<p>我们做了N次花费固定时间的工作，所以这是 O(N) 时间。</p>
<p>这种技术称为记忆法（memoization），是一种非常常见的优化指数时间递归算法的方法。</p>
<h4 id="示例-16"><a class="header" href="#示例-16">示例 16</a></h4>
<p>下面的函数从1到n（包括 1 和 n）打印2的幂。例如，如果 n 是4，它会输出 1、2 和 4。它的运行时间是多少？</p>
<pre><code class="language-java">1 	int powers0f2(int n) {
2 		if (n &lt; 1) {
3 			return 0;
4 		} else if (n == 1) {
5 			System.out.println(1);
6 			return 1;
7 		} else {
8 			int prev = powers0f2(n / 2); 
9 			int curr = prev * 2; 
10 			System.out.println(curr); 
11 			return curr;
12 		} 
13 	}
</code></pre>
<p>有几种方法可以计算此运行时间。</p>
<p><em>它做了什么</em></p>
<p>让我们来看看像 powers0f2(50) 这样的调用。</p>
<pre><code class="language-java">powers0f2(50)
	-&gt; powers0f2(25)
 		-&gt; powers0f2(12)
			-&gt; powers0f2(6)
				-&gt; powers0f2(3)
					-&gt; powersOf2(1)
						-&gt; print &amp; return 1 
					print &amp; return 2
				print &amp; return 4 
			print &amp; return 8
		print &amp; return 16 
	print &amp; return 32
</code></pre>
<p>那么，运行时间就是我们将 50（或n）除以 2 直到得出基本情况(1)的次数。正如我们在第 44 页上讨论的那样，可以将 n 减半直到得到 1 的次数是 O(log n)。</p>
<p><em>它的含义是什么</em></p>
<p>我们也可以通过思考代码应该是做什么的，来得出运行时。它应该是为了从 1 到 n 计算 2 的幂。</p>
<p>对 powers0f2 的每次调用都会打印并返回一个数字（不包括递归调用中发生的情况）。因此，如果该算法在最后打印了 13 个值，那么 powers0f2 就是被调用了 13 次。</p>
<p>在本例中，我们被告知它打印了 1 到 n 之间的所有 2 的幂。因此，函数被调用的次数（也就是它的运行时）必须等于 1 到 n 之间的 2 的幂的个数。</p>
<p>在 1 和 N 之间有 log N 个 2 的幂，因此，运行时间为 O(log n)。</p>
<p><em>增加速率</em></p>
<p>处理运行时的最后一种方法是考虑当 n 变大时运行时如何变化。毕竟，这正是 big O time 的意义所在。</p>
<p>如果 N 从 P 变为 P+1，那么对 powersOfTwo 的调用数量可能根本不会改变。什么时候调用 powersOfTwo 的次数会增加？每次 n 大小加倍时，它将增加 1。</p>
<p>因此，每当 n 翻倍时，对 powersOfTwo 的调用次数就增加 1。因此，对powersOfTwo 的调用次数就是你从 1 开始执行翻倍直到得到 n 的所用的次数，它是方程 2x = n 中的 x。</p>
<p>x是什么？x 的值是 log n，这正是 x = log n 的含义。</p>
<p>因此，运行时为 O(log n)。</p>
<hr />
<h3 id="interview-questions"><a class="header" href="#interview-questions">Interview Questions</a></h3>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="vii-技术问题-1"><a class="header" href="#vii-技术问题-1">VII. 技术问题</a></h1>
<p>技术问题是许多顶级科技公司面试的基础。很多考生都被这些问题的难度吓到了，但还是有一些合理的方法来解决它们。</p>
<h3 id="如何准备"><a class="header" href="#如何准备">如何准备</a></h3>
<p>许多候选人只是通读问题和答案。这就像试图通过阅读问题及其答案来学习微积分一样。你需要练习解决问题，单纯记住答案对你是没有多大帮助的。</p>
<p>对于本书中的每个问题（以及你可能遇到的任何其他问题），请执行以下操作：</p>
<ol>
<li>试着自己解决这个问题。在这本书的后面提供了一些提示，但是要逼着自己在尽可能少的帮助下给出答案。很多问题都是被设计成来刁难人的——这也没关系！当你解决一个问题时，一定要考虑空间和时间效率。</li>
<li>把代码写在纸上。在计算机上编码提供了诸如语法高亮显示、代码补全和快速调试等功能，写在纸上的代码则不然。通过在纸上编码来习惯这种情况，适应以这样较慢的速度编写和编辑代码。</li>
<li>在纸上测试代码。这意味着要测试一般情况、基本情况、错误情况等等。你在面试时需要这样做，因此最好事先进行练习。</li>
<li>把你的纸面代码原样输入计算机。你可能会犯很多错误。列出所有你犯过的错误，这样你就能在面试时记住这些错误。</li>
</ol>
<p>此外，尝试进行尽可能多的模拟采访。你和朋友可以轮流互相进行模拟面试。尽管你的朋友可能不是专家面试官，但他或她仍然可以引导你解决编码或算法问题。同时通过体验面试官的工作，你也会学到很多。</p>
<h3 id="你需要知道什么"><a class="header" href="#你需要知道什么">你需要知道什么</a></h3>
<p>构和算法问题并不是针对知识点的测试。但是，他们确实也假定了一个知识基线。</p>
<h4 id="核心数据结构算法和概念"><a class="header" href="#核心数据结构算法和概念">核心数据结构、算法和概念</a></h4>
<p>大多数面试官不会问有关二叉树平衡或其他复杂算法的这类特殊算法。坦白说，由于已经离开学校几年了，他们可能也不记得这些算法。</p>
<p>你通常只需要知道基本的知识。以下是一些绝对必备的知识：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">数据结构</th><th style="text-align: center">算法</th><th style="text-align: center">概念</th></tr></thead><tbody>
<tr><td style="text-align: center">Linked Lists</td><td style="text-align: center">Breadth-First Search</td><td style="text-align: center">Bit Manipulation</td></tr>
<tr><td style="text-align: center">Trees, Tries, &amp;Graphs</td><td style="text-align: center">Depth-First Search</td><td style="text-align: center">Memory (Stack vs. Heap)</td></tr>
<tr><td style="text-align: center">Stacks &amp; Queues</td><td style="text-align: center">Binary Search</td><td style="text-align: center">Recursion</td></tr>
<tr><td style="text-align: center">Heaps</td><td style="text-align: center">Merge Sort</td><td style="text-align: center">Dynamic Programming</td></tr>
<tr><td style="text-align: center">Vectors / ArrayLists</td><td style="text-align: center">Quick Sort</td><td style="text-align: center">Big O Time &amp; Space</td></tr>
<tr><td style="text-align: center">Hash Tables</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<p>对于每个主题，确保你了解如何使用和实现它们、以及分别适用于什么情况，空间和时间复杂度分别是多少。</p>
<p>练习实现数据结构和算法（先在纸上，然后在计算机上）也是一个很好的训练。它将帮助你了解数据结构的内部是如何工作的，这对于许多面试是很重要的。</p>
<blockquote>
<p>你错过了上面的那段吗？ 这一点很重要。如果你对列出的每个数据结构和算法都不是很熟悉，请从头开始练习实现它们。</p>
</blockquote>
<p>特别地，哈希表是一个非常重要的主题。确保你对这种数据结构非常熟悉。</p>
<h4 id="2-的幂表"><a class="header" href="#2-的幂表">“2 的幂”表</a></h4>
<p>下表对于许多涉及可伸缩性或任何内存限制的问题都很有用。虽然并不严格要求对这个表进行记忆，但是它很有用。你至少应该轻松的推导出来。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">2 的幂</th><th style="text-align: center">精确值（X）</th><th style="text-align: center">约值</th><th style="text-align: center">X Byte 转 MB/GB/等等</th></tr></thead><tbody>
<tr><td style="text-align: center">7</td><td style="text-align: center">128</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">256</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: center">1024</td><td style="text-align: center">1 thousand</td><td style="text-align: center">1KB</td></tr>
<tr><td style="text-align: center">16</td><td style="text-align: center">65,536</td><td style="text-align: center"></td><td style="text-align: center">64KB</td></tr>
<tr><td style="text-align: center">20</td><td style="text-align: center">1,048,576</td><td style="text-align: center">1 million</td><td style="text-align: center">1 MB</td></tr>
<tr><td style="text-align: center">30</td><td style="text-align: center">1,073,741,824</td><td style="text-align: center">1 billion</td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center">32</td><td style="text-align: center">4,294,967,296</td><td style="text-align: center"></td><td style="text-align: center">4 GB</td></tr>
<tr><td style="text-align: center">40</td><td style="text-align: center">1,099,511,627,776</td><td style="text-align: center">1 trillion</td><td style="text-align: center">1 TB</td></tr>
</tbody></table>
</div>
<p>例如，使用这个表，你可以快速推断出将每个 32 位整数映射到布尔值的位向量（bit vector），是否可以装入典型计算机的内存中。有 2^32 个这样的整数。因为每个整数在这个位向量中取一个位，所以我们需要 2^32 位（或 2^29 个字节）来存储这个映射。这大约是半个千兆字节的内存，可以轻松地将其保存在典型计算机上的内存中。</p>
<p>如果你正在与一家基于 Web （web-based）的公司进行视频面试，那么面前放一张这个表格可能会很有用。</p>
<h3 id="解决问题"><a class="header" href="#解决问题">解决问题</a></h3>
<p>下面的流程图将引导你如何逐步解决问题。在你的练习中使用它。你可以在 <em>CrackingTheCodinglnterview.com</em> 上下载这个资料以及更多内容。</p>
<div align=center><img src="img/VII_1.png"/></div>
我们将详细介绍此流程图。
<h4 id="期待什么"><a class="header" href="#期待什么">期待什么</a></h4>
<p>面试应该是很困难的。如果你没有立即得到所有或任何的答案，那也没关系！这是正常的体验，也不坏。</p>
<p>听取面试官的引导。面试官可能会在你解决问题的过程中扮演更积极或不那么积极的角色。面试官的参与程度取决于你的表现、问题的难度、面试官想要什么以及面试官的个性。</p>
<p>当你遇到问题的时候（或者当你练习的时候），请使用以下方法去解决它。</p>
<h4 id="1-仔细听"><a class="header" href="#1-仔细听">1. 仔细听</a></h4>
<p>你可能以前听过这个建议，但是我说的比标准的“确保你正确地听到了问题”这种建议要稍微多一点。</p>
<p>是的，你确实需要倾听问题并确保听对了。你确实需要对一些你不确定的地方进行提问。</p>
<p>但我要说的远不止这些。</p>
<p>仔细听问题，确保你已经在脑中记录了关于问题的所有独特信息。</p>
<p>例如，假设一个问题从以下几行之一开始。我们有理由认为这些信息的存在是有原因的。</p>
<ul>
<li>
<p>“给出两个已排序的数组，找到...”</p>
<p>你可能需要知道数据是已排序。用于排序情况下的最优算法可能不同于未排序情况下的最优算法。</p>
</li>
<li>
<p>“设计一个算法，以在服务器上重复运行……”</p>
<p>服务器要反复运行的情况不同于一次运行的情况。也许这意味着你需要缓存数据？ 或者这表明了对初始数据集要进行合理的预计算？</p>
</li>
</ul>
<p>如果不影响你的算法，面试官不太可能（尽管不是不可能）给你这些信息。</p>
<p>许多候选人会正确地听到这个问题。但是在开发算法的十分钟后，该问题的一些关键细节就被遗忘了。现在他们处于实际上无法最优地解决问题的情况。</p>
<p>你的第一个算法不需要使用这些信息。但是，如果你发现自己陷入了困境，或者你仍然在努力开发更优的东西，问问自己是否已经使用了问题中的所有信息。</p>
<p>你甚至会发现在白板上写下相关信息是很有用的。</p>
<h4 id="2-举一个例子"><a class="header" href="#2-举一个例子">2. 举一个例子</a></h4>
<p>当你听到问题时，从椅子上站起来，走到白板前，画一个例子。</p>
<p>画一个例子是有艺术的。你需要一个好的例子。</p>
<p>这里有一个非常典型的案例，候选人可能会画这样的东西作为二叉搜索树的一个例子：</p>
<div align=center><img src="img/VII_2.png"/></div>
这是一个糟糕的例子，有几个原因。首先，它太小了。在这么小的示例中，你将很难找到一个模式。其次，它并不具体。一个二叉搜索树应该是有值的。不然如果这些数字告诉你如何解决这个问题，你该怎么办？第三，这实际上是一个特例。它不仅是一棵平衡的树，而且还是一棵美丽，完美的树，除了叶子以外的每个节点都有两个孩子。特殊情况可能很具有欺骗性。
<p>相反，你应该创建这样一个示例：</p>
<ul>
<li>
<p>具体。应该使用实数或字符串（如果适用于此问题）。</p>
</li>
<li>
<p>足够大。大多数例子都太小了，只有 50%。</p>
</li>
<li>
<p>不是特例。要当心。很容易在不经意间画出一个特例。如果你的示例有某种特殊情况（即使你认为这可能没什么大不了的），你应该修复它。</p>
</li>
</ul>
<p>尽力举出最好的例子。如果后来发现你的示例不太正确，你可以并且应该修复它。</p>
<h4 id="3-使用蛮力"><a class="header" href="#3-使用蛮力">3. 使用蛮力</a></h4>
<p>一旦你完成了一个示例（实际上，你可以在某些问题中切换步骤 2 和步骤 3 的顺序），就可以使用蛮力破解了，并且对你的初始算法不是最优的有个心理预期。</p>
<p>一些候选人没有使用蛮力破解，因为他们认为蛮力破解方法是很浅显的，同时又很糟糕。但这就是问题：即使对你来说显而易见，但对所有的候选人来说未必都是显而易见的。而且，你也不希望你的面试官认为你正在努力查找这个简单的解决方案。</p>
<p>这个最初的解决方案很糟糕，这没有关系。解释空间和时间复杂度是多少，然后再进行改进。</p>
<p>尽管可能很慢，但蛮力算法还是值得讨论的。这是一个优化的起点，它可以帮助你理解问题。</p>
<h4 id="4-优化"><a class="header" href="#4-优化">4. 优化</a></h4>
<p>一旦你有了一个蛮力算法，你应该优化它。以下是一些行之有效的技巧：</p>
<ol>
<li>查找任何未使用的信息。你的面试官是否告诉你数组已排序？ 你如何利用这些信息？</li>
<li>举一个新的例子。有时，仅仅看一个不同的例子就能让你的头脑清醒，或者帮助你发现问题的模式。</li>
<li>“不正确地”解决它。就像拥有低效的解决方案可以帮助你找到有效的解决方案一样，拥有不正确的解决方案也可以帮助你找到正确的解决方案。例如，如果要求你从一个集合中生成一个随机值，使所有值的概率都相等，那么错误的解决方案可能是返回一个半随机值：任何值都可以返回，但是有些值的概率比其他值大。然后，你可以考虑为什么该解决方案不是完全随机的。你可以重新平衡概率吗？</li>
<li>权衡时间和空间。有时，存储关于该问题额外的状态数据可以帮助你优化运行时间。</li>
<li>预计算信息。有没有一种方法可以重组数据（排序等）或预先计算一些值，从而长远来看将有助于节省时间？</li>
<li>使用哈希表。哈希表在面试问题中被广泛使用，你应该首先考虑它。</li>
<li>考虑一下可能的最佳运行时（第72页讨论）。</li>
</ol>
<p>带着这些想法审视之前的蛮力算法，并寻找 BUD（第67页）。</p>
<h4 id="5-审视"><a class="header" href="#5-审视">5. 审视</a></h4>
<p>在你确定了一个最优算法之后，不要只专注于编码。花一点时间巩固你对算法的理解。</p>
<p>白板编程很慢很慢。测试和修复代码也是如此。因此，你需要确保你在一开始就尽可能接近“完美”。</p>
<p>审视一遍你的算法，感受一下代码的结构。知道变量是什么，什么时候改变。</p>
<blockquote>
<p>考虑先使用伪代码怎么样？ 你可以根据需要编写伪代码。请注意所写内容。基本步骤（"(1) Search array. (2) Find biggest. (3) Insert in heap."）或简短的逻辑（"if p &lt; q, move p. else move q"）都很有用。但是，当你的伪代码开始出现用简单的英语编写的 for 循环时，那么你实际上只是在编写草率的代码。这样的话，直接编写代码可能会更快。</p>
</blockquote>
<p>如果你不能准确地理解将要编写的内容，那么你将很难编写代码。它将花费你更长的时间来完成代码，并且你更有可能犯重大错误。</p>
<h4 id="6-实现"><a class="header" href="#6-实现">6. 实现</a></h4>
<p>现在你已经有了一个最优的算法，你也知道你要编写什么了，那就去实现它吧。</p>
<p>从白板左上角开始编码（你需要空间）。避免“线蠕动（line creep）”（即每行代码都写得歪歪扭扭）。它使你的代码看起来很凌乱，在使用诸如 Python 之类的对空格敏感语言时可能会非常混乱。</p>
<p>请记住，你只有少量的代码来证明你是一名出色的开发人员。每件事都很重要。编写漂亮的代码。</p>
<p>漂亮的代码意味着：</p>
<ul>
<li>
<p>模块化的代码。这显示出良好的编码风格。这也使事情变得更轻松。如果你的算法使用初始化为 <code>{{1, 2, 3}, {4, 5, 6}, ...}</code> 的矩阵，请不要浪费时间来编写这个初始化代码。只需要假设你有一个函数 <code>initIncrementalMatrix(int size)</code> 就可以了。如果需要，稍后再填写详细信息。</p>
</li>
<li>
<p>错误检查。有些面试官很在乎这个，而有些则不然。一个不错的折衷方法是添加一个 <code>todo</code>，然后大声地解释你想要测试的内容。</p>
</li>
<li>
<p>在适当的地方使用其他类/结构。如果需要用函数返回一个起点和终点的列表，则可以将其作为二维数组来执行。最好将其作为一个 StartEndPair（或可能是 Range）对象的列表来执行。你不必为类填写详细信息。只需要假装它是存在的就可以了，后面有时间再处理细节。</p>
</li>
<li>
<p>好的变量名。到处都使用单字母变量的代码很难阅读。这并不是说在适当的地方使用 i 和 j 会有什么问题（例如在遍历数组的基本 for 循环中）。但是，要注意在哪里才可以这样做。如果你编写类似 <code>int i = startOfChild(array)</code> 这样的内容，则此变量应该有一个更好的名称，例如 startChild。</p>
<p>不过，长变量名也可能写起来很慢对于大多数面试官来说，在第一次使用后将其缩写是可以接受的。你可以第一次使用 startChild，然后向面试官说明，此后你将其缩写为 sc。</p>
</li>
</ul>
<p>决定能否写出漂亮代码的具体细节，在不同的面试官和候选人之间，甚至在不同的问题上，都是不同的。专注于编写漂亮的代码，不管它对你来说意味着什么。</p>
<p>如果你发现一些你以后可以重构的东西，那么向你的面试官解释一下，然后决定是否值得花时间这么做。通常是值得的，但也并非总是如此。</p>
<p>如果你感到困惑（这很常见），请回到你的示例并再次审视一遍。</p>
<h4 id="7-测试"><a class="header" href="#7-测试">7. 测试</a></h4>
<p>在实际工作中，你不可能不经过测试就提交代码，你也不应该在不测试代码的情况下就向面试官“提交”代码。</p>
<p>但是，有一些聪明的和不那么聪明的方法来测试你的代码。</p>
<p>许多候选人要做的就是以他们先前的示例为例，并对照其代码进行测试。这可能会发现bug，但这需要很长时间。手工测试非常慢。如果你确实使用了一个不错的大型示例来开发算法，那么你将需要很长时间才能在代码末尾发现一个很小的差一错误（off-by-one error）。</p>
<p>相反，请尝试以下方法：</p>
<ol>
<li>从“概念”测试开始。概念测试意味着只阅读和分析每行代码的功能。想一想，就像你在为代码审阅者解释代码行一样。代码是否按照你认为的方式工作？</li>
<li>看起来很奇怪的代码。仔细检查 <code>x = length - 2</code> 的那行代码。研究从 <code>i = 1</code> 开始的 for 循环。尽管你这样做无疑是有原因的，但确实是这里很容易出错。</li>
<li>热点。你已经编写了足够多的代码，应该了解哪些地方可能导致问题。递归代码中的基本用例。整数除法。二叉树中的空节点。一个链表的迭代的开始和结束。再检查一遍。</li>
<li>小的测试用例。这是我们第一次使用实际的、特定的测试用例来测试代码。不要使用算法部分中那个漂亮的 8 个元素的大数组。相反，要使用 3 或 4 个元素的数组。它可能会发现相同的 bug，但是这样做要快得多。</li>
<li>特殊情况。针对空值或单个元素值、极端情况和其他特殊情况测试代码。</li>
</ol>
<p>当你发现 bug 时（你可能会发现），当然应该修复它们。但不要只做你想到的第一个修正。相反，应该仔细分析错误发生的原因，并确保你的修复是最好的。</p>
<h3 id="优化和解决技巧-1寻找-bud"><a class="header" href="#优化和解决技巧-1寻找-bud">优化和解决技巧 #1：寻找 BUD</a></h3>
<p>这可能是我发现的用于优化问题的最有用的方法。“BUD” 是一个愚蠢的缩写词：</p>
<ul>
<li>瓶颈</li>
<li>不必要的工作</li>
<li>重复的工作</li>
</ul>
<p>这是算法可以“浪费”时间做的三件事。你可以从这几个方面出发审视你的蛮力算法。找到其中之一后，你就可以集中精力摆脱它。</p>
<p>如果它仍然不是最优的，你可以在当前的最佳算法上重复这种方法。</p>
<h4 id="瓶颈"><a class="header" href="#瓶颈">瓶颈</a></h4>
<p>瓶颈是算法的一部分，它会减慢整体运行时间。有两种常见的发生方式：</p>
<ul>
<li>
<p>有一次工作（one-time work）减慢了你的算法。例如，假设你有一个两步算法，首先对数组排序，然后查找具有特定属性的元素。第一步是 O(N log N)，第二步是 O(N)。也许你可以将第二步简化为 O(log N) 或 O(1)，但这有关系吗？不会太多。这当然不是优先事项，因为 O(N log N) 是瓶颈。在优化第一步之前，你的整体算法仍将是 O(N log N)。</p>
</li>
<li>
<p>你有一大块工作是重复做的，比如搜索。也许你可以把它从 O(N) 减少到 O(log N) 甚至 O(1)。这将大大加快你的整体运行时间。</p>
</li>
</ul>
<p>优化瓶颈可以对你的整体运行时间产生很大的影响。</p>
<blockquote>
<p>示例：给定一个由不同整数值组成的数组，计算具有差 k 的整数对的数量。例如，给定数组 {1, 7, 5, 9, 2, 12, 3}，且差 k = 2，则有具有差 2 整数对有四个：(1, 3), (3, 5), (5, 7), (7, 9)。</p>
</blockquote>
<p>蛮力算法是从第一个元素开始遍历数组，然后搜索其余元素（将构成该对的另一边）。对于每一对，计算它们的差。如果差值等于 k，则增加该差的计数器。</p>
<p>这里的瓶颈是重复搜索这一对的“另一边”。因此，优化是最重要的。</p>
<p>我们怎样才能更快地找到正确的“另一边”？我们知道 (x, ？) 的另一边，它是 x + k 或者 x - k。如果我们对数组排序，可以在 O(log N) 时间内通过二分查找找到 N 个元素的另一边。</p>
<p>我们现在有一个两步算法，两个步骤都花费 O(N log N) 的时间。现在，排序成为了新的瓶颈。优化第二步是没有用的，因为第一步无论如何都会减慢我们的速度。</p>
<p>我们只需要完全摆脱第一步，然后对未排序的数组进行操作即可。如何在一个无序的数组中快速查找？用一个哈希表。</p>
<p>将数组中的所有内容都放入哈希表中。然后，要查找数组中是否存在 x + k 或 x-k，只需在哈希表中查找它即可。我们可以在 O(N) 时间内完成此操作。</p>
<h4 id="不必要的工作"><a class="header" href="#不必要的工作">不必要的工作</a></h4>
<blockquote>
<p>示例：打印方程 a^3 + b^3 = c^3 + d^3 的所有正整数解，其中 a、b、c 和 d 是 1 到 1000 之间的整数。</p>
</blockquote>
<p>一个蛮力解决方案就是有四个嵌套的 for 循环。就像是：</p>
<pre><code>1 	n = 1000
2 	for a from 1 to n
3 		for b from 1 to n
4 			for c from 1 to n
5 				for d from 1 to n
6 					if a^3 + b^3 == c^3 + d^3 
7 						print a, b, c, d
</code></pre>
<p>该算法会遍历 a、b、c 和d 的所有可能值，并检查该组合是否正确。</p>
<p>没必要继续检查其他可能的 d 值。因为只有一个可以工作。找到正确的那个答案后，我们至少应该执行 break。</p>
<pre><code>1 	n = 1000
2 	for a from 1 to n
3 		for b from 1 to n
4 			for c from 1 to n
5 				for d from 1 to n
6 					if a^3 + b^3 == c^3 + d^3
7 						print a, b, c, d
8 						break // break out of d's loop
</code></pre>
<p>这对运行时来说并不是一个意义的修改，我们的算法仍然是 O(N^4)，但是这仍然是一个很好的快速修复方法。</p>
<p>还有其他不必要的东西吗？有的。如果每个 (a, b, c) 只有一个有效的 d 值，那么我们就可以对其进行计算。这只是简单的数学运算：d = <sup>3</sup>√(a^3 + b^3 - C^3)。</p>
<pre><code>1 	n = 1000
2 		for a from 1 to n
3 			for b from 1 to n
4 				for c from 1 to n
5 					d = pow(a^3 + b^3 - c^3, 1/3) // Will round to int
6 					if a^3 + b^3 == c^3 + d^3 // Validate that the value works
7 						print a, b, c, d
</code></pre>
<p>第 6 行的 if 语句很重要。第 5 行总是会找到 d 的值，但是我们需要检查它是否是正确的整数值。</p>
<p>这将使我们的运行时间从 O(N^4) 减少到 O(N^3)。</p>
<h4 id="重复的工作"><a class="header" href="#重复的工作">重复的工作</a></h4>
<p>使用与上面相同的问题和蛮力算法，让我们这次查找重复的工作。</p>
<p>该算法通过遍历所有 (a, b) 对，然后搜索所有 (c, d) 对来以查找与该 (a, b) 对是否匹配。</p>
<p>为什么我们要为每一对 (a, b) 计算所有 (c, d) 对？我们应该只创建一次 (c, d) 对的列表。然后，当我们有一个 (a, b) 对时，在 (c, d) 列表中查找匹配项。我们可以通过将每个 (c, d) 对插入到哈希表中来快速定位匹配项，哈希表将从总和映射到该对（或者更确切地说，映射到具有该总和的对列表）。</p>
<pre><code>1 	n = 1000
2 	for c from 1 to n
3 		for d from 1 to n
4 			result = c^3 + d^3
5 			append (c, d) to list at value map[result]
6 	for a from 1 to n
7 		for b from 1 to n
8 			result = a^3 + b^3
9 			list= map.get(result) 
10 			for each pair in list
11 				print a, b, pair
</code></pre>
<p>实际上，一旦我们有了所有 (c, d) 对的映射，我们就可以直接使用它。我们不需要生成 (a, b) 对。每个 (a, b) 都已经在 map 上了。</p>
<pre><code>1 	n = 1000
2 	for c from 1 to n
3 		for d from 1 to n
4 			result = c^3 + d^3
5 			append (c, d) to list at value map[result]
6 
7 	for each result, list in map 
8 		for each pair1 in list
9 			for each pair2 in list
10 				print pair1, pair2
</code></pre>
<p>这将使我们的运行时间达到 O(N^2)。</p>
<h3 id="优化和解决技巧-2diy-do-it-yourself"><a class="header" href="#优化和解决技巧-2diy-do-it-yourself">优化和解决技巧 #2：DIY (Do It Yourself)</a></h3>
<p>当你第一次听说如何在有序数组中查找元素（在学习二分查找之前），你可能不会立即想到，“啊哈!
我们将把目标元素与中点进行比较，然后在适当的那一半上进行递归。”</p>
<p>然而，你可以给一个没有计算机科学知识的人一堆按字母顺序排列的学生论文，他们很可能会执行类似二进制搜索的方法来查找学生论文。他们可能会说，“天哪，Peter Smith？他会在最底层的某个地方。”他们会在中间（大约）随机选择一篇论文，把名字和 “Peter Smith” 相比较，然后在剩下的论文上继续这个过程。虽然他们不懂二分查找，但他们凭直觉同样“搞得定（get it）”。</p>
<p>我们的大脑就像这样有趣。如果在其中加上“设计算法”这句话，人们常常会感到没有头绪。但是给人们一个实际的例子——无论是关于数据的（例如，数组），还是关于现实生活中存在的（例如，一堆论文）——他们的直觉会给他们一个非常好的算法。</p>
<p>我见过无数次这样的候选人。他们在使用计算机算法是进度非常慢，但是当被要求手动解决相同的问题时，他们立即可以很快地完成工作。（从某种意义上说，这并不奇怪。对计算机来说很慢的东西，用手通常也很慢，为什么还要花费额外的精力呢？）</p>
<p>因此，当你遇到问题时，请尝试通过一个真实的例子来直观地解决它。通常，更大的例子会更容易。</p>
<blockquote>
<p>示例：给定一个较小的字符串 s 和一个较大的字符串 b，设计一种算法来找出较短字符串在较长字符串内的所有排列。打印每个排列的位置。</p>
</blockquote>
<p>考虑一下如何解决这个问题，注意排列是字符串的重新排列，因此 s 中的字符可以按 b 中的任何顺序出现，但是它们必须是连续的（不能被其他字符分开）。</p>
<p>如果你和大多数候选人一样，你可能会想到：生成 s 的所有排列，然后在 b 中查找每个排列。因为有 <code>S!</code> 个排列，所以这将花费 O(S!* B) 时间，其中 S 是 s 的长度，B 是 b 的长度。</p>
<p>这是可行的，但它是一个非常慢的算法。它实际上比指数算法更糟糕。如果 s 有 14 个字符，则会有超过 870 亿个排列。再加一个字符到 s 中，排列的数量又会增加到之前的15倍。哎哟！</p>
<p>采用另一种方法，你可以相当轻松地开发出不错的算法。给自己一个大例子，比如这个：</p>
<pre><code>s: abbc
b: cbabadcbbabbcbabaabccbabc
</code></pre>
<p>b 中 s 的排列在哪里？不要考虑你通过什么方式来找，只需找到它们。甚至一个 12 岁的孩子都能做到！</p>
<p>（不，真的，去找到它们。我会等你！）</p>
<p>我在每个排列下面都画了下划线。</p>
<div><img src="img/VII_3.png"/></div>
<p>你找到这些了吗？ 怎么找的？</p>
<p>很少有人——甚至是那些较早提出 O(S! * B) 算法的人——实际上都会生成 <code>abbc</code> 的所有排列，以在 b 中定位这些排列。几乎每个人都采用以下两种（非常相似的）方法之一：</p>
<ol start="3">
<li>遍历b，观察4个字符的滑动窗口（因为s的长度为4），检查每个窗口是否是 s 的排列。</li>
<li>遍历b。每次在看到 s 中的一个字符时，检查后面四个（s的长度）字符是否是 s 的排列。</li>
</ol>
<p>根据“这是否是一个排列”部分具体实现的不同，你可能会得到 O(B * S)、O(B * S log S) 或O(B * S^2) 的运行时。这些都不是最优的算法（有一个 O(B) 的算法），但它比我们之前的算法要好得多。</p>
<p>当你解决问题的时候，试试这个方法。使用一个不错的、大的、直观的例子——手动地，也就是针对特定的例子来解决它。然后，再认真思考你是如何解决的。逆向工程你自己的方法。</p>
<p>要特别注意你直觉上或自动做出的任何“优化”。例如，当你处理这个问题时，你可能跳过了包含 “d” 的滑动窗口，因为 “d” 不在 <code>abbc</code> 中。这是你的大脑做出的优化，你至少应该在你的算法中意识到这一点。</p>
<h3 id="优化和解决技巧-3简化和推广"><a class="header" href="#优化和解决技巧-3简化和推广">优化和解决技巧 #3：简化和推广</a></h3>
<p>通过简化和推广，我们实现了一个多步骤的方法。首先，我们简化或调整一些约束，例如数据类型。然后，我们解决这个新的简化版本的问题。最后，一旦我们有了一个简化问题的算法，我们就试着将其改编为适用于更复杂情况的版本。</p>
<blockquote>
<p>示例：可以通过从一本杂志上剪下几个单词组成一个新句子的方式拼凑出一封勒索信。你如何确定是否可以从给定的杂志（字符串）中拼成一封勒索信（表示为字符串）？</p>
</blockquote>
<p>为了简化问题，我们可以对其进行修改，改成我们可以从杂志上剪下字符，而不一定必须是完整的单词。</p>
<p>我们可以通过简单地创建一个数组并计算字符数来解决简化的勒索信问题。数组中的每一位对应一个字符。首先，我们数一数勒索信中每个字符出现的次数，然后我们遍历杂志，查看是否拥有所有这些字符。</p>
<p>当我们推广这个算法时，我们做的事情非常相似。这一次，我们不是创建一个字符计数的数组，而是创建一个哈希表，从一个单词映射到其频率。</p>
<h3 id="优化和解决技巧-4基本用例和构建"><a class="header" href="#优化和解决技巧-4基本用例和构建">优化和解决技巧 #4：基本用例和构建</a></h3>
<p>使用基本案例和构建，我们首先针对基本用例例（例如，n = 1）解决问题，然后尝试从那里构建。当我们遇到更复杂/有趣的情况（通常为 n = 3 或 n = 4）时，我们尝试使用先前的解决方案来构建。</p>
<blockquote>
<p>示例：设计一种算法来打印字符串的所有排列。为简单起见，假设所有字符都是唯一的。</p>
</blockquote>
<p>考虑一个测试字符串 <code>abcdefg</code>。</p>
<pre><code>Case "a" --&gt; {"a"}
Case "ab" --&gt; {"ab", "ba"} 
Case "abc" --&gt; ?
</code></pre>
<p>这是第一个“有趣”的案例。如果我们有 P ("ab") 的答案，我们如何生成 P ("abc")？额，新加的字母是 c，所以我们可以在所有可能的位置插入 c。那就是：</p>
<pre><code>P("abc") = insert "c" into all locations of all strings in P("ab")
P("abc") = insert "c" into all locations of all strings in {"ab","ba"}
P("abc") = merge({"cab", "acb", "abc"}, {"cba", "bca", bac"})
P("abc") = {"cab", "acb", "abc", "cba", "bca", bac"}
</code></pre>
<p>现在我们了解了这个模式，可以开发一个通用的递归算法。我们要生成字符串 S1 ... Sn 的所有排列，可以先“切掉”最后一个字符，并生成S1 ... Sn-1的所有排列。一旦我们有了 S1 ... Sn-1 的所有排列的列表，便可以遍历该列表。对于其中的每个字符串，我们将 Sn 插入到字符串的每个位置。</p>
<p>基本案例和构建算法通常会变成自然的递归算法。</p>
<h3 id="优化和解决技巧-5数据结构头脑风暴"><a class="header" href="#优化和解决技巧-5数据结构头脑风暴">优化和解决技巧 #5：数据结构头脑风暴</a></h3>
<p>这种方法当然是笨拙的，但通常是有效的。我们可以简单地遍历数据结构列表并尝试应用每个结构。这种方法是有用的，因为一旦我们想到使用树，解决问题就变得很简单了。</p>
<blockquote>
<p>示例：数字随机生成，并存储到一个（扩展的）数组中。你将如何跟踪中位数？</p>
</blockquote>
<p>我们的数据结构头脑风暴可能是这样的：</p>
<ul>
<li>
<p>链表？可能不会。链表在访问和排序数字方面做得不是很好。</p>
</li>
<li>
<p>数组？可能，但你已经有一个数组了。你能以某种方式保持元素有序吗？这成本可能是很高的。我们先不谈这个，如果需要的话再谈。</p>
</li>
<li>
<p>二叉树？这是可能的，因为二叉树在排序方面做得相当好。事实上，如果二叉搜索树是完全平衡的，那么顶部可能是中位数。但是要注意，如果元素个数是偶数，中位数实际上是中间两个元素的平均值。中间的两个元素不能同时在顶部。这可能是一个可行的算法，但让我们先记下来。</p>
</li>
<li>
<p>堆？ 堆真的很擅长基本排序并跟踪最大和最小。这实际上很有趣——如果你有两个堆，则可以跟踪元素的较大一半和较小一半。较大的一半保留在最小堆中，以便较大的一半中的最小元素位于根。较小的一半保留在最大堆中，使得较小的一半的最大元素位于根。现在，有了这些数据结构，在根处就有了潜在的中位数元素。如果堆的大小不再相同，你可以通过从一个堆中取出一个元素并将其推到另一个堆中来快速“重新平衡”堆。</p>
</li>
</ul>
<p>请注意，你做的问题越多，对要应用哪种数据结构的直觉就越发达。你还会培养出一种更敏锐的直觉，知道哪一种方法最有用。</p>
<h3 id="最佳可能的运行时-bcrbest-conceivable-runtime"><a class="header" href="#最佳可能的运行时-bcrbest-conceivable-runtime">最佳可能的运行时 (BCR，Best Conceivable Runtime)</a></h3>
<p>考虑最佳可行的运行时可以为某些问题提供有用的提示。</p>
<p>最好的运行时，从字面上来说，就是你能想到的解决问题的最好的运行时。你可以很容易地证明你没有办法击败BCR。</p>
<p>例如，假设你想要计算两个数组（长度为 A 和 B）共有的元素数量。你马上就知道你不能在比 O(A + B) 更好的时间内完成，因为你必须“触摸”每个数组中的每个元素。O(A + B) 就是 BCR。</p>
<p>或者，假设你想打印一个数组中的所有值对。你知道你不能在比 O(N^2) 更好的时间内完成，因为有 N^2 对要打印。</p>
<p>不过要小心！假设你的面试官要求你在一个数组中找出所有总和为 k 的对（假设所有的元素都不同）。一些尚未完全掌握 BCR 概念的候选人会说 BCR 为 O(N^2)，因为你必须查看 N^2 对。</p>
<p>那是不对的。仅仅因为你希望所有对都具有特定的总和，并不意味着你必须查看所有对。事实上，你没有。</p>
<blockquote>
<p>最佳可能的运行时（Best Conceivable Runtime）和最佳情况运行时（Best Case Runtime）之间有什么关系？ 没有任何联系！ 最佳可能运行时是针对一个问题的，很大程度上取决于输入和输出。它与特定算法没有直接的联系。实际上，如果你通过考虑思考你的算法做了什么，来计算最佳可能的运行时，你可能做错了什么。最佳情况运行时是针对特定算法的（并且通常是一个无用的值）。</p>
</blockquote>
<p>请注意，最佳可能的运行时不一定是可实现的，它只是说你不能比它做得更好。</p>
<h4 id="一个如何使用bcr的例子"><a class="header" href="#一个如何使用bcr的例子">一个如何使用BCR的例子</a></h4>
<p>问题：给定两个已排序的数组，找出它们共有的元素个数。数组的长度相同，每个数组中所有的元素都不同。</p>
<p>让我们从一个很好的例子开始。我们将在共同的元素下划线。</p>
<p>A: 13 27 <u><em>35 40</em></u> 49 <u><em>55</em></u> 59
B: 17 <u><em>35</em></u> 39 <u><em>40 55</em></u> 58 60</p>
<p>这个问题的一个蛮力算法是从 A 中的每个元素开始，在 B 中搜索它。这需要 O(N^2) 的时间，因为对于 A 的 N 个元素中每个来说，我们都需要在 B 中进行 O(N) 的搜索。</p>
<p>BCR 是 O(N)，因为我们知道每个元素至少要查看一次，并且总共有 2N 个元素。（如果我们跳过一个元素，那么该元素的值可能会改变结果。例如，如果我们从未查看过 B 中的最后一个值，那么最后的 60 也可以是 59。）</p>
<p>让我们考虑一下我们现在的位置。我们有一个 O(N^2) 算法，我们想要做得更好——可能地，但不一定，我们希望能和 O(N) 一样快。</p>
<pre><code>Brute Force:       O(N^2) 
Optimal Algorithm: ? 
BCR:               O(N)
</code></pre>
<p>O(N^2) 和 O(N) 之间是什么？很多东西。实际上是无限的东西。理论上我们可以得到一个 O(N log(log(log(log(N)))) 的算法。然而，无论是在采访中还是在现实生活中，这个运行时都不会经常出现。</p>
<blockquote>
<p>在面试时请记住这一点，因为这会让很多人感到困惑。是的，运行时通常是O(log N)、O(N)、O(N log N)、O(N^2) 或 O(2^N)。但是，你不应仅仅纯粹通过淘汰的办法就假定某样东西有一个特定的运行时间。事实上，当你对运行时感到困惑时，你就需要猜测一下——这些时候你很可能会得到一个不太明显和不太常见的运行时。可能运行时间是 O(N^2 K)，其中 N 是数组的大小，K 是对的数量。推导出来，不要猜测。</p>
</blockquote>
<p>最有可能的是，我们正朝着 O(N) 算法或 O(N log N) 算法的方向前进。这告诉了我们什么？</p>
<p>如果我们把当前算法的运行时间想象成 O(N x N)，那么得到 O(N) 或 O(N x log N) 可能意味着将方程中的第二个O(N) 减少到 O(1) 或 O(log N)。</p>
<blockquote>
<p>这是 BCR 发挥作用的一种方式。我们可以使用运行时来获得需要减少的内容的“提示”。</p>
</blockquote>
<p>第二个 O(N) 来自搜索。数组已排序。我们能在比O（N）更快时间下地搜索一个排序数组吗？</p>
<p>为什么不，我们能。我们可以使用二分查找在 O(log N) 时间内找到排序数组中的一个元素。</p>
<p>我们现在有一个改进的算法：O(N log N)</p>
<pre><code>Brute Force:        O(N^2) 
Improved Algorithm: O(N log N) 
Optimal Algorithm:  ?
BCR:                O(N)
</code></pre>
<p>我们能做得更好吗？做得更好意味着将 O(log N) 减少到 O(1)。</p>
<p>一般来说，我们不能在比 O(log N) 更快的时间内搜索一个数组——甚至是一个排序的数组。但是，这不是一般情况。我们会一遍又一遍地进行搜索。</p>
<p>BCR 告诉我们，我们永远不会有比 O(N) 更快的算法。因此，我们在 O(N) 时间内做的任何工作都是“免费的（freebie）”——它不会影响我们的运行时。</p>
<p>重新阅读第 64 页的优化技巧列表。有什么可以帮助我们的吗？</p>
<p>其中一个建议是预先计算或进行前期工作。我们在 O(N) 时间里做的任何前期工作都是免费的。它不会影响我们的运行时间。</p>
<blockquote>
<p>这是 BCR 可以发挥作用的另一个地方。任何小于或等于 BCR 的工作都是“免费的（free）”，因为它不会影响你的运行时。你可能想要最终消除它，但这并不是当前的首要任务。</p>
</blockquote>
<p>我们的重点仍然是将搜索从 O(log N) 减少到 O(1)。任何小于 O(N) 的预计算都是“免费的”。</p>
<p>在这种情况下，我们可以把 B 中的所有内容都放到哈希表中。这将花费 O(N) 时间。然后，我们只需遍历 A 并查找哈希表中的每个元素。这个查找（或搜索）是 O(1) 的，所以我们的运行时是 O(N)。</p>
<p>假设我们的面试官问了一个让我们畏缩的问题：我们能做得更好吗？</p>
<p>不，不是在运行时方面。我们已经实现了尽可能快的运行时间，因此我们无法进一步优化 big O time。但是我们可以优化空间复杂度。</p>
<p>事实上，即使没有面试官的提示，我们也应该对我们的算法有一个问号。如果数据没有排序，我们将获得完全相同的运行时。那么为什么面试官会给我们排序的数组呢？这并非闻所未闻，但这有点奇怪。</p>
<p>让我们回到我们的例子。</p>
<p>A: 13 27 <u><em>35 40</em></u> 49 <u><em>55</em></u> 59
B: 17 <u><em>35</em></u> 39 <u><em>40 55</em></u> 58 60</p>
<p>我们现在正在寻找一种算法，可以：</p>
<ul>
<li>
<p>在 O(1) 空间中操作（可能）。我们已经有了一个具有最佳运行时的 O(N) 空间算法。如果我们想使用更少的额外空间，则可能意味着没有额外的空间。因此，我们需要删除哈希表。</p>
</li>
<li>
<p>在 O(N) 时间内操作（可能）。我们可能想要至少匹配当前最佳的运行时，我们知道我们无法超越它。</p>
</li>
<li>
<p>使用数组已排序的事实。</p>
</li>
</ul>
<p>我们最好的不用额外空间的算法是二分查找。我们来优化一下。我们可以试着审视一下该算法。</p>
<pre><code>1. Do a binary search in B for A[0] = 13. Not found.
2. Do a binary search in B for A[1] = 27. Not found.
3. Do a binary search in B for A[2] = 35. Found at B[1].
4. Do a binary search in B for A[3] = 40. Found at B[5].
5. Do a binary search in B for A[4] = 49. Not found.
6. ...
</code></pre>
<p>考虑一下 BUD。瓶颈在于搜索。是否有不必要或重复的内容？</p>
<p>执行<code>A[3] = 40</code> 时不必搜索整个 B。我们知道我们刚刚在 B[1] 发现 35，所以 40 肯定不会在 35 之前。</p>
<p>每个二分查找应该从最后一个停止的地方开始。</p>
<p>事实上，我们现在根本不需要做二分查找。我们可以做一个线性搜索。只要 B 中的线性搜索是在最后一个结束的地方继续，我们就知道我们将在线性时间内进行操作。</p>
<pre><code>1. Do a linear search in B for A[0] = 13. Start at B[0] = 17. Stop at B[0] = 17. Not found.
2. Do a linear search in B for A[1] = 27. Start at B[0] = 17. Stop at B[1] = 35. Not found.
3. Do a linear search in B for A[2] = 35. Start at B[1] = 35. Stop at B[1] = 35. Found.
4. Do a linear search in B for A[3] = 40. Start at B[2] = 39. Stop at B[3] = 40. Found.
5. Do a linear search in B for A[4] = 49. Start at B[3] = 40. Stop at B[4] = 55. Found.
6. ...
</code></pre>
<p>这个算法非常类似于合并两个排序的数组。它在 O(N) 时间和 O(1) 空间中运行。</p>
<p>我们现在已经到达了 BCR，并且空间很小。我们知道我们不能做得更好。</p>
<blockquote>
<p>这是我们使用 BCR 的另一种方式。如果你已经到达 BCR 并且只有 O(1) 的额外空间，则说明你无法再优化 big O time 或空间了。</p>
</blockquote>
<p>最好想象的运行时不是一个“真正的”算法概念，因为你在算法教科书中找不到它。但是我个人发现，当我自己解决问题以及指导人们解决问题时，它非常有用。</p>
<p>如果你很难理解它，确保你首先理解 big O time（第38页）。你需要掌握它。一旦你掌握了，计算出一个问题的 BCR 只需要几秒钟。</p>
<h3 id="处理错误答案"><a class="header" href="#处理错误答案">处理错误答案</a></h3>
<p>最普遍也是最危险的谣言之一是，候选人需要正确回答每一个问题。这不完全是对的。</p>
<p>第一，对面试问题的回答不应该被视为“正确的”或“不正确的”。当我评估一个人在面试中的表现时，我从来不会想，“他们有多少问题是正确的？”它不是一个二元的评判。而是更关注他们的最终解决方案有多理想，得出该解决方案他们花了多长时间，他们需要多少帮助，以及他们代码的整洁程度。这里有一系列的评判因素。</p>
<p>第二，你的表现是通过与其他候选人的比较来评估的。例如，如果你在 15 分钟内给出了一个问题的最优解，而另一个人在 5 分钟内解决了一个简单得多的问题，那么这个人的表现是否比你更好？也许是，也许不是。如果你被问到非常简单的问题，那么可能会期望你很快地得到最优解。但是，如果问题很难解决，则允许你的回答里出现一些错误。</p>
<p>第三，许多（可能是大多数的）问题都太难了，以至于即使是一个很强的候选人也无法立即得出最优算法。我倾向于提出这样的问题，它们通常需要很强的候选人花 20 到 30 分钟来解决。</p>
<p>我在 Google 在评估成千上万的招聘信息（hiring packets）时，只见过一位候选人的面试是“完美无缺（flawless）”的。其他所有人，包括数百名获得 offer 的人，都犯过错误。</p>
<h3 id="以前听过问题"><a class="header" href="#以前听过问题">以前听过问题</a></h3>
<p>如果你以前听到过这个问题，请向面试官承认。面试官问你这些问题是为了评估你解决问题的能力。如果你已经知道了这个问题，那么你就没有给他们评价你的机会。</p>
<p>另外，如果你不告诉面试官你知道这个问题，面试官可能会觉得你很不诚实。（反过来说，如果你真的透露了这一点，你会得到很高的诚实分。）</p>
<h3 id="面试的完美语言"><a class="header" href="#面试的完美语言">面试的“完美”语言</a></h3>
<p>在许多顶级公司，面试官对语言并不挑剔。他们更感兴趣的是你如何解决问题，而不是你是否知道一门特定的语言。</p>
<p>不过，也有其他一些公司对语言会更加关注，并且有兴趣了解你使用某种特定语言编写代码的能力。</p>
<p>如果可以选择一种语言，那么你应该选择最适合自己的语言。</p>
<p>也就是说，如果你掌握几种不错的语言，则应牢记以下几点：</p>
<h4 id="流行"><a class="header" href="#流行">流行</a></h4>
<p>这不是必需的，但对你的面试官来说，了解你所使用的语言是最理想的情况。因此，更广为人知的语言会更好。</p>
<h4 id="语言可读性"><a class="header" href="#语言可读性">语言可读性</a></h4>
<p>即使你的面试官不懂你的编程语言，他们也应该能够基本理解。一些语言与其他语言很相似，因此理所当然地它们比其他不具此特征的语言更具可读性。</p>
<p>例如，Java 很容易让人理解，即使他们没有使用过它。因为大多数人都使用过类似 Java 的语法，比如 C 和 C++。</p>
<p>但是，诸如 Scala 或 Objective C 之类的语言具有完全不同的语法。</p>
<h4 id="潜在问题"><a class="header" href="#潜在问题">潜在问题</a></h4>
<p>某些语言只会使你面临潜在的问题。例如，使用 C++ 意味着，除了代码中可能存在的所有常见 bug 之外，还可能存在内存管理和指针问题。</p>
<h4 id="冗长性"><a class="header" href="#冗长性">冗长性</a></h4>
<p>有些语言比其他语言更冗长。例如，与 Python 相比，Java 是一种相当冗长的语言。只需比较以下代码段。</p>
<p>Python:</p>
<pre><code class="language-python">1 	dict {"left": 1, "right": 2, "top": 3, "bottom": 4};
</code></pre>
<p>Java:</p>
<pre><code class="language-java">1 	HashMap&lt;String, Integer&gt; dict = new HashMap&lt;String, Integer&gt;().
2 	dict.put("left", 1);
3 	dict.put("right", 2);
4 	diet.put("top", 3);
5 	dict.put("bottom", 4);
</code></pre>
<p>但是，可以通过缩写代码来减少 Java 的一些冗长性。我可以想象一个候选人在白板上写这样的东西：</p>
<pre><code class="language-Java">1 	HM&lt;S, I&gt; dict = new HM&lt;S, I&gt;().
2 	dict.put("left", 1);
3 	... "right", 2
4 	... "top", 3
5 	... "bottom", 4
</code></pre>
<p>候选人可能需要解释这些缩写，但大多数面试官一般都不会介意。</p>
<h4 id="易用性"><a class="header" href="#易用性">易用性</a></h4>
<p>在某些语言中，某些操作比其他语言更容易。例如，在 Python 中，你可以轻松地从一个函数返回多个值。而在  Java 中，相同的操作将需要一个新类。这对于某些问题可能很方便。</p>
<p>但是，与上述类似，可以通过简化代码或假定你实际上没有的方法来缓解这种情况。例如，如果一种语言提供了转置矩阵的函数，而另一种语言没有，这并不一定会使第一种语言能更好地编码（针对需要这种功能的问题）。你可以假设其他语言也有类似的方法。</p>
<h3 id="好的代码是什么样的"><a class="header" href="#好的代码是什么样的">好的代码是什么样的</a></h3>
<p>你现在可能已经知道，老板希望看到你编写出“良好、干净”的代码。但是，这到底意味着什么，在面试中又该如何体现出来呢？</p>
<p>一般来说，好的代码具有以下特性：</p>
<ul>
<li>
<p><strong>正确</strong>：代码应该在所有预期的和意外的输入上正确运行。</p>
</li>
<li>
<p><strong>高效</strong>：代码在时间和空间上都应尽可能高效地运行。这种“效率”包括渐近（big O）效率和实际的、现实生活中的效率。也就是说，当你计算 big O time 时，一个常数因子可能会被去掉，但是在现实生活中，它可能非常重要。</p>
</li>
<li>
<p><strong>简单</strong>：如果你有能力在 10 行而不是 100 行中完成功能，那你就应该这样做。开发人员应该尽可能快地编写代码。</p>
</li>
<li>
<p><strong>可读</strong>：另一个开发人员应该能够阅读你的代码，并了解其功能以及如何执行。可读代码不只是在必要的地方带有注释，更重要的是它以易于理解的方式实现了功能。这意味着你执行大量复杂的位移位（bit shifting）的高级代码不一定是好的代码。</p>
</li>
<li>
<p><strong>可维护</strong>：代码应在产品的生命周期内合理地适应更改，并且应易于其他开发人员以及最初的开发人员进行维护。</p>
</li>
</ul>
<p>兼顾这些方面需要一种平衡的艺术。例如，通常建议牺牲一定程度的效率来提高代码的可维护性，反之亦然。</p>
<p>在面试编写代码时，你应该考虑这些因素。代码的以下方面以更具体的方式演示了前面的列表。</p>
<h4 id="大量使用数据结构"><a class="header" href="#大量使用数据结构">大量使用数据结构</a></h4>
<p>假设你被要求写一个函数来使两个简单的数学表达式相加，它们的形式为 <code>Ax^a + Bx^b + ... </code>（其中系数和指数可以是任何正或负实数）。也就是说，表达式是一组项的序列，其中每个项只是一个常数乘以一个指数。面试官还补充说，她不需要你进行字符串解析，所以你可以使用任何想要的数据结构来保存表达式。</p>
<p>你可以通过多种不同的方法来实现它。</p>
<p><em>糟糕的实现</em></p>
<p>一个糟糕的实现是将表达式存储为一个 double 数组，其中第 k 个元素对应于表达式中 x^k 项的系数。这种结构是有问题的，因为它不能支持带有负或非整数指数的表达式。它还将需要一个包含 1000 个元素的数组来存储表达式 x^1000。</p>
<pre><code class="language-java">1 	int[] sum(double[] expr1, double[] expr2) {
2 		...
3 	}
</code></pre>
<p><em>不那么糟糕的实现</em></p>
<p>一个稍微不那么糟糕的实现是将表达式存储为两个数组（系数和指数，coefficients and exponents）的集合。在这种方法下，表达式的项以任意顺序存储，但“匹配”的表达式的第 i 项表示为 <code> coefficients[i] * X^ exponents[i]</code>。</p>
<p>在该实现方式下，如果系数 [p] = k，指数 [p] = m，则第 p 项就是 kx ^ m。尽管它没有与早期解决方案相同的局限性，但仍然非常混乱。仅仅因为一个表达式，你就必须追踪两个数组。且如果数组的长度不同，表达式可能会有“未定义”的值。而且返回表达式很麻烦，因为你需要返回两个数组。</p>
<pre><code class="language-java">1 	??? sum(double[] coeffs1, double[] expon1, double[] coeffs2, double[] expon2) {
2 		...
3 	}
</code></pre>
<p><em>良好的实现</em></p>
<p>此问题一个良好的实现是为表达式设计自己的数据结构。</p>
<pre><code class="language-java">1 	class ExprTerm {
2 		double coefficient;
3 		double exponent;
4 	}
5
6 	ExprTerm[] sum(ExprTerm[] expr1, ExprTerm[] expr2) { 
7 		...
8 	}
</code></pre>
<p>有些人可能（或者曾经）认为这是“过度优化”。也许是这样，也许不是。无论你是否认为这是过度优化，上面的代码都表明你考虑了如何设计代码，而不是以最快的方式将一些东西拼凑在一起。</p>
<h4 id="适当的代码重用"><a class="header" href="#适当的代码重用">适当的代码重用</a></h4>
<p>假设你被要求编写一个函数来检查二进制数（作为字符串传递）的值是否等于一个字符串的十六进制表示形式。</p>
<p>此问题的一个优雅实现利用了代码重用。</p>
<pre><code class="language-java">1 	boolean compareBinToHex(String binary, String hex) {
2 		int n1 = convertFromBase(binary, 2);
3 		int n2 = convertFromBase(hex, 16);
4 		if (n1 &lt; 0 || n2 &lt; 0) { 
5 			return false;
6 		}
7 		return n1 == n2;
8 	}
9
10 	int convertFromBase(String number, int base) {
11 		if (base &lt; 2 || (base &gt; 10 &amp;&amp; base != 16)) return -1; 
12 		int value = 0;
13 		for (int i = number.length() - 1; i &gt;= 0; i--) {
14 			int digit = digitToValue(number.charAt(i));
15 			if (digit &lt; 0 || digit &gt;= base) { 
16 				return -1;
17 			}
18 			int exp = number.length() - 1 - i;
19 			value += digit * Math.pow(base, exp);
20 		}
21 		return value;
22 	}
23
24 	int digitToValue(char c) { ... }
</code></pre>
<p>我们本可以实现单独的代码来转换二进制数和十六进制码，但这只会使我们的代码更难于编写和维护。相反，我们通过编写一个 convertFromBase 方法和一个 digitToValue 方法实现了代码重用。</p>
<h4 id="模块化"><a class="header" href="#模块化">模块化</a></h4>
<p>编写模块化代码意味着将独立的代码块分离到它们自己的方法中。这这有助于使代码更具可维护性、可读性和可测试性。</p>
<p>假设你正在编写代码以交换整数数组中的最小和最大的元素。你可以使用以下面这种方法来实现所有功能：</p>
<pre><code class="language-java">1 	void swapMinMax(int[] array) {
2 		int max index = 0;
3 		for (int i = 1; i &lt; array.length; i++) { 
4 			if (array[i] &gt; array[maxindex]) {
5 				minindex = i;
6 			}
7 		}
8 
9 		int minindex = 0;
10 		for (int i = 1; i &lt; array.length; i++) { 
11 			if (array[i] &lt; array[minindex]) {
12 				maxindex= i;
13 			}
14 		}
15 
16 		int temp = array[minindex];
17 		array[minindex] array[maxindex];
18 		array[maxindex] = temp;
19 }
</code></pre>
<p>或者，你可以以一种更模块化的方式实现，将相对独立的代码块分离到它们自己的方法中。</p>
<pre><code class="language-java">1 	void swapMinMaxBetter(int[] array) {
2 		int minindex = getMinindex(array);
3 		int maxindex = getMaxindex(array);
4 		swap(array, minindex, maxindex);
5 	}
6
7 	int getMinindex(int[] array) { ... }
8 	int getMaxindex(int[] array) { ... }
9 	void swap(int[] array, int m, int n) { ... }
</code></pre>
<p>虽然非模块化代码并不是特别糟糕，但是模块化代码的优点在于它很容易测试，因为每个组件都可以单独验证。随着代码变得越来越复杂，以模块化的方式编写代码变得越来越重要。这将使其更容易阅读和维护。你的面试官希望看到你在面试中展示这些技能。</p>
<h4 id="灵活和健壮"><a class="header" href="#灵活和健壮">灵活和健壮</a></h4>
<p>仅仅因为你的面试官只是要求你编写代码，来检查正常的井字棋盘（tic-tac-toe board）中是否有赢家，并不意味着你必须假定它是 3x3 的棋盘。为什么不以一种更通用的方式来编写代码来实现 NxN 的棋盘呢？</p>
<p>编写灵活的通用代码也意味着使用变量而不是写死（hard-coded）的值，或者使用模板/泛型来解决问题。如果我们可以编写代码来解决更通用的问题，我们就应该这样做。</p>
<p>当然，这是有限制的。如果对于一般情况而言解决方案要复杂得多，并且在目前看来似乎不必要，那么最好只实现简单的、预期的情况。</p>
<h4 id="错误检查"><a class="header" href="#错误检查">错误检查</a></h4>
<p>一个谨慎的程序员的标志是她不会对输入做任何假设。相反，她通过 ASSERT 语句或 if 语句验证输入是否正确。</p>
<p>例如，回想一下前面的代码，它将一个数字从其基数 i（例如，基数 2 或基数 16）表示形式转换为一个整数。</p>
<pre><code class="language-java">1 	int convertToBase(String number, int base) {
2 		if (base &lt; 2 || (base &gt; 10 &amp;&amp; base != 16)) return -1; 
3 		int value = 0;
4 		for (int i = number.length() - 1; i &gt;= 0; i--) {
5 			int digit = digitToValue(number.charAt(i));
6 			if (digit &lt; 0 || digit &gt;= base) { 
7 				return -1;
8 			}
9 			int exp = number.length() - 1 - i;
10 			value =+ digit * Math.pow(base, exp);
11 		}
12 		return value;
13 	}
</code></pre>
<p>在第 2 行中，我们检查基数是否有效（我们假设大于 10 的基数，除 16 之外，没有字符串形式的标准表示形式）。在第 6 行中，我们执行另一个错误检查：确保每个数字都在允许的范围内。</p>
<p>此类检查在生产代码中至关重要，因此在面试代码中也是如此。</p>
<p>当然，编写这些错误检查可能很乏味，并且会在面试中浪费宝贵的时间。重要的是要指出你要写这些检查。如果错误检查不仅仅是一个快速的 If 语句，那么最好在错误检查的地方留出一些空间，并向面试官表明，当你完成其余代码时，你将补充这些错误检查。</p>
<h3 id="不要放弃"><a class="header" href="#不要放弃">不要放弃!</a></h3>
<p>我知道面试问题可能会让人不知所措，但这也是面试官测试的一部分。面对挑战你是迎头而上，还是会因恐惧而退缩？ 重要的是，你要积极主动地直面棘手的问题。毕竟，请记住面试应该是很艰难的。当你遇到一个非常棘手的问题时，你不应该感到惊讶。</p>
<p>表现出对解决棘手问题的兴奋，会让你获得额外的“加分”。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="viii-offer-及其他-1"><a class="header" href="#viii-offer-及其他-1">VIII. Offer 及其他</a></h1>
<p>就在你以为面试后可以放松一下的时候，你却面临着面试后的压力：你应该接受这个 offer 吗？这个 offer 是理想的吗？你如何拒绝一个 offer？最后期限呢？我们将在这里处理其中的一些问题，并详细讨论如何评估一个 offer 以及如何讨价还价（negotiate）。</p>
<h3 id="处理-offer-和拒绝"><a class="header" href="#处理-offer-和拒绝">处理 offer 和拒绝</a></h3>
<p>无论你是接受一个 offer，还是拒绝一个 offer，或者是对被拒绝的结果做出反应，你要做的都是重要的。</p>
<h4 id="offer-最后期限和延期"><a class="header" href="#offer-最后期限和延期">Offer 最后期限和延期</a></h4>
<p>当公司发放 offer 时，几乎总是有一个最后期限。通常最后期限是一到四周。如果你还在等其他公司的回音，你可以要求延期。如果可能的话，公司通常会尽量照顾这种情况。</p>
<h4 id="拒绝一份-offer"><a class="header" href="#拒绝一份-offer">拒绝一份 Offer</a></h4>
<p>即使你现在对在这家公司工作不感兴趣，也可能会在几年后对它感兴趣。（或者，你的联系人有一天可能会跳槽到更令人兴奋的公司。）用良好的措辞拒绝这份 offer 并保持沟通，是对你最有利的。</p>
<p>当你拒绝一份 offer 的时候，请提供一个非冒犯性的、无可争辩的理由。例如，如果你为了一家初创公司而拒绝了一家大公司，则可以解释说，你认为目前创业公司是正确的选择。大公司不可能突然“成为”一家初创公司，所以他们不会对你的理由提出异议。</p>
<h4 id="处理拒绝"><a class="header" href="#处理拒绝">处理拒绝</a></h4>
<p>被拒绝是不幸的，但这并不意味着你不是一个伟大的工程师。很多优秀的工程师表现不佳，要么是因为他们在这类面试中“不会应试”，要么就是因为他们当时很“倒霉”。</p>
<p>幸运的是，大多数公司都明白，这些面试并不完美，致使许多优秀的工程师被拒绝了。由于这个原因，公司往往渴望重新面试以前被拒绝的候选人。一些公司甚至会因其先前的表现，而联系以前的候选人，或加快他们的申请进度。</p>
<p>当你接到这个不幸的电话时，可以以此为契机来重新申请。感谢招聘人员为你抽出时间，向他们解释你很失望，但你理解他们的立场，并询问何时可以重新申请这家公司。</p>
<p>你也可以询问招聘人员的反馈。在大多数情况下，大型科技公司不会提供反馈，但有些公司会。提出这样的问题并没有什么害处：“对于我下次该怎么做，你有什么建议吗？”</p>
<h3 id="评估-offer"><a class="header" href="#评估-offer">评估 offer</a></h3>
<p>恭喜！你获得了 offer！而且，如果你幸运的话，你甚至可能获得了多个 offer。现在，招聘人员的工作就是尽其所能地鼓励你接受这份工作。你怎么知道这家公司是否适合你？ 我们将介绍一些再评估一份 offer 时应考虑的事项。</p>
<h4 id="财务包裹"><a class="header" href="#财务包裹">财务包裹</a></h4>
<p>也许候选人在评估一份 offer 时犯的最大的错误就是太看重薪水。候选人往往太看重这个数字，以至于最终接受了财务上较差的 offer。薪水只是你财务薪酬的一部分。你还应该查看：</p>
<ul>
<li><em>签字费，搬家费，和其他一次性津贴</em>：许多公司提供签字费和/或搬家费。在比较 offer 时，明智的做法是将这笔现金分期为三年（或你预计停留多久）进行计算。</li>
<li><em>生活成本差异</em>：税收和其他生活成本差异会对你的实际收入产生很大影响。例如，硅谷比西雅图贵 30% 以上。</li>
<li><em>年终奖</em>：科技公司的年终奖范围从 3% 到 30% 不等。你的招聘人员可能会向你透露平均年终奖是多少，但如果没有，请咨询在该公司任职的朋友。</li>
<li><em>股票期权和转让</em>：股权薪酬可以构成你年度薪酬的另一大部分。与签字费一样，公司间的股票薪酬也可以通过将其摊销三年，然后将其计入工资来进行比较。</li>
</ul>
<p>不过要记住，你所学到的东西，以及公司如何发展你的职业生涯，对你的长期财务状况的影响往往要比工资大得多。仔细考虑一下你到底有多想把关注点放在眼前的工资上。</p>
<h4 id="职业发展"><a class="header" href="#职业发展">职业发展</a></h4>
<p>当你收到这个 offer 的时候，你可能会很兴奋，但很有可能，几年后，你又会开始考虑再次面试。因此，你现在就考虑这份 offer 将如何影响你的职业道路是很重要的。这意味着要考虑以下问题：</p>
<ul>
<li>公司名称在我的履历表上有多好？</li>
<li>我能学到多少？我能学到相关的东西吗？</li>
<li>晋升计划是什么？开发人员的职业生涯如何发展？</li>
<li>如果我想进入管理层，这家公司是否提供切合实际的计划？</li>
<li>公司或团队正在成长吗？</li>
<li>如果我想离开公司，它是否位于我感兴趣的其他公司附近，或者我需要搬家？</li>
</ul>
<p>最后一点非常重要，通常会被忽视。如果你所在的城市只有几家公司可供选择，那么你的职业选择就会更加有限。选择越少，你就越不可能发现真正的好机会。</p>
<h4 id="公司稳定性"><a class="header" href="#公司稳定性">公司稳定性</a></h4>
<p>在其他条件相同的情况下，稳定当然是一件好事。没有人希望被解雇或下岗。</p>
<p>但是，其他所有条件实际上并不相等。越稳定的公司通常也增长越慢。</p>
<p>你应该对公司稳定性给予多大的重视实际上取决于你和你的价值观。对于某些候选人而言，稳定性不是一个很大的因素。你能很快找到新工作吗？如果是这样，即使公司不稳定，也最好选择快速发展的公司？如果你有工作签证限制，或者只是对自己找到新工作的能力不自信，那么稳定性可能更为重要。</p>
<h4 id="幸福因素"><a class="header" href="#幸福因素">幸福因素</a></h4>
<p>最后同样重要的是，你当然应该考虑自己会多么幸福。以下任何因素均可能会影响该因素：</p>
<ul>
<li><em>产品</em>：许多人会仔细考虑他们正在开发的产品，当然这一点也很重要。然而，对于大多数工程师来说，还有更重要的因素，比如你和谁一起工作。</li>
<li><em>领导和同事</em>：当人们说他们喜欢或讨厌他们的工作时，通常是因为他们的同事和领导。入职前，你见过他们吗？你喜欢和他们交谈吗？</li>
<li><em>企业文化</em>：企业文化与一切息息相关，从决策的制定方式，社交氛围到公司的组织方式。问问你未来的同事，他们会如何描述这种文化。</li>
<li><em>工作时间</em>：询问未来的同事他们通常工作多长时间，并弄清楚这是否符合你的生活方式。但是要记住，在重要的开发截止日期之前的工作时间通常要长得多。</li>
</ul>
<p>另外，请注意，如果你有机会很容易地更换团队（比如你在 Google 和 Facebook），你将有机会找到一个与你非常匹配的团队和产品。</p>
<h3 id="谈判negotiation"><a class="header" href="#谈判negotiation">谈判（Negotiation）</a></h3>
<p>多年前，我报名参加了一个谈判班。第一天，讲师请我们想象一个想买车的场景。经销商 A 以固定的  20,000 美元的价格出售汽车，没有讨价还价的余地。经销商 B 允许我们谈判。（经过谈判后）我们去经销商 B 买车要花多少钱？（快！自己回答！）</p>
<p>该班级平均表示，这辆车要便宜750美元。换句话说，如果只是为了避免一个小时左右的谈判，学生将多支付750美元。毫不奇怪，在一次班级调查中，大多数学生也表示，他们没有就他们的工作机会进行谈判。他们只是接受公司给他们的任何东西。</p>
<p>我们中的许多人可能会同情这种立场。谈判对我们大多数人来说都不好玩。但是，谈判的经济利益通常是值得的。</p>
<p>帮你自己一个忙。去谈判吧。这里有一些提示，可以帮助你入门。</p>
<ol start="3">
<li><em>放手去做（Just Do It）</em>。是的，我知道这很可怕，(几乎)没人喜欢谈判。但这是非常值得的。招聘人员不会因为你的谈判而取消你的 offer，所以你不会有什么损失。如果是大公司的 offer，则尤其如此。你可能不会和你未来的同事进行谈判。</li>
<li><em>有一个可行的备选 offer</em>。基本上，招聘人员与你谈判是因为他们担心你可能不会加入公司。如果你有其他的选择，这将使他们的担忧更加真实。</li>
<li><em>有一个具体的“要求”</em>：要求额外的7000美元的工资比只要求“更多”更有效。毕竟，如果你只是要求更多，招聘人员可以再给你1000美元，从技术上来说，这已经满足了你的愿望。</li>
<li><em>超量（Overshoot）</em>：在谈判中，人们通常不会直接同意你的要求。这是一次有来有回的对话。你的要求需要比你真正希望得到的多一些，因为该公司可能会跟你互相折中达成一致。</li>
<li><em>考虑薪资以外的因素</em>：公司通常更愿意就非薪资部分进行谈判，因为加薪太多可能意味着他们付给你的薪资比你的同事要多。考虑要求更多的股权或更大的签字费。或者，你可以要求公司以现金支付你的搬家费福利，而不必让公司直接支付实际的搬家费账单。对于许多大学生来说，这是一个很好的途径，因为他们实际的搬家费用是相当便宜的。</li>
<li><em>使用你最好的媒介</em>：许多人会建议你仅通过电话进行谈判。在某种程度上，他们是对的，最好通过电话进行谈判。然而，如果你在电话谈判中感到不舒服，可以通过电子邮件来解决。你尝试进行谈判比通过特定的媒介进行谈判更重要。</li>
</ol>
<p>另外，如果你正在与一家大公司进行谈判，则应该知道他们经常为员工设置“级别”，在那里，所有处于特定级别的员工的薪水都差不多。Microsoft 对此有一个特别明确的系统。你可以在自己级别的薪水范围内进行协商，但是要超出该范围，则需要提高级别。如果你正在寻找一个大的提升，你需要说服招聘人员和你未来的团队，你的经验符合这个更高的水平——这是一件困难但可行的事情。</p>
<h3 id="工作中"><a class="header" href="#工作中">工作中</a></h3>
<p>在你的职业道路上导航并不会在面试后就结束。事实上，这才刚刚开始。一旦你真的加入了一家公司，你需要开始考虑你的职业道路。你将从这里走向哪里？你将如何到达那里？</p>
<h4 id="设置一个时间表"><a class="header" href="#设置一个时间表">设置一个时间表</a></h4>
<p>这是一个很常见的故事：你加入了一家公司，你很激动，一切都很好。五年过去了，你还在那里。然后，你意识到过去三年对你的技能或简历没有多大帮助。那为什么在工作两年后你不离开呢？</p>
<p>当你享受你的工作时，很容易陷入舒适圈，而不会意识到自己的事业没有进步。这就是为什么在开始新工作之前应该对你的职业道路有个大体的方向。十年后你想达到什么水平？要达到这个目标需要哪些步骤？另外，每年都要想一下明年的经验会给你带来什么，去年你的职业生涯或技能有什么进步。</p>
<p>通过预先概述你的路径并定期进行检查，可以避免陷入这个自我满足的陷阱。</p>
<h4 id="建立牢固的关系"><a class="header" href="#建立牢固的关系">建立牢固的关系</a></h4>
<p>当你想要选择一份新的工作时，你的人际网络将是至关重要的。毕竟，在线申请是很困难的，个人推荐要好得多，你在这方面能否做好取决于你的人际网络。</p>
<p>在工作中，与你的领导和同事建立牢固的关系。员工离职后，请与他们保持联系。在他们离开几周后，只要一个友好的招呼，就能有助于将你们从工作上的熟人变成生活中的熟人。</p>
<p>同样的方法也适用于你的个人生活。你的朋友，你朋友的朋友，都是有价值的关系。乐于帮助他人，他们将更有可能为你提供帮助。</p>
<h4 id="问问自己想要什么"><a class="header" href="#问问自己想要什么">问问自己想要什么</a></h4>
<p>虽然有些领导可能真的想指引你的职业发展，但其他人会采取一种不干涉的方式。由你来决定适合你职业的挑战。</p>
<p>（合理地）向你的领导坦白你的目标。如果你想承担更多的后端编码项目，请就跟他这样说。如果你想探索更多的领导机会，跟他多讨论一下你如何能做到这一点。</p>
<p>你需要成为自己最好的拥护者，这样你才能根据自己的时间表实现目标。</p>
<h4 id="继续面试"><a class="header" href="#继续面试">继续面试</a></h4>
<p>即使你不积极寻找新工作，也要设定一个每年至少面试一次的目标。这将使你的面试技能保持新鲜，也能让你了解外面有什么样的机会（和薪水）。</p>
<p>如果你收到 offer，你不一定要接受它。它仍然会建立与该公司的联系，以防你以后想要加入。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ix-面试问题-1"><a class="header" href="#ix-面试问题-1">IX. 面试问题</a></h1>
<h3 id="目录-1"><a class="header" href="#目录-1">目录</a></h3>
<p><strong>数据结构</strong></p>
<ul>
<li><a href="Chapter_1_Arrays_and_Strings.html">Chapter 1 I 数组和字符串</a></li>
<li><a href="Chapter_2_Linked_Lists.html">Chapter 2 I 链表</a></li>
<li><a href="Chapter_3_Stacks_and_Queues.html">Chapter 3 I 栈和队列</a></li>
<li><a href="Chapter_4_Trees_and_Graphs.html">Chapter 4 I 树和图</a></li>
</ul>
<p><strong>概念和算法</strong></p>
<ul>
<li><a href="Chapter_5_Bit_Manipulation.html">Chapter 5 I 位操作</a></li>
<li><a href="Chapter_6_Math_and_Logic_Puzzles.html">Chapter 6 I 数学和逻辑难题</a></li>
<li><a href="Chapter_7_Object-Oriented_Design.html">Chapter 7 I 面向对象的设计</a></li>
<li><a href="Chapter_8_Recursion_and_Dynamic_Programming.html">Chapter 8 I 递归和动态规划</a></li>
<li><a href="Chapter_9_System_Design_and_Scalability.html">Chapter 9 I 系统设计和可扩展性</a></li>
<li><a href="Chapter_10_Sorting_and_Searching.html">Chapter 10 I 排序与搜索</a></li>
<li><a href="Chapter_11_Testing.html">Chapter 11 I 测试</a></li>
</ul>
<p><strong>基础知识</strong></p>
<ul>
<li><a href="Chapter_12_C_and_C++.html">Chapter 12 I C 和 C++</a></li>
<li><a href="Chapter_13_Java.html">Chapter 13 I Java</a></li>
<li><a href="Chapter_14_Databases.html">Chapter 14 I 数据库</a></li>
<li><a href="Chapter_15_Threads_and_Locks.html">Chapter 15 I 线程和锁</a></li>
</ul>
<p><strong>附加复习题</strong></p>
<ul>
<li><a href="Chapter_16_Moderate.html">Chapter 16 I 中等</a></li>
<li><a href="Chapter_17_Hard.html">Chapter 17 I 困难</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1--数组和字符串"><a class="header" href="#chapter-1--数组和字符串">Chapter 1 | 数组和字符串</a></h1>
<p>希望本书的所有读者都熟悉数组和字符串，这样我们将不会再用这些细节来烦你。相反，我们将专注于这些数据结构的一些更常见的技术和问题。</p>
<p>请注意，数组问题和字符串问题通常是可以互换的。也就是说，本书使用数组陈述的一个问题可以作为字符串问题来询问，反之亦然。</p>
<h3 id="hash-tables"><a class="header" href="#hash-tables">Hash Tables</a></h3>
<p>Hash table是一种通过键值映射以实现高效查找的数据结构。有很多方法可以实现这一点。在这里，我们将介绍一种简单但常见的实现。</p>
<p>在这个简单的实现中，我们使用一个链表数组和一个 hash code 方法。要插入 key（可以是字符串，也可以是其他任何数据类型）和 value，我们需要执行以下操作：</p>
<ol>
<li>首先，计算 key 的hash code，它通常是 int 或 long 类型的。注意，两个不同的 key 可能具有相同的 hash code，因为能存在无限数量的 key，而 int 类型的个数却是有限的。</li>
<li>然后，将 hash code 映射到数组中的一个 index。这可以通过 <code>hash（key） % array_length</code> 之类的东西来完成。当然，两个不同的 hash code 可以映射到同一个 index。</li>
<li>在这个 index 处，有一个 key 和 value 的链表。将 key 和 value 存储在此 index 处。我们必须使用链表，是因为存在以下的冲突：我们可能遇到两个不同的 key 共用相同 hash code，或者两个不同的 hash code 映射到同一个 index。</li>
</ol>
<p>若要按其 key 来检索对应的 value，你需要重复这个过程。计算 key 的 hash code，再根据 hash code 计算 index。然后，使用这个 key 在链表中搜索 value。</p>
<p>如果冲突的数量非常高，最坏的情况运行时间是 O(N)，其中 N 是 key 的数量。但是，我们通常假设一个好的实现可以将冲突保持在最小，在这种情况下查找时间为 O(1)。</p>
<div align=center><img src="img/ch1_1.png"/></div>
或者，我们可以使用平衡二叉搜索树来实现 hash table。这种方法的查找时间为 O(log N)。这样做的好处是可能占用更少的空间，因为我们不再分配大型数组。我们还可以按顺序遍历 key，这有时很有用。
<h3 id="arraylist--可扩容数组"><a class="header" href="#arraylist--可扩容数组">ArrayList &amp; 可扩容数组</a></h3>
<p>在某些语言中，数组（在本例中通常称为list）是可自动调整大小的。数组或 list 将随着添加数据项而增长。在其他语言中，如 Java，数组是固定长度的。需要创建数组时就定义其大小。</p>
<p>当你需要一个可以动态调整大小的数组类型数据结构时，通常可以选择 Arraylist。Arraylist 是一个根据需要调整自身大小的数组，同时仍然提供 O(1) 访问。一个典型的实现是，当数组已满时，数组的大小会加倍。每次加倍需要 O(n) 时间，但是这种情况很少发生，所以它的平摊插入时间（amortized insertion runtime）仍然是 O(1)。</p>
<pre><code class="language-java">1 	Arraylist&lt;String&gt; merge(String[] words, String[] more) {
2 		Arraylist&lt;String&gt; sentence = new Arraylist&lt;String&gt;();
3 		for (String w : words) sentence.add(w);
4 		for (String w : more) sentence.add(w);
5 		return sentence;
6 	}
</code></pre>
<p>这是面试中必不可少的数据结构。确保你能够适应将要使用的任何语言中的动态调整大小的数组 / list。注意，数据结构的名称以及“调整因子（resizing factor）”（Java中为2）在不同语言中可能会有所不同。</p>
<p><em>为什么平摊插入运行时间是 O(1)?</em></p>
<p>假设你有一个大小为 N 的数组。我们可以倒推计算出每次扩容时需要复制的元素数量。可以看到，当我们将数组增加到 K 个元素时，该数组之前的大小就是这个数字的一半。因此，我们需要复制 K/2 个元素。</p>
<pre><code class="language-markdown">最后一次扩容： n/2 elements to copy
前一次扩容  : n/4 elements to copy
前一次扩容  : n/8 elements to copy
前一次扩容  : n/16 elements to copy
...
第二次扩容  ： 2 elements to copy
第一次扩容  ： 1 element to copy
</code></pre>
<p>因此，插入N个元素的复制总数大致为 N/2 + N/4  + N/8  + ... + 2 + 1，刚好小于 N。</p>
<blockquote>
<p>如果这个数列的总和对你来说不是很直观，那么想象一下：假设你要走一公里的路去商店。你步行 0.5 公里，然后 0.25 公里，然后 0.125 公里，以此类推。你永远不会超过一公里（尽管你会非常接近它）。</p>
</blockquote>
<p>因此，插入N个元素总共的时间复杂度是 O(N)。这样平均每次插入是 O(1)，即便在最坏的情况下某些插入需要 O(N) 时间。</p>
<h3 id="stringbuilder"><a class="header" href="#stringbuilder">StringBuilder</a></h3>
<p>假设你正在拼接一个字符串列表，如下所示。这段代码的运行时间是多少？为简单起见，假设所有字符串都是相同的长度（即长为 x），且字符串的个数为 n。</p>
<pre><code class="language-java">1 	String joinWords(String[] words) {
2 		String sentence = "";
3 		for (String w : words) {
4 			sentence = sentence + w;
5		}
6 		return sentence;
7 	}
</code></pre>
<p>在每次拼接时，都会创建一个新的字符串副本，并逐个字符地复制这两个字符串。第一次迭代需要复制 x 个字符。第二次迭代需要复制 2x 个字符。第三次迭代需要 3x，以此类推。因此总时间是 O(x + 2x + … + nx)。可以简化成 O(xn^2)。</p>
<blockquote>
<p>为什么是 O(xn^2)？因为 1 + 2 + ... + n​ 等于 n(n+1)/2，或写为 O(n^2)。</p>
</blockquote>
<p>StringBuilder 可以帮你避免这个问题。StringBuilder 只是创建一个包含所有字符串的可调整大小的数组，只有在必要时才将它们复制回字符串。</p>
<pre><code class="language-java">1 	String joinWords(String[] words) {
2 		StringBuilder sentence = new StringBuilder();
3 		for (String w : words) {
4 			sentence.append(w);
5		}
6 		return sentence.toString();
7 	}
</code></pre>
<p>学习字符串、数组和通用数据结构的一个很好的练习是实现自己版本的 StringBuilder、HashTable 和 ArrayList。</p>
<p><strong>附加阅读</strong>：Hash Table Collision Resolution (pg 636), Rabin-Karp Substring Search (pg 636).</p>
<hr />
<h3 id="interview-questions-1"><a class="header" href="#interview-questions-1">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>1.1 是否唯一（Is Unique）</strong>：实现一个算法来确定一个字符串中所有字符是否是唯一的。如果不能使用其他数据结构怎么办？</p>
<p><em>提示：#44, #777, #732</em></p>
</li>
<li>
<p><strong>1.2 检查全排列（Check Permutation）</strong>：给定两个字符串，编写一个方法来确定其中一个是否是另一个的全排列。</p>
<p><em>提示：#7, #84, #722, #737</em></p>
</li>
<li>
<p><strong>1.3 URL化（URLify）</strong>：编写一个方法，用 '%20' 替换字符串中的所有空格。你可以假设字符串在末尾有足够的空间来容纳额外的字符，并且给定了字符串的“真实”长度。（注意：如果用 Java 实现，请使用字符数组，以便可以在原来的空间（in place）执行此操作。）</p>
<p>EXAMPLE</p>
<pre><code>Input: "Mr John Smith    ", 13
Output: "Mr%20John%20Smith"
</code></pre>
<p><em>提示：#53, #118</em></p>
</li>
<li>
<p><strong>1.4 回文全排列（Palindrome Permutation）</strong>：给定一个字符串，编写一个函数来检查它是否是回文全排列。回文是指一个前后相同的单词或短语。全排列是字母的重新排列。回文不需要局限于字典中的单词。</p>
<p>EXAMPLE</p>
<pre><code>Input: Tact Coa
Output: True (permutations: "taco cat", "atco eta", etc.)
</code></pre>
<p><em>提示：#106, #121, #134, #136</em></p>
</li>
<li>
<p><strong>1.5 差一步（One Away）</strong>：可以对字符串执行三种类型的编辑：插入字符，删除字符或替换字符。给定两个字符串，编写一个函数来检查它们是否相距一步编辑（或零步编辑）。</p>
<p>EXAMPLE</p>
<pre><code>pale, ple -&gt; true
pales, pale -&gt; true
pale, bale -&gt; true
pale, bake -&gt; false
</code></pre>
<p><em>提示：#23, #97, #130</em></p>
</li>
<li>
<p><strong>1.6 字符串压缩（String Compression）</strong>：实现一种方法，使用重复字符的计数执行基本的字符串压缩。例如，字符串 <code>aabcccccaaa</code> 将变为 <code>a2blc5a3</code>。如果“压缩”后的字符串长度不会变得小于原始字符串的长度，那么你的方法应该返回原始字符串。你可以假设该字符串仅包含大写和小写字母（a ~ z）。</p>
<p><em>提示：#92, #110</em></p>
</li>
<li>
<p><strong>1.7 旋转矩阵（Rotate Matrix）</strong>：给定一个由 <code>NxN</code> 矩阵表示的图像，其中图像中的每个像素为 4 字节，请编写一种将图像旋转 90 度的方法。你能做到吗？</p>
<p><em>提示：#51, #100</em></p>
</li>
<li>
<p><strong>1.8 零矩阵（Zero Matrix）</strong>：编写这样一个算法，如果MxN矩阵中的元素为 0，则使其整个行和列均设置为 0。</p>
<p><em>提示：#17, #74, #702</em></p>
</li>
<li>
<p><strong>1.9 字符串旋转（String Rotation）</strong>：假设你有一个 <code>isSubstring</code> 方法，该方法是检查一个单词是否是另一个单词的子字符串。给定两个字符串 s1 和 s2，编写代码以仅调用一次 <code>isSubstring</code> 来检查 s2 是否是 s1 的旋转（例如，“waterbottle” 是  “erbottlewat” 的旋转）。</p>
<p><em>提示：#34, #88, #704</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：面向对象设计(#7.12)，递归(#8.3)，排序和搜索(#10.9)，C++(#12.11 )，中等问题(#16.8, #16.17, #16.22)，困难问题(#17.4, #17.7, #17.13, #17.22, #17.26)。</p>
<p>提示从第 653 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2--链表"><a class="header" href="#chapter-2--链表">Chapter 2 | 链表</a></h1>
<p>链表是表示节点序列的数据结构。在单链表中，每个节点都指向链表中的下一个节点。双向链表为每个节点提供指向下一个节点和前一个节点的指针。</p>
<p>下图是一个双向链表：</p>
<div align=center><img src="img/ch2_1.png"/></div>
与数组不同，链表不提供对列表中特定 “index” 的固定时间访问。这意味着，如果你希望找到列表中的第 K 个元素，就需要遍历 K 个元素。
<p>链表的好处是可以在固定的时间内从列表头添加和删除项。对于特定的应用程序，这可能很有用。</p>
<h3 id="创建链表"><a class="header" href="#创建链表">创建链表</a></h3>
<p>下面的代码实现了一个非常基本的单链表。</p>
<pre><code class="language-java">1 	class Node {
2 		Node next= null;
3 		int data; 
4
5 		public Node(int d) {
6 			data= d;
7 		}
8
9 		void appendToTail(int d) {
10 			Node end= new Node(d);
11 			Node n = this;
12 			while (n.next != null) {
13 				n = n.next;
14 			}
15 			n.next = end;
16 		}
17 	}
</code></pre>
<p>在这个实现中，我们没有使用 LinkedList 数据结构。我们通过对链表头节点（head Node）的引用访问链表。以这种方式实现链表时，需要小心一点。如果多个对象需要引用链表，而链表的头节点发生了更改，该怎么办？一些对象可能仍然指向旧的头节点。</p>
<p>如果愿意，我们可以实现一个封装了 Node 类的 LinkedList 类。这实际上只有一个成员变量：head Node。这将在很大程度上解决前面所说的问题。</p>
<p>记住，当你在面试中讨论链表时，你必须清楚它是单链表还是双链表。</p>
<h3 id="从单链表中删除节点"><a class="header" href="#从单链表中删除节点">从单链表中删除节点</a></h3>
<p>从链表中删除节点非常简单。给定一个节点 n，我们找到其前一节点 <code>prev</code> 并令 <code>prev.next = n.next</code>。如果实双向链表，我们还必须更新 <code>n.next</code>，令 <code>n.next.prev = n.prev</code>。 要记住的重要事项是（1）检查空指针和（2）根据需要更新头或尾指针。</p>
<p>此外，如果使用C、C++或其他需要开发人员进行内存管理的语言来实现此代码，则应考虑是否需要释放已删除的节点。</p>
<pre><code class="language-java">1 	Node deleteNode(Node head, int d) {
2 		Node n = head;
3
4 		if (n.data == d) {
5 			return head.next; /* moved head */
6 		}
7
8 		while (n.next != null) {
9 			if (n.next.data == d) {
10 				n.next = n.next.next;
11 				return head; /* head didn't change */
12 			}
13 			n = n.next;
14 		}
15 		return head;
16 	}
</code></pre>
<h3 id="runner技术"><a class="header" href="#runner技术">“Runner”技术</a></h3>
<p>“runner”（或第二个指针）技术用于许多链表问题。runner 技术意味着你可以同时使用两个指针遍历链表，其中一个指针位于另一个指针之前。“快”节点可能领先固定的个数，或者它可能在“慢”节点遍历一个节点时跳过多个节点。</p>
<p>例如，假设你有一个链表 a1 -&gt; a2 -&gt; ... -&gt; an -&gt; b1 -&gt; b2 -&gt; ... -&gt; bn，并且你想把它重新排列成 a1 -&gt; b1 -&gt; a2 -&gt; b2 -&gt; ... -&gt; an -&gt; bn。你不知道链表的长度（但是你知道长度是偶数）。</p>
<p>你可以使用一个指针 p1​（快指针），在 ​p2​ 每移动一个元素时 ​p1​ 移动两个元素。当 ​p1 到达链表的末尾时，p2 将位于中点。然后，将 p1 移回到链表头并开始“织入（weaving）”元素。在每次迭代中，p2 选择一个元素并将其插入 p1​ 之后。</p>
<h3 id="递归问题"><a class="header" href="#递归问题">递归问题</a></h3>
<p>许多链表问题依赖于递归。如果在解决链表问题时遇到困难，应该研究递归方法是否可行。这里我们不深入讨论递归，因为后面的一章将专门讨论它。</p>
<p>但是，你应该记住递归算法至少占用 O(n)​ 空间，其中 n 是递归调用的深度。所有递归算法都可以替换成使用迭代实现，尽管它们可能要复杂得多。</p>
<hr />
<h3 id="interview-questions-2"><a class="header" href="#interview-questions-2">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>2.1 删除重复项（Remove Dups）</strong>：编写代码从未排序的链表中删除重复项。</p>
<p>FOLLOW UP</p>
<p>如果不允许使用临时缓冲区，如何解决这个问题?</p>
<p><em>提示：#9, #40</em></p>
</li>
<li>
<p><strong>2.2 返回第 K 到最后（Return Kth to Last）</strong>：实现一个算法，以找到单链表的第 K 个到最后一个元素。</p>
<p><em>提示：#8, #25, #41, #67, #126</em></p>
</li>
<li>
<p><strong>2.3 删除中间节点（Delete Middle Node）</strong>：实现一个算法，以删除单链表的中间节点（即，除了第一个和最后一个节点以外的任何节点，不一定是确切的中间节点），要求仅允许访问该节点。</p>
<p>EXAMPLE</p>
<pre><code>Input: the node c from the linked list a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f
Result: nothing is returned, but the new linked list looks like a-&gt;b-&gt;d-&gt;e-&gt;f
</code></pre>
<p><em>提示：#72</em></p>
</li>
<li>
<p><strong>2.4 分区（Partition）</strong>：编写代码以围绕值 x 对链表进行分区，使所有小于 x 的节点排在所有大于或等于 x 的节点之前。 如果 x 包含在列表中，则 x 的值仅需在小于 x 的元素之后（请参见下文）。 分区元素 x 可以出现在“右分区”中的任何位置； 不需要将它放在左右分区之间。</p>
<p>EXAMPLE</p>
<pre><code>Input: 3 -&gt; 5 -&gt; 8 -&gt; 5 -&gt; 10 -&gt; 2 -&gt; 1 [partition= 5]
Output: 3 -&gt; 1 -&gt; 2 -&gt; 10 -&gt; 5 -&gt; 5 -&gt; 8
</code></pre>
<p><em>提示：#3, #24</em></p>
</li>
<li>
<p><strong>2.5 总和列表（Sum Lists）</strong>：你有两个由链表表示的数字，其中每个节点都包含一个数字。 这些数字以相反的顺序存储，即第一位的数字就位于列表的开头。编写一个函数，将两个数字相加，然后将和以链表的形式返回。</p>
<p>EXAMPLE</p>
<pre><code>Input: (7-&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2). That is, 617 + 295.
Output: 2 -&gt; 1 -&gt; 9. That is, 912.
</code></pre>
<p>FOLLOW UP</p>
<p>假设数字以正序存储。重复上述问题。</p>
<p>EXAMPLE</p>
<pre><code>Input: (6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5). That is, 617 + 295.
Output: 9 -&gt; 1 -&gt; 2. That is, 912.
</code></pre>
<p><em>提示：#7, #30, #71, #95, #109</em></p>
</li>
<li>
<p><strong>2.6 回文（Palindrome）</strong>：实现一个函数来检查一个链表是否是一个回文。</p>
<p><em>提示：#5, #13, #29, #61, #101</em></p>
</li>
<li>
<p><strong>2.7 相交（Intersection）</strong>：给定两个（单）链表，判断两个链表是否相交。是的话返回相交节点。请注意，相交是基于引用而不是基于值定义的。也就是说，如果第一个链表的第 k 个节点与第二个链表的第 j 个节点完全相同（引用层面上），那么它们相交。</p>
<p><em>提示：#20, #45, #55, #65, #76, #93, #111, #120, #129</em></p>
</li>
<li>
<p><strong>2.8 循环检测（Loop Detection）</strong>：给定一个循环链表，实现一个算法，返回循环开始处的节点。</p>
<p>DEFINITION</p>
<p>循环链表：一种（不纯的）链表，其中一个节点的下一个指针指向较早的节点，从而在链表中形成一个循环。</p>
<p>EXAMPLE</p>
<pre><code>Input: A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; C [the same C as earlier]
Output: C
</code></pre>
<p><em>提示：#50, #69, #83, #90</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：树和图(#4.3)，面向对象设计(#7.12)，系统设计和可扩展性(#9.5)，中等问题(#16.25)，困难问题(#17.12)。</p>
<p>提示从第 653 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3--栈和队列"><a class="header" href="#chapter-3--栈和队列">Chapter 3 | 栈和队列</a></h1>
<p>如果您熟悉数据结构的细节，那么有关堆栈和队列的问题将更容易处理。不过，这些问题可能相当棘手。有些问题可能仅仅是对原始数据结构的轻微修改，但是其他问题则将面临更复杂的挑战。</p>
<h3 id="实现一个栈"><a class="header" href="#实现一个栈">实现一个栈</a></h3>
<p>堆栈数据结构正如它听起来的样子：一堆数据。在某些类型的问题中，将数据存储在堆栈中可能比存储在数组中更好。</p>
<p>堆栈使用 LIFO（后进先出）的顺序。也就是说，就像在一堆餐盘中一样，添加到堆栈中的最新项是要删除的第一个项。
它使用以下操作：</p>
<ul>
<li>pop () : Remove the top item from the stack.</li>
<li>push (item) : Add an item to the top of the stack.</li>
<li>peek () : Return the top of the stack.</li>
<li>isEmpty () : Return true if and only if the stack is empty.</li>
</ul>
<p>与数组不同，堆栈不提供对第 i 项的固定时间（constant-time）访问。但是，它允许固定时间的添加和删除，因为它不需要移动元素。</p>
<p>我们提供了实现堆栈的简单示例代码。注意，如果数据项是从同一侧添加和删除的，也可以使用链表实现堆栈。</p>
<pre><code class="language-java">1 	public class MyStack&lt;T&gt; {
2 		private static class StackNode&lt;T&gt; {
3 			private T data;
4 			private StackNode&lt;T&gt; next;
5
6 			public StackNode(T data) {
7 				this.data = data;
8 			}
9 		}
10
11 		private StackNode&lt;T&gt; top;
12
13 		public T pop() {
14 			if (top == null) throw new EmptystackException();
15 			T item = top.data;
16 			top = top.next;
17 			return item;
18 		}
19
20 		public void push(T item) {
21 			StackNode&lt;T&gt; t = new StackNode&lt;T&gt;(item);
22 			t.next = top;
23 			top= t;
24 		}
25
26 		public T peek() {
27 			if (top == null) throw new EmptyStackException();
28 			return top.data;
29 		}
30
31 		public boolean isEmpty() {
32 			return top == null;
33 		}
34 	}
</code></pre>
<p>经常有用到堆栈一种情况是在某些递归算法中。有时候，你需要在递归时将临时数据 push 到堆栈中，然后在回溯（backtrack）时删除它们（例如，因为递归检查失败）。堆栈提供了一种直观的方法来实现。</p>
<p>堆栈还可以用于迭代地实现递归算法。（这是一个很好的练习！采用简单的递归算法并迭代实现。）</p>
<h3 id="实现一个队列"><a class="header" href="#实现一个队列">实现一个队列</a></h3>
<p>A queue implements FIFO (first-in first-out) ordering. As in a line or queue at a ticket stand, items are removed from the data structure in the same order that they are added.
It uses the operations:</p>
<p>队列使用 FIFO（先进先出）的顺序。就像在售票亭排队一样，数据项将按照添加它们的顺序从数据结构中删除。</p>
<p>它使用以下操作：</p>
<ul>
<li>add (item) : Add an item to the end of the list.</li>
<li>remove () : Remove the first item in the list.</li>
<li>peek () : Return the top of the queue.</li>
<li>isEmpty () : Return true if and only if the queue is empty.</li>
</ul>
<p>队列也可以用链表实现。事实上，它们本质上是一样的，它们本质上是一样的。</p>
<pre><code class="language-java">1 	public class MyQueue&lt;T&gt; {
2 		private static class QueueNode&lt;T&gt; {
3 			private T data;
4 			private QueueNode&lt;T&gt; next;
5
6 			public QueueNode(T data) {
7 				this.data = data;
8 			}
9 		}
10
11 		private QueueNode&lt;T&gt; first;
12 		private QueueNode&lt;T&gt; last;
13
14 		public void add(T item) {
15 			QueueNode&lt;T&gt; t = new QueueNode&lt;T&gt;(item);
16 			if (last != null) {
17 				last.next= t;
18 			}
19 			last = t;
20 			if (first== null) {
21 				first= last;
22 			}
23 		}
24
25 		public T remove() {
26 			if (first== null) throw new NoSuchElementException();
27 			T data= first.data;
28 			first= first.next;
29 			if (first == null) {
30 				last = null;
31 			}
32 			return data;
33 		}
34
35 		public T peek() {
36 			if (first== null) throw new NoSuchElementException();
37 			return first.data;
38 		}
39
40 		public boolean isEmpty() {
41 			return first== null;
42 		}
43 	}
</code></pre>
<p>更新队列中的第一个和最后一个节点尤其容易出错。一定要仔细检查一下。</p>
<p>经常使用队列的地方是广度优先搜索（breadth-first search）或实现一个缓存（cache）。</p>
<p>例如，在广度优先搜索中，我们使用队列来存储我们需要处理的节点列表。每次处理节点时，都将其相邻节点添加到队列的后面。这允许我们按照查看顺序处理节点。</p>
<hr />
<h3 id="interview-questions-3"><a class="header" href="#interview-questions-3">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>3.1 三合一（Three in One）</strong>：描述如何使用单个数组实现三个栈。</p>
<p><em>提示：#2, #72, #38, #58</em></p>
</li>
<li>
<p><strong>3.2 Min函数（Stack Min）</strong>：设计一个栈，除了 push 和 pop，还有一个返回最小元素的函数 min。push、pop 和 min 的运行时间都应为 0(1)。</p>
<p><em>提示：#27, #59, #78</em></p>
</li>
<li>
<p><strong>3.3 一摞盘子（Stack of Plates）</strong>：想象有一摞盘子。如果这摞盘子堆得太高，它可能会倒塌。因此，在现实生活中，当前一摞盘子的高度超过某个阈值时，我们可能需要重新放一摞。实现一个类似于此的数据结构 SetOfStacks 。SetOfStacks 应该由几个栈组成，并且应该在前一个栈超过容量时创建一个新的栈。SetOfStacks.push() 和SetOfStacks.pop() 的作用应该与单个堆栈相同（即，pop() 返回的值应该与仅有单个堆栈时的返回值相同）。</p>
<p>FOLLOW UP</p>
<p>实现一个函数 popAt(int index)，它在特定的子堆栈上执行 pop 操作。</p>
<p><em>提示：#64, #87</em></p>
</li>
<li>
<p><strong>3.4 通过堆栈实现队列（Queue via Stacks）</strong>：实现一个 MyQueue 类，它使用两个堆栈实现一个队列。</p>
<p><em>提示：#98, #774</em></p>
</li>
<li>
<p><strong>3.5 排序堆栈（Sort Stack）</strong>：编写一个程序对栈进行排序，使最小的项在栈顶。可以使用额外的临时堆栈，但不能将元素复制到任何其他数据结构（如数组）中。堆栈支持以下操作：push、pop、peek 和 Empty。</p>
<p><em>提示：# 15, #32, #43</em></p>
</li>
<li>
<p><strong>3.6 动物收容所（Animal Shelter）</strong>：动物收容所只收容猫狗，实行“先进先出”的原则。人们必须在动物收容所里收养“最老的”动物（根据到达时间），或者他们可以选择他们更喜欢狗还是猫（并且将收养这种类型中最老的动物）。他们不能选择他们想要的特定动物。创建数据结构以维护该系统，并实现诸如 enqueue，dequeueAny，dequeueDog 和 dequeueCat 之类的操作。你可以使用内置的链表数据结构。</p>
<p><em>提示：#22, #56, #63</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：链表(#2.6)，中等问题(#16.26)，困难问题(#17.9)。</p>
<p>提示从第 653 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4--树和图"><a class="header" href="#chapter-4--树和图">Chapter 4 | 树和图</a></h1>
<p>许多求职者发现树和图的问题是最棘手的。搜索一个树要比在一个线性组织的数据结构（例如数组或链表）中搜索要复杂得多。此外，最坏情况和平均情况下的时间复杂度可能会有很大差异，我们必须评估任何算法的两个方面。熟练地从头实现树或图将是必不可少的。</p>
<p>因为与图相比，大多数人对树更熟悉（而且它们也更简单些），所以我们将先讨论树。但这有点乱，因为树实际上就是一种图。</p>
<blockquote>
<p>注：本章中的某些术语在不同的教科书和其他资料中可能略有不同。如果你习惯了不同的定义，那也没关系。但在面试中一定要和面试官澄清任何有歧义的地方。</p>
</blockquote>
<h3 id="树的类型"><a class="header" href="#树的类型">树的类型</a></h3>
<p>理解树的一种很好的方法是使用递归来解释。树是由节点（Node）组成的数据结构。</p>
<ul>
<li>
<p>每棵树都有一个根节点。（实际上，这在图论中并不是绝对必要的，但通常我们在编程中使用树的方式就是这样，尤其是在编程面试中。）</p>
</li>
<li>
<p>根节点具有零个或多个子节点。</p>
</li>
<li>
<p>每个子节点都有零个或多个子节点，以此类推。</p>
</li>
</ul>
<p>树中不能有环。节点的顺序可能是特定的，也可能不特定，节点的值可以是任何的数据类型，并且它们可能有也可能没有返回到父节点的链接。</p>
<p>Node 的一个非常简单的类定义是：</p>
<pre><code class="language-java">1 	class Node {
2 		public String name;
3 		public Node[] children;
4 	}
</code></pre>
<p>你可能还想写一个 Tree 类来封装这个 node 。但出于面试问题的目的，我们通常不使用 Tree 类。如果你觉得这能使你的代码更简单或更好，你可以这样做，但事实上很少有这种情况。</p>
<pre><code class="language-java">1 	class Tree {
2 		public Node root;
3 	}
</code></pre>
<p>树和图的问题经常是充满了模糊的细节和错误的假设。请务必理解下面的这些概念，并在必要时跟面试官澄清。</p>
<h4 id="树-vs-二叉树"><a class="header" href="#树-vs-二叉树">树 vs. 二叉树</a></h4>
<p>二叉树（binary tree）是指每个节点最多有两个子节点的树。并不是所有的树都是二叉树。例如，下面这个树不是二叉树。你可把它称为三元树（ternary tree）。</p>
<div align=center><img src="img/ch4_1.png"/></div>
有时候你可能需要一个不是二叉树的树。例如，假设你使用树来表示一串电话号码。在这种情况下，你可以使用 10 元树（10-ary tree），即每个节点最多包含10个子节点（每个节点代表一个数字）。
<p>如果节点没有子节点，则称该节点为“叶子”节点。</p>
<h4 id="二叉树-vs-二叉搜索树"><a class="header" href="#二叉树-vs-二叉搜索树">二叉树 vs. 二叉搜索树</a></h4>
<p>二叉搜索树（binary search tree）是一种二叉树，其中每个节点都符合一个特定的排序属性：所有左子节点 &lt;= n &lt; 所有右子节点。对于每个节点 n 都必须如此。</p>
<blockquote>
<p>二叉搜索树的定义在节点值相等时的处理方面可能略有不同。在某些定义下，树不能有重复的值。在其他情况下，重复的值将位于右侧，或者可以位于任意一侧。所有这些都是有效的定义，但前提是你应该和面试官说清楚。</p>
</blockquote>
<p>注意，这个不等式必须对节点的所有后代都成立，而不仅仅是它的直接子节点。下图左边的树是一个二叉搜索树。右边的树不是，因为 12 在 8 的左子树里。</p>
<div align=center><img src="img/ch4_2.png"/></div>
当给出一个树的问题时，许多求职者下意识认为面试官说的是一个二叉搜索树。记住一定要问清楚。二叉搜索树的必要条件是，对于每个节点，其左子节点小于或等于当前节点，而当前节点小于右子节点。
<h4 id="平衡-vs-不平衡"><a class="header" href="#平衡-vs-不平衡">平衡 vs. 不平衡</a></h4>
<p>虽然很多树都是平衡的，但并非所有树都平衡。让你的面试官在这里澄清一下。注意，平衡树并不意味着左右子树的大小完全相同（就像下图中的“完美二叉树”这样）。</p>
<p>一种理解方法是，“平衡”树实际上意味着“不是非常不平衡”。它的平衡程度足以确保 insert 和 find 的时间复杂度为 O(log n) ，但它并不一定像可能的那样平衡。</p>
<p>两种常见的平衡树是红黑树（pg 639）和AVL树（pg 637）。这些将在 Advanced Topics 这部分中进行更详细的讨论。</p>
<h4 id="完全二叉树"><a class="header" href="#完全二叉树">完全二叉树</a></h4>
<p>完全二叉树（complete binary tree）是一种除最后一层外，树的其他每一层都被完全填充的二叉树。最后一层满足从左到右填充。</p>
<div align=center><img src="img/ch4_3.png"/></div>
#### 满二叉树
满二叉树（full binary tree）是一种二叉树，其中每个节点都有 0 个或 2 个子节点。也就是说，不存在某个节点只有一个子节点。
<div align=center><img src="img/ch4_4.png"/></div>
#### 完美二叉树
完美二叉树（perfect binary tree）既满足完全二叉树特征，又满足满二叉树的特征。所有的叶子节点都在同一层，并且这一层拥有最大节点数。
<div align=center><img src="img/ch4_5.png"/></div>
注意，完美二叉树在面试和实际使用中很少见，因为完美树必须恰好有 2^k - 1 个节点（其中 k 是级树的层数）。在面试中，不要假设二叉树是完美的。
<h3 id="二叉树遍历"><a class="header" href="#二叉树遍历">二叉树遍历</a></h3>
<p>在面试之前，你应该能够轻松地实现中序遍历、前序遍历和后序遍历。其中最常见的是中序遍历。</p>
<h4 id="中序遍历"><a class="header" href="#中序遍历">中序遍历</a></h4>
<p>中序遍历（In-order traversal）意味着先“访问（visit）”（通常是打印）左边的分支，然后是当前节点，最后是右边的分支。</p>
<pre><code class="language-java">1 	void inOrderTraversal(TreeNode node) {
2 		if (node != null) {
3 			inOrderTraversal(node.left);
4 			visit(node);
5 			inOrderTraversal(node.right);
6		}
7 	}
</code></pre>
<p>在二叉搜索树上执行时，它按升序访问节点（因此得名 “in-order”）。</p>
<h4 id="前序遍历"><a class="header" href="#前序遍历">前序遍历</a></h4>
<p>前序遍历（Pre-order traversal ）先访问当前节点，再访问其子节点（因此得名 “pre-order”）。</p>
<pre><code class="language-java">1 	void preOrderTraversal(TreeNode node) {
2 		if (node != null) {
3 			visit(node);
4 			preOrderTraversal(node.left);
5 			preOrderTraversal(node.right);
6 		}
7	}
</code></pre>
<p>在前序遍历中，根节点总是被访问的第一个节点。</p>
<h4 id="后序遍历"><a class="header" href="#后序遍历">后序遍历</a></h4>
<p>后序遍历（Post-order traversal）先访问当前节点的子节点，再访问该节点(因此得名 “post-order”)。</p>
<pre><code class="language-java">1 	void postOrderTraversal(TreeNode node) {
2 		if (node != null) {
3 			postOrderTraversal(node.left);
4 			postOrderTraversal(node.right);
5 			visit(node);
6		}
7 	}
</code></pre>
<p>在后序遍历中，根节点总是被访问的最后一个节点。</p>
<h3 id="二叉堆最小堆和最小堆"><a class="header" href="#二叉堆最小堆和最小堆">二叉堆（最小堆和最小堆）</a></h3>
<p>我们在这里只讨论最小堆。最大堆本质上是相同的，但是元素的顺序是降序而不是升序。</p>
<p>最小堆是一个完整二叉树（也就是说，除了最后一层中最右边的元素之外，其他的都被填满了)，其中每个节点都比其子节点小。因此，根节点是树中的最小元素。</p>
<div align=center><img src="img/ch4_6.png"/></div>
在最小堆上有两个关键操作：insert 和 extract_min。
<p><em>插入（insert）</em></p>
<p>当我们插入最小堆时，我们总是从底部插入元素开始。我们从最右边的位置插入，以便不破坏其完整二叉树的属性。</p>
<p>然后，我们通过将新元素与其父元素交换来“修复”树，直到找到适合该元素的位置。也就是将最小的元素向上冒泡（bubble up）。</p>
<div align=center><img src="img/ch4_7.png"/></div>
这需要 O(log n) 时间，其中 n 是堆中的节点数。
<p><em>提取最小元素（Extract Minimum Element）</em></p>
<p>找到最小堆的最小元素很容易：它始终位于顶部。而更棘手的部分是如何删除它。（事实上，这并不是那么棘手。）</p>
<p>首先，我们删除最小元素并将其与堆中的最后一个元素（最底部，最右侧的元素）交换。然后，我们向下冒泡（bubble down）这个元素，与它的一个子元素交换，直到最小堆属性恢复为止。</p>
<p>我们要和左子结点交换还是和右子结点交换？这取决于节点值的大小。在左右元素之间没有固有的顺序，但是你需要使用较小的元素来维护最小堆顺序。</p>
<div align=center><img src="img/ch4_8.png"/></div>
这个算法也将花费 O(log n) 的时间。
<h3 id="tries前缀树"><a class="header" href="#tries前缀树">Tries（前缀树）</a></h3>
<p>trie（有时称为前缀树，prefix tree）是一种有趣的数据结构。它在面试问题中经常出现，但是算法教科书并没有在这个数据结构上花费太多时间。</p>
<p>trie 是 n 元树的一种变体，其中字符存储在每个节点上。树下的每条路径都可以代表一个单词。</p>
<p><code>*</code>节点（有时称为“空节点”）通常用于指示完整的单词。例如，MANY 下面有一个<code>*</code>节点的事实表明MANY 是一个完整的单词。MA 路径的存在表明有以 MA 开头的单词。</p>
<p>这些<code>*</code>节点的实际实现可能是一种特殊类型的子节点（例如 TerminingTrieNode，它继承自 TrieNode）。或者，我们可以在“父”节点内使用一个布尔标志终止。</p>
<p>trie 中的节点可以有 1 到 ALPHABET_SIZE + 1 个子节点（如果使用布尔标志而不是<code>*</code>节点，则可以是 0 到 ALPHABET_SIZE个 ）。</p>
<div align=center><img src="img/ch4_9.png"/></div>
通常，trie 用于存储整个（英语）语言文字以进行快速前缀查找。虽然 hash table 可以快速查阅一个字符串是否是有效单词，但它无法告诉我们一个字符串是否是任何有效单词的前缀。trie 可以很快地做到这一点。
<blockquote>
<p>有多快呢？trie 可以在 O(K) 的时间内检查一个字符串是否是有效前缀，其中 K 是字符串的长度。这实际上与 hash table 的运行时（runtime）相同。虽然我们经常将 hash table 查找的运行时称为 O(1)，但这并不完全正确。hash table 必须读取输入中的所有字符，在单词查找的情况下需要 O(K) 时间。</p>
</blockquote>
<p>许多涉及有效单词列表的问题都使用 trie 作为优化。当我们在树中反复搜索相关前缀时（例如，查找M，然后 MA，然后 MAN，然后 MANY），我们可以传递对树中当前节点的引用。这将允许我们只检查 Y 是否是 MAN 的子节点，而不是每次都从根节点开始。</p>
<h3 id="图"><a class="header" href="#图">图</a></h3>
<p>树实际上是一种图，但不是所有的图都是树。简而言之，树是没有环的连通图（connected graph）。</p>
<p>图就是通过边来互相连接的节点的集合。</p>
<ul>
<li>
<p>图可以是有向的（如下图所示），也可以是无向的。有向边就像单行道，无向边就像双行道。</p>
</li>
<li>
<p>图可能由多个独立的子图组成。如果每对顶点之间都有一条路径，则称为“连通图（connected graph）”。</p>
</li>
<li>
<p>图也可以有环（或没有）。 “无环图（acyclic graph）”是没有环的图。</p>
</li>
</ul>
<p>直观上，你可以这样画一个图:</p>
<div align=center><img src="img/ch4_10.png"/></div>
在编程方面，有两种常用的方法来表示图。
<h4 id="邻接表adjacency-list"><a class="header" href="#邻接表adjacency-list">邻接表（Adjacency List）</a></h4>
<p>这是表示图最常用的方法。每个顶点（或节点）存储一个邻接顶点表（list of adjacent vertices）。</p>
<p>在无向图中，像 (a, b) 这样的边会被存储两次：一次在 a 的邻接顶点中，一次在 b 的邻接顶点中。</p>
<p>图节点的简单类定义看起来与树节点基本相同。</p>
<pre><code class="language-java">1 	class Graph {
2 		public Node[] nodes;
3 	}
4
5 	class Node {
6 		public String name;
7 		public Node[] children;
8 	}
</code></pre>
<p>之所以使用 Graph 类，是因为与树不同，你不一定能从一个节点到达所有节点。</p>
<p>你不需要任何额外的类来表示图。由列表（数组、arraylist、链表等）组成的数组（或 hash table）可以存储邻接表。上图可以表示为：</p>
<blockquote>
<p>0: 1
1: 2
2: 0, 3
3: 2
4: 6
5: 4
6: 5</p>
</blockquote>
<p>这个更紧凑一些，但看起来没有那么清晰。除非有令人信服的理由，否则我们还是倾向于使用节点类。</p>
<h4 id="邻接矩阵adjacency-matrices"><a class="header" href="#邻接矩阵adjacency-matrices">邻接矩阵（Adjacency Matrices）</a></h4>
<p>邻接矩阵是一个 NxN 布尔矩阵（其中N是节点的数量），其中当<code>matrix[i][j]</code>处的值为<code>true</code>时，表示从节点 i 到节点 j 存在一条边（也可以使用一个成分为 0 和 1 的整数矩阵来表示）。</p>
<p>在无向图中，邻接矩阵是对称的。而在有向图中，这不一定。</p>
<div align=center><img src="img/ch4_11.png"/></div>
邻接表中使用的图算法（广度优先搜索等）也可以使用邻接矩阵执行，但是它们的效率可能会有所降低。在使用邻接表来表示时，你可以轻松地遍历节点的邻居。在使用邻接矩阵来表示时，需要遍历所有节点来标识节点的邻接点。
<h3 id="图搜索"><a class="header" href="#图搜索">图搜索</a></h3>
<p>搜索图的两种最常用方法是深度优先搜索（depth-first search）和广度优先搜索（breadth-first search）。</p>
<p>在深度优先搜索（DFS）中，我们从根节点（或另一个任意选择的节点）开始，并在移动到下一个分支之前，先完全探索每个分支。即，先深度后广度（因此得名深度优先搜索）。</p>
<p>在广度优先搜索（BFS）中，我们从根节点（或另一个任意选择的节点）开始，并在对它的任何一个子节点的分支进行继续探索之前，先保证探索完它的每个邻接点。即，先广度后深度（因此得名广度优先搜索）。</p>
<p>请参阅下面对一个图及其深度优先和广度优先搜索的描述（假设邻接点按数字顺序迭代）。</p>
<div align=center><img src="img/ch4_12.png"/></div>
广度优先搜索和深度优先搜索往往用于不同的场景。如果我们想访问图中的每个节点，通常首选 DFS。两者都可以很好地完成，但深度优先搜索的实现要更简单一些。
<p>但是，如果我们想要找到两个节点之间的最短路径（或任何路径），BFS 通常会更好。</p>
<p>考虑将整个世界上所有的人际关系用一个图来表示，并尝试在 Ash 和 Vanessa 之间找到一条关系路径。</p>
<p>在深度优先搜索中，我们可能会经历这样一条路径，比如 Ash -&gt; Brian -&gt; Carleton -&gt; Davis -&gt; Eric -&gt; Farah -&gt; Gayle -&gt; Harry -&gt; Isabella -&gt; John -&gt; Kari ...，然后发现自己离得很远。这样我们可能绕了大半个世界，而无法意识到，事实上 Vanessa 直接就是 Ash 的朋友。我们最终还是会找到他们之间的关系路径，但可能需要很长时间。而且这往往也不是最短的路径。</p>
<p>在广度优先搜索中，我们将尽可能久地在靠近 Ash 的位置查找。我们可能会遍历 Ash 的许多朋友，但除非绝对必要，否则我们不会去搜索他那些相对更疏远的人脉关系。如果 Vanessa 是 Ash 的朋友，或者是他朋友的朋友，我们能够在相对较短的时间内地找到这条路径。</p>
<h4 id="深度优先搜索-dfs"><a class="header" href="#深度优先搜索-dfs">深度优先搜索 (DFS)</a></h4>
<p>在 DFS 中，我们访问一个节点 a，然后遍历 a 的每个邻接点。当访问 a 的邻接点 b 时，我们先访问 b 的所有邻接点，然后再访问 a 的其他邻接点。也就是说，a 比它的任何邻接点都先彻底地搜索 b 的分支。</p>
<p>注意，前序遍历和其他形式的树遍历是 DFS 的一种形式。关键的区别在于，在为图实现这种算法时，我们必须检查节点是否已被访问。如果我们不这样做，我们就有陷入无限循环的风险。</p>
<p>下面的伪代码实现了DFS。</p>
<pre><code class="language-java">1 	void search(Node root) {
2 		if (root == null) return;
3 		visit(root);
4 		root.visited = true;
5 		for each (Node n in root.adjacent) {
6 			if (n.visited == false) {
7				search(n);
8			}
9		}
10 	}
</code></pre>
<h4 id="广度优先搜索-bfs"><a class="header" href="#广度优先搜索-bfs">广度优先搜索 (BFS)</a></h4>
<p>BFS 没有那么直观，许多求职者在实现 BFS 时都会感觉到很纠结，除非他们对此已经足够熟悉。主要的障碍是（错误地）假设 BFS 是递归的。实际并不是，相反，它使用队列。</p>
<p>在 BFS 中，节点 a 在访问在访问完自己的所有邻接点之后，才会去访问其邻接点的邻接点。你可以将此视为从 a 开始逐级搜索。使用队列的迭代解决方案通常是效果最好的。</p>
<pre><code class="language-java">1 	void search(Node root) {
2 		Queue queue = new Queue();
3 		root.marked = true;
4 		queue.enqueue(root); // Add to the end of queue
5
6 		while (!queue.isEmpty()) {
7 			Node r = queue.dequeue(); // Remove from the front of the queue
8 			visit(r);
9 			foreach (Node n in r.adjacent) {
10 				if (n.marked == false) {
11 					n. marked = true;
12 					queue.enqueue(n);
13				}
14			}
15 		}
16 	}
</code></pre>
<p>如果你被要求去实现 BFS，最关键是要记住使用队列。算法的其余部分都基于此。</p>
<h4 id="双向搜索bidirectional-search"><a class="header" href="#双向搜索bidirectional-search">双向搜索（Bidirectional Search）</a></h4>
<p>双向搜索用于寻找源节点和目标节点之间的最短路径。它通过同时运行两个广度优先搜索来进行，每个节点执行一个。当他们的搜索发生碰撞时，我们就找到了一条路径。</p>
<div align=center><img src="img/ch4_13.png"/></div>
为了了解为什么这更快，考虑一个图，其中每个节点最多具有 k 个相邻节点，并且从节点 s 到节点 t 的最短路径长度为 d。
<ul>
<li>
<p>在传统的广度优先搜索中，我们将在搜索的第一个“层级”中搜索最多 k 个节点。 在第二层中，我们将为那些前 k 个节点中的每一个搜索最多 k 个节点，因此总共 k^2 个节点（到目前为止）。我们这样做 d 次，这样就是 O(k^d) 个节点。</p>
</li>
<li>
<p>在双向搜索中，我们的两个搜索在大约在执行到 d/2 层（路径的中点）之后发生碰撞。从节点 s 开始的搜索大约访问 k^(d/2) 个节点，从节点 t 开始的搜索也是如此。 这总共给大概是 2*k^(d/2) 或 O(k^(d/2)) 个节点。</p>
</li>
</ul>
<p>这似乎是一个微小的差异，但事实并非如此，差距是很大的。回忆一下 (k^(d/2)) * (k^(d/2)) = k^d。双向搜索实际上要快 k^(d/2) 倍。</p>
<p>换句话说：如果我们的系统只能支持在广度优先搜索中搜索 “friend of friend” 路径，那么它现在可能会支持 “friend of friend of friend of friend” 路径。即我们可以支持原先两倍长的路径。</p>
<p><strong>附加阅读</strong>：Topological Sort (pg 632), Dijkstra's Algorithm (pg 633), AVL Trees (pg 637), Red-BlackTrees (pg 639).</p>
<hr />
<h3 id="interview-questions-4"><a class="header" href="#interview-questions-4">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>4.1 节点间路线（Route Between Nodes）</strong>：给定一个有向图，设计一个算法来判断两个节点之间是否有存在一条路线。</p>
<p><em>提示：#127</em></p>
</li>
<li>
<p><strong>4.2 最小树（Minimal Tree）</strong>：给定一个具有唯一整数元素的排序（递增顺序）数组，编写算法创建一个高度最小的二叉搜索树。</p>
<p><em>提示：#79, #73, #776</em></p>
</li>
<li>
<p><strong>4.3 深度列表（List of Depths）</strong>：给定一个二叉树，设计一个算法，在每个深度创建一个该处所有节点的链表（例如，如果你有一个深度为 D 的树，你就会有 D 个链表）。</p>
<p><em>提示：#107, #123, #135</em></p>
</li>
<li>
<p><strong>4.4 检查平衡（Check Balanced）</strong>：实现一个函数来检查二叉树是否平衡。出于此问题的目的，将平衡树定义为这样一种树：树中任意一个节点的两个子树的高度相差不会超过 1。</p>
<p><em>提示：#27, #33, #49, #705, #724</em></p>
</li>
<li>
<p><strong>4.5 验证BST （Validate BST）</strong>：实现一个函数来检查二叉树是否是二叉搜索树。</p>
<p><em>提示：#35, #57, #86, #113, #128</em></p>
</li>
<li>
<p><strong>4.6 后继（Successor）</strong>：编写一种算法，以在二进制搜索树中找到给定节点的“下一个”节点（即有序后继）。你可以假定每个节点都有一个指向其父节点的链接。</p>
<p><em>提示：#79, #91</em></p>
</li>
<li>
<p><strong>4.7 构建顺序（Build Order）</strong>：给你一个项目列表和一个依赖项列表（这是一对项目的列表，其中第二个项目依赖于第一个项目）。所有依赖项必须在项目开始之前构建。找到一个允许构建项目的构建顺序。如果没有有效的构建顺序，则返回错误。</p>
<p>EXAMPLE</p>
<pre><code></code></pre>
</li>
</ul>
<p>Input:
projects: a, b, c, d, e, f
dependencies: (a, d), (f, b), (b, d), (f, a), (d, c)
Output: f, e, a, b, d, c</p>
<pre><code>
*提示：#26, #47, #60, #85, #725, #133*



- **4.8 第一个共同祖先（First Common Ancestor）**：设计一个算法，编写代码实现查找二叉树中两个节点的第一个共同祖先。避免在数据结构中存储额外的节点。注意：这不一定是二叉搜索树。

*提示：#70, #76, #28, #36, #46, #70, #80, #96*



- **4.9 BST序列（BST Sequences）**：通过从左到右遍历一个数组并插入每个元素，创建二叉搜索树。给定一个具有不同元素的二叉搜索树，打印所有可能生成该树的数组。

EXAMPLE

</code></pre>
<p>Input:</p>
<pre><code>
&lt;div align=center&gt;&lt;img src="img/ch4_14.png"/&gt;&lt;/div&gt;

</code></pre>
<p>Output: {2, 1, 3}, {2, 3, 1}</p>
<pre><code>  
  *提示：#39, #48, #66, #82*
  

  
- **4.10 检查子树（Check Subtree）**：T1 和 T2 是两个非常大的二叉树，T1 比 T2 大得多。创建算法以确定 T2 是否为 T1 的子树。如果在 T1 中存在节点 n，且该节点 n 的子树与 T2 相同，则 T2 是 T1 的一个子树。也就是说，如果你在节点 n 处砍下这个树，那么这两个树将是相同的。

  *提示：#4, #11, #18, #31, #37*

  

- **4.11 随机节点（Random Node）**：你将从头实现一个二叉树类，这个类除了插入、查找和删除外，还有一个方法 getRandomNode()，它从树中返回一个随机节点。所有节点被选择的概率应该是相等的。为 getRandomNode 设计和实现一个算法，并解释如何实现其余的方法。

  *提示：#42, #54, #62, #75, #89, #99, #112, #119*

  

- **4.12 带求和的路径（Paths with Sum）**：给定一个二叉树，其中每个节点包含一个整数值（可能是正的，也可能是负的）。设计一个算法来计算一个总和为给定值的路径总数。该路径不需要在根节点或叶节点处开始或结束，但必须向下（即只从父节点移动到子节点）。

  *提示：#6, #14, #52, #68, #77, #87, #94, #103, #108, #115*



**附加问题**：递归(#8.10)，系统设计和可扩展性(#9.2,#9.3)，排序和搜索(#10.10)，困难问题(#17.7,#17.12,#17.13,#17.14,#17.17,#17.20,#17.22,#17.25)。

提示从第 653 页开始。</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5--位操作"><a class="header" href="#chapter-5--位操作">Chapter 5 | 位操作</a></h1>
<p>位操作用于处理各种各样的问题。有时候，会有问题明确说明需要通过位操作处理。但也有时候，位操纵只是被当做一种优化代码的技术来使用。你应该熟悉位操作，无论是手动计算还是使用代码实现。请小心，在进行位操作时很容易犯小错误。</p>
<h3 id="手动位操作"><a class="header" href="#手动位操作">手动位操作</a></h3>
<p>如果你对位操作有些生疏，可以试试下面的手动计算练习。其中第三列中的项目可以完全靠手动解决，也可以使用一些“技巧”（如下所述）。为了简单起见，假设使用的都是四位的数字。</p>
<p>如果你搞混了，就将它们作为基数 10 （译者注，即十进制）进行处理。然后可以对二进制数应用相同的处理过程。记住 ^ 表示一个 XOR（异或），而 ~ 是一个 NOT（否定）。</p>
<div align=center><img src="img/ch5_1.png"/></div>
第三栏使用的技巧分别如下：
<ol>
<li>
<p>0110 + 0110 等于0110 * 2，相当于将 0110 左移 1 位。</p>
</li>
<li>
<p>0100 等于 4，乘以 4 就是左移 2 位。将 0011 左移 2 位，得到 1100。</p>
</li>
<li>
<p>考虑将计算过程分解成一位一位地进行。如果将某位与它自己的否定值进行异或（XOR），则始终会得到 1。因此，a^(~a) 的解将是一个全部由 1 组成的序列。</p>
</li>
<li>
<p>~0 会得到一个全部由 1 组成的序列，所以 ~0 &lt;&lt; 2 结果是 1 的序列后面加两个 0。与另一个值按位与（AND）的话，将使该值的最后两位清零。</p>
</li>
</ol>
<p>如果你没有立即想到这些技巧的话，请从逻辑上来考虑解决。</p>
<h3 id="位操作的真相和技巧"><a class="header" href="#位操作的真相和技巧">位操作的真相和技巧</a></h3>
<p>下列表达式在位操作中很有用。不过，不要只是记住它们，仔细想想为什么这些都是正确的。我们使用 “1s” 和 “0s” 分别表示 1 或 0 的序列。</p>
<div align=center><img src="img/ch5_2.png"/></div>
要理解这些表达式，请回想一下这些操作是逐位发生的，其中一个位上发生的操作不会影响其他位。这意味着如果上述一个语句对于单个位为真，那么对于一个位序列也是正确的。
<h3 id="二进制补码和负数"><a class="header" href="#二进制补码和负数">二进制补码和负数</a></h3>
<p>计算机通常以二进制补码的形势存储整数。正数表示为自身，而负数表示为其绝对值的二进制补码（其符号位为 1 表示负值）。N 位数的二进制补码（其中 N 是用于该数字的位数，不包括符号位）是该数字关于 2^N 的补码。</p>
<p>让我们以 4 位整数 -3 为例。如果是一个 4 位的数字，我们有一位用于符号，三位用于该值。我们可以求关于 2^3 的补码，也就是 8。3（-3 的绝对值）关于 8 的补码（The complement of 3 with respect to 8，译者注，即 8 - 3）是 5。二进制中的 5 是 101。因此，二进制中 4 位数字的 -3 是1101，第一位是符号位。</p>
<p>换句话说，作为 N 位数字 -K（负K）的二进制表示是  <code>concat(1, (2^N-1) - K) </code>。</p>
<p>另一种理解方法是我们把正数表示中的各位取反，然后加1。3 在二进制中是 011。将各位取反得到 100，加 1 得到 101，然后将符号位 (1) 前置得到 1101。</p>
<p>在四位整数中，这将如下所示。</p>
<div align=center><img src="img/ch5_3.png"/></div>
观察到左边和右边的整数的绝对值之和总是为 2^3，并且左边和右边的二进制值是相同的，除了符号位。这是为什么呢？
<h3 id="算术右移-vs-逻辑右移"><a class="header" href="#算术右移-vs-逻辑右移">算术右移 vs. 逻辑右移</a></h3>
<p>右移操作符有两种类型。算术右移本质上就是除以 2。逻辑上的右移就是我们在视觉上看到的位的移动。这在负数上最能够体现。</p>
<p>在逻辑右移中，我们将位向右移位，并将0置于最高位。它由 <code>&gt;&gt;&gt;</code> 运算符表示。对于8位整数（符号位是最高位）上，这将如下图所示。符号位用灰色背景表示。</p>
<div align=center><img src="img/ch5_4.png"/></div>
在算术右移中，我们将值向右移动，但用符号位的值填充空出的新位。
<p>这（大致）具有除以 2 的效果。它由 <code>&gt;&gt;</code> 运算符表示。</p>
<div align=center><img src="img/ch5_5.png"/></div>
参数为 x=-93242 和 count=40 时，你觉得这些函数的运行结果会是什么？
<pre><code class="language-java">1 	int repeatedArithmeticShift(int x, int count) {
2 		for (int i = 0; i &lt; count; i++) {
3 			x &gt;&gt;= 1; // Ar ith met ic shift by 1
4		}
5 		return x;
6	}
7
8 	int repeatedLogicalShift( int x, int count) {
9 		for (int i = 0; i &lt; count; i++) {
10 			x &gt;&gt;&gt;= 1; // Logical shift by 1
11		}
12 		return x;
13	}
</code></pre>
<p>逻辑移位操作下，我们最终会得到 0，因为我们不断地把 0 移到最高位上。</p>
<p>算术移位操作下，我们会得到 -1，因为我们不断地把 1 移到最高位上。一个全部由 1 组成的序列若指的是（带符号）整数，则其表示 -1。</p>
<h3 id="常见的位操作方法getting-和-setting"><a class="header" href="#常见的位操作方法getting-和-setting">常见的位操作方法：Getting 和 Setting</a></h3>
<p>以下操作非常重要，但不要只是简单地记住它们。死记硬背只会导致你犯无法弥补的错误。相反，要理解如何实现这些方法，以便你可以解决这些以及其他的位操作问题。</p>
<h4 id="get-bit"><a class="header" href="#get-bit">Get Bit</a></h4>
<p>此方法将 1 向左移位 i 位，创建一个类似于 00010000 的值。通过将前面得到的结果与 num 执行按位与（AND）操作，我们清除了 num 中除了第 i 位之外的所有位。最后，我们将其与 0 进行比较。如果结果不为零，则第 i 位必须为 1。不然则为0。</p>
<pre><code class="language-java">1 	boolean getBit(int num, int i) {
2 		return ((num &amp; (1 &lt;&lt; i)) != 0);
3 	}
</code></pre>
<h4 id="set-bit"><a class="header" href="#set-bit">Set Bit</a></h4>
<p>setBit 方法将 1 向左移位 i 位，创建一个类似于 00010000 的值。通过将前面得到的结果与 num 执行按位或（OR）操作，只有第 i 位的值才会改变。掩码（mask）的其他所有位都是零，因此按位或操作时不会影响 num 上其他各位的值。</p>
<pre><code class="language-java">1 	int setBit(int num, int i) {
2 		return num | ( 1 &lt;&lt; i);
3 	}
</code></pre>
<h4 id="clear-bit"><a class="header" href="#clear-bit">Clear Bit</a></h4>
<p>该方法几乎与 setBit 相反。首先，我们创建一个像 11101111 这样的数字，具体操作是通过创建它的倒数（00010000）并对其进行取反运算。然后，我们将其与 num 执行按位与（AND）。这将清除第 i 位，其余部分保持不变。</p>
<pre><code class="language-java">1 	int clearBit(int num, int i) {
2 		int mask = ~(1 &lt;&lt; i);
3 		return num &amp; mask;
4 	}
</code></pre>
<p>为了从最高有效位（most significant bit）到第 i 位（包括 i）清除所有位，我们在第 i 位创建一个1的掩码（1 &lt;&lt; i）。然后，我们将其减去 1，得到一个由 0 组成的序列，并且后面跟着 i 个 1。然后我们用这个掩码和 num 执行按位与（AND），最终只留下最后的 i 位。</p>
<pre><code class="language-java">1 	int clearBitsMSBthroughI(int num, int i) {
2 		int mask = (1 &lt;&lt; i) - 1;
3 		return num &amp; mask;
4 	}
</code></pre>
<p>要清除从第 i 位到第 0 位（包括0）的所有位，我们采用全部由 1 组成的序列（即-1），并将其向左移位 i + 1 位。我们得到一个由 1 组成的序列（在最高有效位上都是 1），并且后面跟着 i 个 0。</p>
<pre><code class="language-java">1 	int clearBitsithrough0(int num, int i) {
2 		int mask = (-1 &lt;&lt; (i + 1));
3 		return num &amp; mask;
4 	}
</code></pre>
<h4 id="update-bit"><a class="header" href="#update-bit">Update Bit</a></h4>
<p>要将第 i 位设置为值 v，我们首先使用看起来像 11101111 的掩码清除第 i 位的值。然后，我们将预期值 v，左移 i 位。这将创建一个第 i 位等于 v，其他位所有为0的数字。最后，我们对这两个数字进行按位或（OR）运算，如果 v为 1 则更新第 i 位，否则保持它为0。</p>
<pre><code class="language-java">1 	int updateBit(int num, int i, boolean bitIs1) {
2 		int value = bitIs1 ? 1 : 0;
3 		int mask = ~(1 &lt;&lt; i);
4 		return (num &amp; mask) | (value &lt;&lt; i);
5 	}
</code></pre>
<hr />
<h3 id="interview-questions-5"><a class="header" href="#interview-questions-5">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>5.1 插入（Insertion）</strong>：给定两个 32 位数字 N 和 M，以及两个位置 i 和 j。编写一个将 M 插入 N 的方法，使 M 从 N 的第 j 位开始插入，到第 i 位结束。你可以假定 j 到 i 位有足够的空间来容纳所有 M。也就是说，如果 M = 10011，则可以假定 j 和 i 之间至少有 5 位。例如，不会给你 j = 3 和 i = 2，因为 M 不能全部放到第 3 位和第 2 位之间。</p>
<p>EXAMPLE</p>
<pre><code>Input: N = 10000000000, M = 10011, i = 2, j = 6
Output: N = 10001001100
</code></pre>
<p><em>提示：#137, #769, #215</em></p>
</li>
<li>
<p><strong>5.2 二进制到字符串（Binary to String）</strong>：给定一个在 0 和 1 之间的实数（例如 0.72）并以 double 类型传入参数，打印出它的二进制表示形式。如果这个数字不能用最多 32 个字符的二进制形式表示，就打印 “ERROR”。</p>
<p><em>提示：#743, #767, #773, #269, #297</em></p>
</li>
<li>
<p><strong>5.3 翻转位取胜（Flip Bit to Win）</strong>：给定有一个整数，你可以将 <code>0</code> 变成到 <code>1</code> ，正好翻转一位。编写代码来查找你可以创建的最长的由数字 <code>1</code> 组成的序列的长度。</p>
<p><strong>5.3翻转位以赢得</strong>:你有一个整数，你可以将 <code>0</code> 变成到 <code>1</code> 正好翻转一位。编写代码来查找你可以创建的最长的由数字 <code>1</code> 组成的序列的长度。</p>
<p>EXAMPLE</p>
<pre><code>Input: 1775 (or: 11011101111)
Output: 8
</code></pre>
<p><em>提示：#759, #226, #374, #352</em></p>
</li>
<li>
<p><strong>5.4 下一个数字（Next Number）</strong>：给定一个正整数，打印下一个最小的数字和下一个最大的数字，满足它们的二进制表示中 <code>1</code> 的位数相同。</p>
<p><em>提示：#747, #7 75, #242, #372, #339, #358, #375, #390</em></p>
</li>
<li>
<p><strong>5.5 调试器（Debugger）</strong>：解释以下代码的作用：((n &amp; (n-1)) == 0)。</p>
<p><em>提示：#757, #202, #267, #302, #346, #372, #383, #398</em></p>
</li>
<li>
<p><strong>5.6 转换（Conversion）</strong>：编写一个函数，以确定需要翻转多少位才能将整数 A 转换为整数 B。</p>
<p><strong>5.6转换</strong>:编写一个函数，以确定需要翻转多少位才能将整数 A 转换为整数 B。</p>
<p>EXAMPLE</p>
<pre><code>Input: 29 (or: 11101), 15 (or: 01111)
Output: 2
</code></pre>
<p><em>提示：#336, #369</em></p>
</li>
<li>
<p><strong>5.7 成对交换（Pairwise Swap）</strong>：编写一个程序，用尽可能少的指令交换整数中的奇数位和偶数位（例如，交换第 0 位和第 1 位，交换第 2 位和第 3 位，依此类推）。</p>
<p><em>提示：#745, #248, #328, #355</em></p>
</li>
<li>
<p><strong>5.8 画线（Draw Line）</strong>：一个黑白屏幕被存储为单个字节数组，允许将 8 个连续像素存储在一个字节中。 屏幕的宽度为 w，其中 w 可被 8 整除（也就是说，没有字节将被跨行分割）。当然，屏幕的高度可以从数组的长度和宽度推算出。实现一个从 (x1,  y) 到 (x2,  y) 画一条水平线的函数。</p>
<p>方法签名应类似于：</p>
<pre><code class="language-java">drawline(byte[] screen, int width, int x1, int x2, int y)
</code></pre>
<p><em>提示：#366, #387, #384, #397</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：数组和字符串(#1.1, #1.4, #1.8)，数学和逻辑难题(#6.10)，递归(#8.4, #8.14)，排序和搜索(#10.7, #10.8)，c++(#12.10)，中等问题(#16.1, #16.7)，困难问题(#17.1)。</p>
<p>提示从第 662 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6--数学和逻辑难题"><a class="header" href="#chapter-6--数学和逻辑难题">Chapter 6 | 数学和逻辑难题</a></h1>
<p>所谓的“智力题”（或脑筋急转弯）是最受争议的问题，许多公司都有禁止使用它们的政策。不幸的是，即使禁止了这些问题，你仍然可能会被问到其中之一。为什么？ 因为没有人可以就脑筋急转弯的定义达成共识。</p>
<p>好消息是，如果你被问到一个智力题或脑筋急转弯，它可能是一个相当公平的问题。它可能不会依赖于措辞技巧，而且几乎总是可以从逻辑上推导出来。许多人拥有数学或计算机科学的基础，而且几乎所有人的解决方案都可以从逻辑上推导出来。</p>
<p>我们将通过一些常见的方法以及一些基本的知识，来解决这些问题。</p>
<h3 id="质数"><a class="header" href="#质数">质数</a></h3>
<p>你可能知道，每个正整数都可以分解成质数的乘积。例如：</p>
<div align=center><img src="img/ch6_1.png"/></div>
注意，许多质数的指数都是 0。
<h4 id="可除性"><a class="header" href="#可除性">可除性</a></h4>
<p>上面提到的质数定律意味着，为了使数字 x 能整除数字 y（写成 x\y，或mod(y, x) = 0），x 的质因数分解中的所有质数都必须在 y 的质因数分解中。或者，更具体地说：</p>
<div align=center><img src="img/ch6_2.png"/></div>
实际上，x 和 y 的最大公约数是：
<div align=center><img src="img/ch6_3.png"/></div>
x 和 y 的最小公倍数为：
<div align=center><img src="img/ch6_4.png"/></div>
作为一个有趣的练习，停下来想一下如果使 gcd * lcm，会发生什么：
<div align=center><img src="img/ch6_5.png"/></div>
<div align=center><img src="img/ch6_6.png"/></div>
#### 检查质数
<p>这个问题很常见，我们觉得有必要专门讨论一下。简单的方法是从 2 到 n-1 进行迭代，在每次迭代中检查可除性。</p>
<pre><code class="language-java">1 	boolean primeNaive(int n) {
2 		if (n &lt; 2) {
3 			return false;
4 		}
5 		for (int i = 2; i &lt; n; i++) {
6 			if (n % i == 0) {
7 				return false;
8 			}
9 		}
10 		return true;
11 	}
</code></pre>
<p>一个小但重要的改进是只迭代到根号 n。</p>
<pre><code class="language-java">1 	boolean primeSlightlyBetter(int n) {
2 		if (n &lt; 2) {
3 			return false;
4 		}
5 		int sqrt = (int) Math.sqrt(n);
6 		for (int i = 2; i&lt;= sqrt; i++) {
7 			if (n % i == 0) return false; 
8 		}
9 		return true;
10 	}
</code></pre>
<p>用根号 n 就足够了，因为对于每一个能整除 n 的数 a，都有一个补数 b，其中 a * b = n。如果 a &gt; 根号 n ，那么 b &lt; 根号 n  （因为 (根号 n )^2 = n ）。因此我们不需要 a 来检验 n 的质数，因为我们已经用 b 检验过了。</p>
<p>当然，实际上，我们真正需要做的就是检查 n 是否可以被质数整除。这就是埃拉托色尼筛（the Sieve of Eratosthenes）的作用。</p>
<h4 id="生成质数列表埃拉托色尼筛the-sieve-of-eratosthenes"><a class="header" href="#生成质数列表埃拉托色尼筛the-sieve-of-eratosthenes">生成质数列表：埃拉托色尼筛（The Sieve of Eratosthenes）</a></h4>
<p>Eratosthenes 筛法是生成质数列表的一种高效方法。它的原理是认识到所有非质数都能被一个质数整除。</p>
<p>我们首先列出所有数字，直到某个最大值为止。首先，我们划掉所有能被 2 整除的数。然后，我们寻找下一个质数（下一个未划去的数），并划去所有能被它整除的数。通过划去所有能被 2、3、5、7、11 等整除的数，我们得到了一个从 2 到最大值的质数列表。</p>
<p>下面的代码实现了 Eratosthenes 筛。</p>
<pre><code class="language-java">1 	boolean[] sieveOfEratosthenes(int max) {
2 		boolean[] flags = new boolean[max + 1];
3 		int count = 0;
4
5 		init(flags); // Set all flags to true other than 0 and 1
6 		int prime = 2;
7 
8 		while (prime &lt;= Math.sqrt(max)) {
9 			/* Cross off remaining multiples of prime */
10 			crossOff(flags, prime);
11
12 			/* Find next value which is true */
13 			prime = getNextPrime(flags, prime);
14 		}
15 
16 		return flags;
17 	}
18
19 	void crossOff(boolean[] flags, int prime) {
20 		/* Cross off remaining multiples of prime. We can start with (prime*prime),
21 		 * because if we have a k * prime, where k &lt; prime, this value would have
22 		 * already been crossed off in a prior iteration. */
23 		for (int i = prime * prime; i &lt; flags.length; i += prime) {
24 			flags[i] = false;
25 		}
26 	}
27
28 	int getNextPrime(boolean[] flags, int prime) { 
29 		int next = prime + 1;
30 		while (next &lt; flags.length &amp;&amp; !flags[next]) { 
31 			next++;
32 		}
33 		return next;
34 	}
</code></pre>
<p>当然，可以对此进行许多优化。一种简单的方法是仅在数组中使用奇数，这将使我们可以将空间使用量减少一半。</p>
<h3 id="概率"><a class="header" href="#概率">概率</a></h3>
<p>概率可能是一个复杂的话题，但是它基于一些可以从逻辑上推导的基本定律。</p>
<p>让我们看一个维恩图来形象化两个事件 A 和 B。两个圆的面积表示它们的相对概率，重叠的区域是事件{A and B}。</p>
<div align=center><img src="img/ch6_7.png"/></div>
#### A and B 的概率
<p>想象一下，你正对着这个维恩图掷飞镖。落在 A 和 B 重叠区域处的概率是多少？如果你知道落在 A 点的概率，并且你也知道 A 在 B 上的百分率（也就是说，在你落在A点的情况下，同时落在B点的概率），那么可以将概率表示为：</p>
<pre><code>P(A and B) = P(B given A) P(A)
</code></pre>
<p>例如，假设我们正在选择一个介于 1 到 10（包括 10）之间的数字。选择的数字既是偶数又是一个介于 1 和 5 之间的数字的概率是多少？选择一个介于 1 和 5 之间的数字的概率是 50％，而 1 和 5 之间的数字是偶数的概率是 40%。因此，两者都是的概率是：</p>
<pre><code>P(x is even and x &lt;= 5)
	= P(x is even given x &lt;= 5) P(x &lt;= 5) 
	= (2/5) * (1/2)
	= 1/5
</code></pre>
<p>请注意，由于 <code>P(A and B) = P(B given A) P(A) = P(A given B) P(B)</code>，因此可以用相反的形式表示 <code>A given B</code> 的概率：</p>
<pre><code>P(A given B) = P(B given A) P(A) / P(B) 
</code></pre>
<p>上面的方程叫做贝叶斯定理。</p>
<h4 id="a-or-b-的概率"><a class="header" href="#a-or-b-的概率">A or B 的概率</a></h4>
<p>现在，假设你想要知道落在 <code>A or B</code> 上的概率是多少。如果你知道单独落在 A、B 每个上面的概率，你也知道落在覆盖区域概率，那么可以将概率表示为：</p>
<pre><code>P(A or B) = P(A) + P(B) - P(A and B)
</code></pre>
<p>从逻辑上讲，这是有道理的。如果我们简单地把它们的大小相加，我们就会重复计算它们的交集。因此我们需要减去这个重复相加的部分。可以再次通过维恩图来形象化：</p>
<div align=center><img src="img/ch6_8.png"/></div>
例如，假设我们正在选择一个介于 1 到 10（包括 10）之间的数字。选择的数字是偶数，或者是一个介于 1 和 5 之间的数字的概率是多少？我们选择一个偶数的概率为50％，选择一个介于 1 和 5 之间的数字的概率是 50％。两者都做的概率是20％。因此，概率是：
<pre><code>P(x is even or x &lt;=5)
	= P(x is even)+ P(x &lt;= 5) - P(x is even and x &lt;= 5)
	= 1/2 + 1/2 - 1/5
	= 4/5
</code></pre>
<p>从这里，获取独立事件和互斥事件的特殊情况规则很容易。</p>
<h4 id="独立"><a class="header" href="#独立">独立</a></h4>
<p>如果 A 和 B 是独立的（也就是说，一个事件发生不能代表另一事件的发生），则 <code>P(A and B) = P(A) P(B)</code>。这个规则简单地来自于认识到 <code>P(B given A) = P(B)</code>，因为 A 并不代表 B。</p>
<h4 id="互斥"><a class="header" href="#互斥">互斥</a></h4>
<p>如果 A 和 B 是互斥的（也就是说，如果一个发生，那么另一个就不会发生），则 <code>P(A or B) = P(A) + P(B)</code>。这是因为 <code>P(A and B) = 0</code>，所以这一项从先前的<code>P(A or B)</code> 方程中去掉了。</p>
<p>奇怪的是，许多人混淆了独立和互斥的概念。他们是完全不同的。实际上，两个事件不能既独立又互斥（假设两个概率都大于0）。为什么？因为互斥性意味着如果一个发生，那么另一个就不会发生。然而，独立性表示一个事件的发生完全与另一个事件无关。因此，只要两个事件的概率为非零，它们就永远不会相互排斥和独立。</p>
<p>如果一个事件或两个事件的概率为零（即不可能），那么这两个事件就既是独立的又是互斥的。这可以通过简单应用独立性和互斥性的定义（即公式）来证明。</p>
<h3 id="开始交谈"><a class="header" href="#开始交谈">开始交谈</a></h3>
<p>遇到脑筋急转弯时不要惊慌。就像算法问题一样，面试官想知道你是如何解决问题的，他们不希望你立即知道答案。开始交谈，向面试官展示你是如何解决问题的。</p>
<h3 id="开发规则和模式"><a class="header" href="#开发规则和模式">开发规则和模式</a></h3>
<p>在许多情况下，你会发现在解决问题时写下“规则”或模式是很有用的。是的，你确实应该把这些写下来——它会帮助你在解题时记住它们。让我们通过一个例子来演示这种方法。</p>
<p>你有两根绳子，每根都需要一个小时来燃烧。你将如何使用它们来精确地计时 15 分钟？注意，绳子的密度是不均匀的，所以绳子长度的一半不一定需要半个小时来燃烧。</p>
<blockquote>
<p>提示：到此为止，花点时间尝试自己解决这个问题。如果绝对必须，请通读本节以获得提示——但是要慢慢读。每一段都会让你更接近答案。</p>
</blockquote>
<p>从问题的陈述中，我们立即知道我们可以计时一小时。我们还可以计时两个小时，点燃一根绳子，等它烧完，然后点燃另一根。可以将其概括为一条规则。</p>
<p><em>规则1</em>：给定一根绳子燃烧需要 x 分钟，另一根需要 y 分钟，我们可以计时 x+y 分钟。</p>
<p>我们还能用绳子做什么？我们可能会认为，在绳子的中间（或除绳子末端以外的任何地方）点燃一根绳子不会对我们有什么好处。火焰会向两个方向蔓延，我们不知道燃烧需要多长时间。</p>
<p>然而，我们可以在两头点燃一根绳子。两束火焰将在 30 分钟后汇合。</p>
<p><em>规则2</em>：给定一根燃烧 x 分钟的绳子，我们可以计时 x/2 分钟。</p>
<p>现在，我们知道可以用一根绳子计时 30 分钟。这也意味着我们可以从第二根绳子上减少 30 分钟的燃烧时间，方法是从两端点燃绳 1，从一端点燃绳 2。</p>
<p><em>规则3</em>：如果绳 1 燃烧需要 x 分钟，绳 2 需要 y 分钟，我们可以把绳 2 变成一根燃烧时间为 (y - x) 分钟或 (y - x/2) 分钟的绳子。</p>
<p>现在，让我们将所有这些拼在一起。我们可以将绳 2 变成燃烧时间为 30 分钟的绳子。如果然后在另一端点燃绳 2（请参阅规则 2），则绳 2 将在 15 分钟后燃烧完成。</p>
<p>从头到尾，我们的方法如下：</p>
<ol>
<li>从两端点燃绳 1，从一端点燃绳 2。</li>
<li>当绳 1 上的两个火焰相遇时，30 分钟已经过去了。绳 2 的燃烧时间还剩 30 分钟。</li>
<li>此时，在另一端点燃绳 2。</li>
<li>在恰好 15 分钟后，绳 2 将全部烧完。</li>
</ol>
<h3 id="最坏情况转换"><a class="header" href="#最坏情况转换">最坏情况转换</a></h3>
<p>许多脑筋急转弯是使最坏情况最小化的问题（worst-case minimization problems），要么是最小化一个动作，要么是在做某件事时最多执行特定次数。一个有用的技巧是尝试“平衡”最坏的情况。也就是说，如果早期的决定导致最坏情况的发生，我们有时可以更改决策以平衡最坏情况。用一个例子来解释就最清楚不过了。</p>
<p>“九球”问题是一个经典的面试问题。你有九个球。八个重量相同，一个较重。你会得到一个天平，它只告诉你左边或右边哪个更重。仅秤两次，找出较重的球。</p>
<p>第一种方法是将球分成四个一组，第九个球放在一边。较重的球在较重的那一组中。如果它们的重量相同，那么我们就知道第九个球是较重的那个。对其余的组重复此方法将导致最坏的情况，即需要称重三次——多了一次！</p>
<p>在最坏的情况下，这是一种不平衡：第九个球只需要一次称重就可以发现它是否较重，而其他的球则需要称重三次。如果我们通过将更多的球放在一边来惩罚第九球，我们可以减轻其他球的负担。这是一个“平衡最坏情况（worst case balancing）”的例子。</p>
<p>如果我们把这些球分成三组，每组三个，我们就会知道哪组球重。我们甚至可以把它形式化为一个<em>规则</em>：给定 N 个球，其中 N 能被 3 整除，仅称一次就能使我们找到带有较重球的那 X/3 个球。</p>
<p>对于最后一组三个球，我们只需重复以下步骤：将一个球放到一边，然后称重两个。选择两者中较重的一个。或者，如果球的重量相同，则选择第三个。</p>
<h3 id="算法的方法"><a class="header" href="#算法的方法">算法的方法</a></h3>
<p>如果你卡住了，可以考虑使用解决算法问题的其中一种方法来解决（从第 67 页开始）。脑筋急转弯通常只是去掉了技术方面的算法问题。Base Case 、Build 和 Do It Yourself (DIY) 这几部分的内容很有用。</p>
<p><strong>Additional Reading</strong>： Useful Math (pg 629).</p>
<hr />
<h3 id="interview-questions-6"><a class="header" href="#interview-questions-6">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>6.1 重药丸（The Heavy Pill）</strong>：你有20瓶药片。19个瓶子里装的是 1.0 克的药片，但是一个瓶子里装的是 1.1 克的药片。给你一个可以精确测量的天平，你怎么找到这个较重的瓶子?</p>
<p>你只能使用一次天平。</p>
<p><em>提示：#186, #252, #319, #387</em></p>
</li>
<li>
<p><strong>6.2 篮球（Basketball）</strong>：你有一个篮球框，并被告知你可以玩以下两种游戏的其中之一。</p>
<p>游戏 1：你只有一次投篮的机会。</p>
<p>游戏 2：你有三次投篮的机会，但是在这三次中你必须投中的两次。</p>
<p>如果 p 是一次投篮投中的概率，那么 p 的值在哪个范围的时候你应该选游戏 1，什么时候你应该选游戏 2？</p>
<p><em>提示：#787, #239, #284, #323</em></p>
</li>
<li>
<p><strong>6.3 多米诺骨牌（Dominos）</strong>：有一个 8x8 的国际象棋棋盘，其中从一个对角线挖去两个格子。给定 31 个多米诺骨牌，且一个多米诺骨牌恰好可以覆盖两个格子。你可以使用这 31 个多米诺骨牌覆盖整个棋盘吗？ 证明你的答案（通过提供示例或说明为什么它是不可能的）。</p>
<p><em>提示：#367, #397</em></p>
</li>
<li>
<p><strong>6.4 三角形上的蚂蚁（Ants on a Triangle）</strong>：三角形的不同顶点上有三只蚂蚁。如果它们开始沿着三角形的边走，发生碰撞的概率是多少？假设每只蚂蚁随机选择一个方向，任意一个方向被选择的可能性都相同，并且它们以相同的速度行走。</p>
<p>类似地，求 n 个顶点多边形上 n 个蚂蚁碰撞的概率。</p>
<p><em>提示：#157, #195, #296</em></p>
</li>
<li>
<p><strong>6.5 水壶（Jugs of Water）</strong>：你有一个 5 夸脱的水壶，一个 3 夸脱的水壶，以及不限量的水（但没有量杯）。你将如何精确得到 4 夸脱的水？ 请注意，水壶的形状很奇怪，以至于不可能精确地填满水壶的“一半”。</p>
<p><em>提示：#149, #379, #400</em></p>
</li>
<li>
<p><strong>6.6 蓝眼睛的岛（Blue-Eyed Island）</strong>：一群人住在一个岛上，当一个访客带着一个奇怪的命令来了：所有的蓝眼睛的人必须尽快离开这个岛。每天晚上 8 点将有一个航班起飞。每个人都能看到别人眼睛的颜色，但他们不知道自己眼睛的颜色（也不允许任何人告诉他们）。此外，他们不知道有多少人有蓝眼睛，尽管他们知道至少有一个人有。这些蓝眼睛的人需要多少天才能离开?</p>
<p><em>提示：#278, #282, #341, #370</em></p>
</li>
<li>
<p><strong>6.7 世界末日（The Apocalypse）</strong>：在新的末日世界中，世界女王非常关心出生率。因此，她下令所有家庭必须确保他们有一个女孩，否则他们将面临巨额罚款。如果所有的家庭都遵守这一政策，也就是说，他们必须继续生孩子，直到他们有了一个女孩，在那一刻他们立即停止，那么新一代的性别比例会是多少？（假设某人在某一次怀孕中生男孩或女孩的几率是相等的。）从逻辑上解决问题，然后对其进行计算机模拟。</p>
<p><em>提示：#154, #760, #171, #788, #201</em></p>
</li>
<li>
<p><strong>6.8 鸡蛋掉落问题（The Egg Drop Problem）</strong>：有一栋100层的建筑物。如果鸡蛋从第 N 层或以上掉落，它将破裂。如果它从下面的任何一层掉下来，它都不会破裂。给定两个鸡蛋。请找到这个楼层 N，同时要保证次策略在最坏的情况下所扔次数最少。</p>
<p><em>提示：#756, #233, #294, #333, #357, #374, #395</em></p>
</li>
<li>
<p><strong>6.9 100 个储物柜（100 Lockers）</strong>：走廊中有 100 个封闭的储物柜。一个人首先打开所有 100 个储物柜。接下来，他在每 2 个储物柜处将当前的关闭。然后，在第三次通过时，他会在每 3 个储物柜处切换当前储物柜的开关状态（如果储物柜是打开的，则将其关闭；如果储物柜是关闭的，则将其打开）。这个过程将持续 100 次，这样，在每 i 次通过走廊时，这个人就会在每 i 个储物柜处切换当前的状态。当他的第 100 次通过走廊后，他只切换了第 100 个储物柜，请问当前还有多少储物柜是开着的？</p>
<p><em>提示：#139, #172, #264, #306</em></p>
</li>
<li>
<p><strong>6.10 有毒（Poison）</strong>：你有 1000 瓶苏打水，而其中有一瓶是有毒的。你有 10 张可以用来检测毒素的试纸。一滴毒药就会使试纸永久呈阳性。你可以一次在试纸上滴任意数量的液滴，并且可以根据需要多次重复使用测试条（只要结果呈阴性）。但是，你每天只能测试一次，并且需要 7 天才能返回结果。你如何用最少的时间找出有毒的那瓶水？</p>
<p>FOLLOW UP</p>
<p>编写代码来模拟你的方法。</p>
<p><em>提示：#146, #163, #183, #191, #205, #221, #230, #241, #249</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：中等问题(#16.5)，困难问题(#17.19)。</p>
<p>提示从第 662 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7--面向对象的设计"><a class="header" href="#chapter-7--面向对象的设计">Chapter 7 | 面向对象的设计</a></h1>
<p>面向对象（Object-oriented）的设计问题要求候选人能草拟出实现技术问题或现实对象的类和方法。这些问题会让面试官对你的编码风格有一个深入的了解。</p>
<p>这些问题与其说是关于重复设计模式，不如说是关于说明您了解如何创建优雅的、可维护的面向对象代码。在这类问题上的糟糕表现可能会引发严重的危险信号（red flag）。</p>
<h3 id="如何处理"><a class="header" href="#如何处理">如何处理</a></h3>
<p>无论对象是物理项还是技术任务，都可以用类似的方法处理面向对象的设计问题。下面的方法可以很好地解决许多问题。</p>
<h4 id="步骤1处理歧义"><a class="header" href="#步骤1处理歧义">步骤1：处理歧义</a></h4>
<p>面向对象设计（OOD）问题通常是有意含糊不清的，以便测试你是否会做出假设，或者是否会要求澄清问题。 毕竟，如果一个开发人员只是编写代码，而不理解她所期望创建的内容，将浪费公司的时间和金钱，并有可能会产生更严重的问题。</p>
<p>当被问及面向对象的设计问题时，你应该询问谁将使用它（who）以及它们将如何使用它（how）。根据实际问题，你甚至可以通过“六个W”来澄清，即：who、what、where、when、how、why。</p>
<p>例如，假设你被要求描述一个咖啡机的面向对象设计。这看起来很简单，对吧？ 实则并不完全是这样。</p>
<p>你的咖啡机可能是一台工业机器，设计用于大型餐厅，每小时为数百名顾客提供服务，并制作十种不同类型的咖啡产品。或者它可能是一台非常简单的机器，专为老年人设计用于制作简单的黑咖啡。这些用例将显著影响你的设计。</p>
<h4 id="步骤2定义核心对象"><a class="header" href="#步骤2定义核心对象">步骤2：定义核心对象</a></h4>
<p>既然我们已经理解了我们在设计什么，那么我们应该考虑系统中的“核心对象”是什么。例如，假设我们被要求为一家餐厅进行面向对象的设计。我们的核心对象可能是诸如 Table、Guest、Party、Order、Meal、Employee、Server 和 Host 之类的东西。</p>
<h4 id="步骤3分析关系"><a class="header" href="#步骤3分析关系">步骤3：分析关系</a></h4>
<p>或多或少地确定了我们的核心对象之后，我们现在要分析对象之间的关系。 哪些对象是其他对象的成员？是否有对象从其他对象继承？关系是多对多还是一对多？</p>
<p>例如，在餐厅（Restaurant）问题中，我们可能会提出以下设计：</p>
<ul>
<li>Party 上应该有很多 Guest。</li>
<li>Server 和 Host 继承自 Employee。</li>
<li>每个 Table 都只有一个 Party，但是每个 Party 可以有多个 Table 。</li>
<li>该 Restaurant 只有一个 Host 。</li>
</ul>
<p>在这里要非常小心——你可能会很容易做出错误的假设。例如，一张 Table 可能有多个 Party （在一些餐厅前卫的“公共餐桌”中很常见）。你应该跟你的面试官确认需要将设计做到何种通用程度。</p>
<h4 id="步骤4探究对象的行为"><a class="header" href="#步骤4探究对象的行为">步骤4：探究对象的行为</a></h4>
<p>此时，你应该已经有了你面向对象的设计的基本轮廓。剩下的就是考虑对象将采取的关键行为（key actions）以及它们之间是如何相互关联的。你可能会发现之前遗漏了一些对象，因此将需要更新设计。</p>
<p>例如，一群人（Party）走进餐厅（Restaurant），其中一位顾客（Guest）向主人（Host）要了一张桌子（Table）。主人（Host）查看预定单（Reservation），如果存在预订，则给这群人（Party）分配给一张桌子（Table）。否则，这群客人（Party）将被添加到列表的末尾。当一组客人（Party）离开时，桌子（Table）被释放并分配给列表中的新的一群人（Party） 。</p>
<h3 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h3>
<p>因为面试官想测试的是你的能力而不是你的知识，所以设计模式大多超出了面试的范围。然而，单例（Singleton）和工厂方法（Factory Method）设计模式在面试中经常会被用到，所以我们将在此简单做下介绍。</p>
<p>实际上设计模式的种类比本书可能会提及的要多得多。如果你想提高这方面的软件工程技能的，最好还是法是挑选一本专门针对这个领域的书。</p>
<p>要小心，不要陷入不断尝试为特定问题找到“正确”设计模式的陷阱。你应该创建适用于该问题的设计。在某些情况下，它可能是一个既定的设计模式，但在许多其他情况下则不是。</p>
<h4 id="单例类"><a class="header" href="#单例类">单例类</a></h4>
<p>单例模式（Singleton pattern）确保一个类只有一个实例，并确保通过应用程序访问该实例。如果你有一个只有一个实例的“全局”对象，它可能非常有用。例如，我们可以向下面这样实现 Restaurant类，使它只有一个 Restaurant 类的实例。</p>
<pre><code class="language-java">1 	public class Restaurant {
2 		private static Restaurant _instance = null;
3 		protected Restaurant() { ... }
4 		public static Restaurant getlnstance() {
5 			if (_instance == null) {
6 				_instance = new Restaurant();
7 			}
8 			return _instance;
9 		}
10 	}
</code></pre>
<p>应该指出的是，许多人不喜欢单例设计模式，甚至称它为“反模式（anti-pattern）”。其中一个原因是它可能会干扰单元测试。</p>
<h4 id="工厂方法"><a class="header" href="#工厂方法">工厂方法</a></h4>
<p>工厂方法（Factory Method）提供了一个用于创建类实例的接口，其子类决定实例化哪个类。 你可以在 Creator 类是抽象类的情况下实现此操作，而无需为工厂方法提供实现。或者，你可以将 Creator 类作为具体类，并为工厂方法提供实现。在这种情况下，工厂方法将接受一个参数，该参数表示要实例化哪个类。</p>
<pre><code class="language-java">1 	public class CardGame {
2 		public static CardGame createCardGame(GameType type) {
3 			if (type == GameType.Poker) {
4 				return new PokerGame();
5 			} else if (type == GameType.BlackJack) {
6 				return new BlackJackGame();
7 			}
8 			return null;
9 		}
10 	}
</code></pre>
<hr />
<h3 id="interview-questions-7"><a class="header" href="#interview-questions-7">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>7.1 牌组（Deck of Cards）</strong>：设计一个普通牌组的数据结构。解释如何使用这个数据结构来实现二十一点（blackjack）。</p>
<p><em>提示：#753, #275</em></p>
</li>
<li>
<p><strong>7.2 呼叫中心（Call Center）</strong>：假设你有一个呼叫中心，员工分为三级：接线员，经理和主管。打进来的电话必须首先分配给有空的接线员。如果接线员不能处理呼叫，他或她必须将这个呼叫提交给经理。如果经理没有空闲或不能处理此呼叫，则应将此呼叫上升到主管那里。为这个问题设计类和数据结构。实现方法 dispatchCall()，该方法将呼叫分配给第一个可用的员工。</p>
<p><em>提示：#363</em></p>
</li>
<li>
<p><strong>7.3 点唱机（Jukebox）</strong>：使用面向对象的原则设计一个音乐点唱机。</p>
<p><em>提示：#798</em></p>
</li>
<li>
<p><strong>7.4 停车场（Parking Lot）</strong>：使用面向对象原则设计一个停车场。</p>
<p><em>提示：#258</em></p>
</li>
<li>
<p><strong>7.5 在线图书阅读器（Online Book Reader）</strong>：设计在线图书阅读器系统的数据结构。</p>
<p><em>提示：#344</em></p>
</li>
<li>
<p><strong>7.6 拼图（Jigsaw）</strong>：实现一个 NxN 拼图。设计数据结构，并说明完成拼图的算法。你可以假定你有一个 fitsWith 方法，该方法在传递两个拼图边缘时，如果两个边缘属于同一边，则返回 true。</p>
<p><em>提示：#192, #238, #283</em></p>
</li>
<li>
<p><strong>7.7 聊天服务器（Chat Server）</strong>：说明如何设计一个聊天服务器。特别是，提供关于各种后端组件、类和方法的详细信息。最难解决的问题是什么？</p>
<p><em>提示：#213, #245, #271</em></p>
</li>
<li>
<p><strong>7.8 奥赛罗（Othello）</strong>：奥赛罗的玩法如下：奥赛罗的每一块棋子都是一面白，另一面黑。当一个棋子的左右两边或上下两面都被对手包围时，我们就说它被抓到了，并且其颜色要被翻转。轮到你时，你必须抓到对手的至少一个棋子。当任一用户没有更多有效动作时，游戏结束。得分最高的人获胜。基于面向对象的原则设计实现奥赛罗。</p>
<p><em>提示：#179, #228</em></p>
</li>
<li>
<p><strong>7.9 环形数组（Circular Array）</strong>：实现一个 CircularArray 类，它支持一种类似数组数据结构，以实现高效的旋转。如果可能，该类应该使用泛型类型（也称为模板），并支持以 <code>for (Obj o: circularArray)</code> 的方法实现迭代。</p>
<p><em>提示：#389</em></p>
</li>
<li>
<p><strong>7.10 扫雷（Minesweeper）</strong>：设计并实现一个基于文本的扫雷游戏。扫雷是一个经典的单机游戏，在一个 NxN 的网格中隐藏着 B 枚地雷（或炸弹）。其余单元格要么是空白的，要么后面有数字。这些数字反映了周围八个单元中的炸弹数量。然后用户打开一个单元格。如果是炸弹，玩家就输了。如果它是一个数字，则显示该数字。如果它是一个空白单元格，那么这个单元格和所有相邻的空白单元格（直到并包括周围的数字单元格）都将显示出来。当所有非炸弹单元格都暴露出来后，玩家就获胜了。玩家还可以将某些地方标记为潜在炸弹。这不会影响游戏，除了能阻止用户不小心点击一个被认为有炸弹的单元格。（给读者的提示：如果你不熟悉此游戏，请先在线玩几轮。）</p>
<div align=center><img src="img/ch7_1.png"/></div>
<p><em>提示：#351, #361, #377, #386, #399</em></p>
</li>
<li>
<p><strong>7.11 文件系统（File System）</strong>：说明用于设计内存文件系统的数据结构和算法。尽可能用一个代码示例进行说明。</p>
<p><em>提示：#141, #216</em></p>
</li>
<li>
<p><strong>7.12 哈希表（Hash Table）</strong>：设计并实现一个哈希表，该哈希表使用链接（linked lists，链表）来处理冲突。</p>
<p><em>提示：#287, #307</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：线程和锁 (#16.3)</p>
<p>提示从第 662 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8--递归和动态规划"><a class="header" href="#chapter-8--递归和动态规划">Chapter 8 | 递归和动态规划</a></h1>
<p>虽然存在大量的递归问题，但其中许多都遵循着类似的模式。判断一个问题是否是考察递归的，一个很好的暗示是这个问题可以由子问题构建而成。</p>
<p>当你听到以下列语句开头的问题时，它通常是（但并非总是）一个潜在的递归的问题：“设计一个算法来计算第 n 个......”，“编写代码以列出前 n 个……”， “实现一个方法来计算所有的……”，等等。</p>
<blockquote>
<p>提示：根据我指导求职者的经验，人们在“这听起来像一个递归问题”这一直觉上通常有 50% 的准确率。利用这种直觉，因为 50% 也是很有价值的。但是不要害怕用不同的方式来看待问题，即使你最初认为它看起来是递归的。因为还有 50% 的可能性你是错的。</p>
</blockquote>
<p>熟能生巧！你做的题越多，就越容易识别递归问题。</p>
<h3 id="如何处理-1"><a class="header" href="#如何处理-1">如何处理</a></h3>
<p>根据定义，递归解决方案是基于子问题的解决方案构建的。很多时候，这意味着只需通过添加内容，删除内容或以其他方式更改f（n-1）的解来计算f（n）。在其他情况下，你可以解决数据集的前半部分，然后是后半部分的问题，然后合并这些结果。</p>
<p>你可以通过多种方式将问题划分为子问题。开发算法的三种最常用的方法是自下而上（bottom-up），自上而下（top-down）和一半一半（half-and-half）。</p>
<h4 id="自下而上的方法"><a class="header" href="#自下而上的方法">自下而上的方法</a></h4>
<p>自下而上的方法通常是最直观的。我们首先明确如何解决一个简单情况下的问题，比如只有一个元素的列表。然后我们弄清楚如何解决两个元素的问题，然后是三个元素，以此类推。这里的关键是考虑如何根据前一个案例（或多个以前的案例）为当前的案例构建解决方案。</p>
<h4 id="自上而下的方法"><a class="header" href="#自上而下的方法">自上而下的方法</a></h4>
<p>自上而下的方法可能更复杂，因为它不那么具体。但有时候，这是思考问题的最佳方式。</p>
<p>在这些问题中，我们考虑如何将案例 N 的问题划分为子问题。</p>
<p>小心案例之间的重叠。</p>
<h4 id="一半一半的方法"><a class="header" href="#一半一半的方法">一半一半的方法</a></h4>
<p>除了自上而下和自下而上的方法之外，将数据集分成两半通常也是有效的。</p>
<p>例如，二分搜索使用一种“一半一半（half-and-half）”方法。我们在有序数组中查找元素时，首先要确定数组的哪一半包含该值。然后我们在有值那一半进行递归搜索。</p>
<p>归并排序也是一种“一半一半（half-and-half）”的方法。我们对数组的每一半进行排序，然后将排序后的一半合并在一起。</p>
<h3 id="递归-vs-迭代"><a class="header" href="#递归-vs-迭代">递归 vs 迭代</a></h3>
<p>递归算法的空间效率非常低。每次递归调用都会向堆栈添加一个新层，这意味着如果你的算法递归到 n 的深度，那么它至少会使用 O(n) 内存。</p>
<p>因此，迭代地实现递归算法通常更好。所有递归算法都可以迭代地实现，尽管有时候实现这样的代码要复杂得多。在深入研究递归代码之前，先问问自己迭代地实现它有多难，并与面试官讨论权衡。</p>
<h3 id="动态规划-vs-记忆法memorizotion"><a class="header" href="#动态规划-vs-记忆法memorizotion">动态规划 vs 记忆法（Memorizotion）</a></h3>
<p>尽管人们对动态规划（Dynamic programming）问题的可怕程度大做文章，但实际上没有必要害怕它们。事实上，一旦你理解了，这些其实可能是非常容易的问题。</p>
<p>动态规划主要是采用递归算法并找到重叠的子问题（即重复调用）。然后缓存这些结果，以便将来进行递归调用。</p>
<p>或者，你可以研究递归调用的模式并实现迭代。你仍然要“缓存（cache）”之前的工作。</p>
<blockquote>
<p>术语说明：有些人把自上而下的动态规划称为“记忆法（memoization）”，只使用“动态规划”来指代自下而上的工作。我们在这里没有做出这样的区分。统称为动态规划。</p>
</blockquote>
<p>动态规划的一个最简单的例子是计算第 n 个斐波那契数。处理这类问题的一个好方法将其作为正常的递归解决方案实现，然后添加缓存部分。</p>
<h4 id="斐波那契数列fibonacci-numbers"><a class="header" href="#斐波那契数列fibonacci-numbers">斐波那契数列（Fibonacci Numbers）</a></h4>
<p>让我们来看一下计算第 n 个斐波那契数的方法。</p>
<p><em>递归</em></p>
<p>我们将从递归实现开始。听起来很简单，对吧？</p>
<pre><code class="language-java">1 	int fibonacci(int i) {
2 		if (i == 0) return 0;
3 		if (i == 1) return 1;
4 		return fibonacci(i - 1) + fibonacci(i - 2);
5 	}
</code></pre>
<p>这个函数的运行时间是多少？在回答之前想一下。</p>
<p>如果你说是 O(n) 或者 O(n^2)（很多人会这么说），请再想一想。研究代码所采用的代码路径。将代码路径画成树（即递归树）对本问题和许多递归问题都很有用。</p>
<div align=center><img src="img/ch8_1.png"/></div>
观察树上的叶子节点都是 fib(1) 和 fib(0)，它们表示基本案例。
<p>树中的节点总数将表示运行时，因为每个调用在其递归调用之外只执行 O(1) 个工作。因此，调用的数量是运行时。</p>
<blockquote>
<p>提示：对于以后的问题，请记住这一点。将递归调用绘制为树是计算递归算法运行时的一种很好的方法。</p>
</blockquote>
<p>树中有多少节点？在我们开始处理基本案例（叶子）之前，可以看到除叶子外每个节点都有两个子节点。即每个节点分叉两次。</p>
<p>根节点有两个子节点。这些子节点中每个又分别都有两个子节点（所以“孙节点（grandchildren）”层总节点数为 4 个）。这些孙节点中每个又分别都有两个子节点，以此类推。如果我们这样做n次，我们会得到大约 O(2^n) 个节点。这样运行时大概为 O(2^n)。</p>
<blockquote>
<p>实际上，它略好于 O(2^n)。如果你看一下子树，你可能会注意到（除了叶子节点和它上面的那些节点）任何节点的右子树总是小于左子树。如果左右子树的大小相同，其运行时将为 O(2^n)。但由于左右子树的大小不同，真正的运行时间更接近于 O(1.6^n)。虽然说 O(2^n) 在技术上仍然正确，但它描述的其实是运行时的上限（参见“Big O, Big Theta,and Big Omega“，第39页）。不管怎样，我们仍然有一个指数级的运行时。</p>
</blockquote>
<p>事实上，如果我们在计算机上实现这个，我们会看到秒数呈指数增长。</p>
<div align=center><img src="img/ch8_2.png"/></div>
我们应该寻找一种方法来优化它。
<p><em>自上而下动态规划（或记忆法）</em></p>
<p>重新回到递归树。在哪里可以看到相同的节点?</p>
<p>可以发现有很多相同的节点。例如，fib(3) 出现两次，fib(2) 出现了三次。那为什么我们每次还要从头开始重新计算这些呢？</p>
<p>事实上，当我们调用 fib(n) 时，我们不应该做比 O(n) 更多的调用，因为只有 O(n) 个可能的值可以赋给 fib。每次计算 fib(i) 时，我们都应该缓存计算的结果并在以后直接使用这个结果。</p>
<p>这就是记忆法。</p>
<p>只需稍加修改，我们就可以将这个函数调整为在 O(n) 的时间内运行。我们只是在两次调用之间缓存fibonacci(i) 的结果。</p>
<pre><code class="language-java">1 	int fibonacci(int n) {
2 		return fibonacci(n, new int[n + 1]);
3 	}
4
5 	int fibonacci(int i, int[] memo) {
6 		if (i == 0 || i == 1) return i;
7
8 		if (memo[i] == 0) {
9 			memo[i] = fibonacci(i - 1, memo) + fibonacci(i - 2, memo);
10 		}
11 		return memo[i];
12 	}
</code></pre>
<p>在一台典型的计算机上，第一个递归函数生成第 50 个斐波那契数可能需要超过一分钟的时间，而动态规划方法可以在几分之一毫秒内生成第 10000 个斐波那契数。(当然，使用这种精确的代码（exact code），int 值在很早就会溢出。)</p>
<p>现在，如果我们绘制递归树，它看起来像这样（黑框代表立即返回的缓存调用）：</p>
<div align=center><img src="img/ch8_3.png"/></div>
现在这棵树中有多少个节点？ 我们可能会注意到树现在直接向下延伸，深度大约为 n。这些节点中的每个节点都有一个其他的子节点，导致树中大约有 2n 个子节点。这需要 O(n) 的运行时间。
<p>通常，将递归树描绘成如下所示是有用的：</p>
<div align=center><img src="img/ch8_4.png"/></div>
实际上递归不是这样发生的。但是，通过横向扩展节点而不是纵向扩展节点，你可以得到一棵在变深之前会变宽的树。（这就像是广度优先而不是深度优先。）有时这使得计算树中的节点数变得更容易。你真正要做的是更改要展开的节点和返回缓存值的节点。如果你坚持要计算动态编程问题的运行时，可以尝试这种方法。
<p><em>自下而上的动态规划</em></p>
<p>我们也可以采用这种方法，并用自下而上的动态规划实现它。考虑做与递归记忆法相同的事情，但是要反过来。</p>
<p>首先，我们计算 fib(1) 和 fib(0)，这些已经从基本案例中得知。然后我们用这些来计算 fib(2)，再然后我们使用之前的答案来计算 fib(3)，然后是fib(4)，以此类推。</p>
<pre><code class="language-java">1 	int fibonacci(int n) {
2 		if (n == 0) return 0;
3 		else if (n == 1) return 1;
4
5 		int[] memo new int[n];
6 		memo[0] = 0;
7 		memo[l] = 1;
8 		for (int i= 2; i &lt; n; i++) {
9 			memo[i] = memo[i - 1] + memo[i - 2];
10		}
11 		return memo[n - 1] + memo[n - 2];
12 	}
</code></pre>
<p>如果你真的理解了这是如何工作的，你会发现只有在计算 memo[i+1] 和 memo[i+2] 时才需要用到 memo[i]。之后就不需要了。因此，我们可以去掉 memo 表，只存储一些变量。</p>
<pre><code class="language-java">1 	int fibonacci(int n) {
2 		if (n == 0) return 0;
3 		int a = 0;
4 		int b = 1;
5 		for (int i = 2; i &lt; n; i++) {
6 			int c = a + b;
7 			a = b;
8 			b = c;
9 		}
10 		return a + b;
11 	}
</code></pre>
<p>这基本上是将最后两个 Fibonacci 值的结果存储到 a 和 b 中。在每次迭代中，我们计算下一个值 (c = a + b)，然后将 (b, c = a + b) 移动到 (a, b) 中。</p>
<p>对于这样一个简单的问题，这种解释似乎有些过度了，但真正理解这个过程将使更困难的问题变得容易得多。阅读本章中的问题（其中许多使用动态规划）将有助于巩固你的理解。</p>
<p><strong>附加阅读</strong>： Proof by Induction (pg 631).</p>
<hr />
<h3 id="interview-questions-8"><a class="header" href="#interview-questions-8">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>8.1 三级台阶（Triple Step）</strong>：一个孩子跑上有 n 级台阶的楼梯，一次可以跳 1 级、2 级或 3 级。实现一个方法来，计算该孩子可以有多少种可能的方式跑上楼梯。</p>
<p><em>提示：#152, #178, #217, #237, #262, #359</em></p>
</li>
<li>
<p><strong>8.2 网格中的机器人（Robot in a Grid）</strong>：想象一个机器人坐在网格的左上角，其中该网格有 r 行和 c 列。该机器人只能在向右和向下两个方向移动，但是某些单元格是“禁区”，因此机器人不能踩到它们。设计一种算法，从左上角到右下角为机器人找到一条路径。</p>
<p><em>提示：#331, #360, #388</em></p>
</li>
<li>
<p><strong>8.3 魔法索引（Magic Index）</strong>：数组 A[0 ... n-1] 中的魔法索引被定义为这样一个索引，使得 A[i] = i。给定一个由不同整数组成的有序数组，编写一个方法以找到数组 A 中的魔术索引（如果存在）。</p>
<p>FOLLOW UP</p>
<p>如果值不唯一怎么办？</p>
<p><em>提示：#770, #204, #240, #286, #340</em></p>
</li>
<li>
<p><strong>8.4 幂集（Power Set）</strong>：编写一种方法以返回集合的所有子集。</p>
<p><em>提示：#273, #290, #338, #354, #373</em></p>
</li>
<li>
<p><strong>8.5 递归相乘（Recursive Multiply）</strong>：编写一个递归函数，使两个正整数相乘，不使用 * 运算符。你可以使用加法、减法和移位，但应尽量减少这些操作的数量。</p>
<p><em>提示：#166, #203, #227, #234, #246, #280</em></p>
</li>
<li>
<p><strong>8.6 汉诺塔（Towers of Hanoi）</strong>：在经典的汉诺塔问题中，你有 3 个塔和 N 个不同大小的圆盘，它们可以滑到任何塔上。困难在于圆盘从上到下必须按大小的升序进行排序（即，每个圆盘都位于更大的圆盘之上）。你有以下限制：</p>
<p>（1）一次只能移动一个圆盘。</p>
<p>（2）将圆盘从从一个塔顶滑到另一个塔顶。</p>
<p>（3）一个圆盘不能放在比它小的圆盘上。</p>
<p>编写一个程序，使用堆栈将圆盘从第一个塔移动到最后一个塔。</p>
<p><em>提示：#744, #224, #250, #272, #318</em></p>
</li>
<li>
<p><strong>8.7 无重复字符的排列（Permutations without Dups）</strong>：编写一个方法来计算一串无重复字符的所有排列。</p>
<p><em>提示：#150, #185, #200, #267, #278, #309, #335, #356</em></p>
</li>
<li>
<p><strong>8.8 有重复字符的排列（Permutations with Dups）</strong>：编写一个方法来计算字符串的所有排列，其字符不一定是唯一的。排列列表不应重复。</p>
<p><em>提示：#761, #790, #222, #255</em></p>
</li>
<li>
<p><strong>8.9 括号（Parens）</strong>：实现一个算法，以打印 n 对括号的所有有效（例如正确打开和关闭）组合。</p>
<p>EXAMPLE</p>
<pre><code>Input: 3
Output: ((())), (()()), (())(), ()(()), ()()()
</code></pre>
<p><em>提示：#138, #174, #787, #209, #243, #265, #295</em></p>
</li>
<li>
<p><strong>8.10 绘画填充（Paint Fill）</strong>：实现许多图像编辑程序可能会看到的“绘画填充”功能。即，给定一个屏幕（由一个二维颜色数组表示）、一个点和一种新颜色，填充周围区域，直到颜色从原来的颜色改变。</p>
<p><em>提示：#364, #382</em></p>
</li>
<li>
<p><strong>8.11 硬币（Coins）</strong>：假设有无数个 25 美分、10 美分、5 美分和 1 美分的硬币，编写代码核算有多少种 n 美分的表示方法。</p>
<p><em>提示：#300, #324, #343, #380, #394</em></p>
</li>
<li>
<p><strong>8.12 八皇后（Eight Queens）</strong>：编写一个算法，在 8x8 的国际象棋棋盘上，打印 8 个皇后的所有排列方式，以使它们都不共享相同的行、列或对角线。在这种情况下，“对角线”是指所有的对角线，而不仅仅是平分棋盘的两条。</p>
<p><em>提示：#308, #350, #371</em></p>
</li>
<li>
<p><strong>8.13 （Stack of Boxes）</strong>：你有总数为 n 的一堆盒子，宽度w&lt;i&gt;，高度h&lt;i&gt;，深度d&lt;i&gt;。盒子不能旋转，只有当堆中的每个盒子的宽度，高度和深度均严格大于其上方的盒子，才可以堆叠在一起。实现一种方法来计算可能的最高堆栈的高度。堆栈的高度是每个盒子的高度之和。</p>
<p><em>提示：#755, #194, #274, #260, #322, #368, #378</em></p>
</li>
<li>
<p><strong>8.14 布尔求值（Boolean Evaluation）</strong>：给定一个由 0 (false)、1 (true)、&amp; (AND)、| (OR) 和 ^ (XOR) 组成的布尔表达式，以及一个期望的布尔结果值 <code>result</code>。可以向表达式中插入括号以使其得出期望的 <code>result</code> ，实现一个函数，来计算可采取的操作方法的数量。</p>
<p>EXAMPLE</p>
<pre><code>countEval ("1^0|0|1", false) -&gt; 2
countEval ("0&amp;0&amp;0&amp;1^1|0", true) -&gt; 10
</code></pre>
<p><em>提示：#748, #168, #197, #305, #327</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：链表(#2.2, #2.5, #2.6)，栈和队列(#3.3)，树和图(#4.2, #4.3, #4.4, #4.5, #4.8, #4.10, #4.11, #4.12)，数学和逻辑难题(#6.6)，排序和搜索(#10.5, #10.9, #10.10)，C++(#12.8)，中等问题(#16.11)，困难问题(#17.4, #17.6, #17.8, #17.12, #17.13, #17.15, #17.16, #17.24, #17.25)。</p>
<p>提示从第 662 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-9--系统设计和可扩展性"><a class="header" href="#chapter-9--系统设计和可扩展性">Chapter 9 | 系统设计和可扩展性</a></h1>
<p>尽管可扩展性问题看起来很吓人，但它可能是最简单的问题之一。没有“陷阱”，没有技巧，没有花哨的算法——至少通常没有。让许多人困惑的是，他们相信这些问题有某种“魔力”——一些隐藏的知识。</p>
<p>不是那样的。这些问题只是为了了解你在实际工作中的表现而设计。试想如果你的经理让你设计一些系统，你会怎么着手做呢？</p>
<p>这就是为什么你应该在面对这类问题时，要像在处理实际工作中的问题一样。多询问问题。契合你的面试官。讨论解决方案的取舍权衡。</p>
<p>我们将在本章中介绍一些关键概念，但要明白关键不在于记住这些概念。是，理解系统设计的一些重要组件可能很有用，但我们更多地是应该关注解决问题的流程。要记住，有好的解决方案和糟糕的解决方案。没有完美的解决方案。</p>
<h3 id="对付这些问题"><a class="header" href="#对付这些问题">对付这些问题</a></h3>
<ul>
<li>
<p><strong>保持沟通</strong>：系统设计问题的一个关键目标是评估你的沟通能力。和面试官保持互动。问他们问题。对系统问题持开放态度。</p>
</li>
<li>
<p><strong>先注重广度</strong>：不要直接进入算法部分，或过度专注于一部分。</p>
</li>
<li>
<p><strong>使用白板</strong>：使用白板可以帮助你的面试官 follow 你提出的设计方案。在一开始就使用白板来画出你的方案。</p>
</li>
<li>
<p><strong>回应面试官的担忧</strong>：你的面试官很可能会带着对方案的担忧来考察你。不要置之不理，要验证它们。承认面试官指出的问题，并做出相应的改变。</p>
</li>
<li>
<p><strong>注意假设</strong>：错误的假设可能会极大地改变问题。例如，如果你的系统为数据集生成分析/统计数据，那么这些分析是否必须完全是最新的就很重要了。</p>
</li>
<li>
<p><strong>明确陈述你的假设</strong>：当你做出假设时，请陈述它们。这让你的面试官在你犯错时可以帮忙纠正你，并且这也表明了你至少知道自己在做什么假设。</p>
</li>
<li>
<p><strong>必要时估计</strong>：在许多情况下，你可能没有所需的数据。例如，如果你正在设计一个网络爬虫，则可能需要估计存储所有 URL 所需的空间。你可以使用你知道的其他数据进行估算。</p>
</li>
<li>
<p><strong>掌舵</strong>：作为候选人，你应该掌控整个局面（stay in the driver's seat）。这并不意味着你不与面试官交谈；事实上你必须和面试官多沟通。但是，不要被问题影响自己的主线思路。多问问题。对权衡持开放态度。继续深入。继续改进。</p>
</li>
</ul>
<p>这些问题主要是关于在解决过程的需要注意的，而不是针对最终的设计。</p>
<h3 id="设计step-by-step"><a class="header" href="#设计step-by-step">设计：Step-By-Step</a></h3>
<p>如果你的经理要求你设计一个像 TinyURL 这样的系统，你可能不会只是说个“OK”，然后把自己锁在办公室里自己设计吧。在做之前你可能会有很多的问题要去问。这也应该是你在面试中处理设计问题的方式。</p>
<h4 id="step-1审题"><a class="header" href="#step-1审题">Step 1：审题</a></h4>
<p>如果你不知道自己将要设计什么，你就不能开始设计一个系统。确定问题的范围非常重要，因为你要确保你在构建面试官想要的东西，因为这可能是面试官特别看重的。</p>
<p>如果你被问到诸如“设计 TinyURL ”之类的问题，你需要了解具体需要实现什么。人们能够指定自己的短 URL 吗？还是全部自动生成？你需要跟踪任何点击的统计数据吗？URL 应该永远保持活动状态，还是有超时机制？</p>
<p>这些是在进一步讨论之前必须回答的问题。</p>
<p>在这里列出主要特性或用例。例如，对 TinyURL来说，它可能是：</p>
<ul>
<li>
<p>将 URL 缩短为 TinyURL。</p>
</li>
<li>
<p>URL 的分析。</p>
</li>
<li>
<p>检索与 TinyURL 关联的 URL。</p>
</li>
<li>
<p>用户帐户和链接管理。</p>
</li>
</ul>
<h4 id="step-2做出合理的假设"><a class="header" href="#step-2做出合理的假设">Step 2：做出合理的假设</a></h4>
<p>可以做一些假设（必要时），但它们应该是合理的。例如，假设你的系统每天只需要处理100个用户，或假设你有无限的可用内存，这些都是不合理的。</p>
<p>然而，每天最多设计 100 万个新 URL 可能是合理的。做出这个假设可以帮助你计算系统可能需要存储多少数据。</p>
<p>有些假设可能需要一些“产品意义”（这不是一件坏事）。例如，数据最多 10 分钟就过期了，这样可以吗？这要看情况而定。如果刚刚输入的 URL 需要 10 分钟才能工作，这将是一个破坏性的问题。人们通常希望这些 URL 立即生效。但是，如果是统计数据要在 10 分钟过期，那可能没问题。和你的面试官讨论这些假设。</p>
<h4 id="step-3画出主要的组件"><a class="header" href="#step-3画出主要的组件">Step 3：画出主要的组件</a></h4>
<p>从椅子上站起来，走到白板前，绘制一张主要组件的设计图。你可能会有类似一台前端服务器（或一组服务器）的东西，可以从后端数据存储中提取数据。可能有另一组服务器在 internet 上搜索某些数据，还有一组服务器进行流程分析。按系统可能的样子来绘制这张图。</p>
<p>从头到尾梳理系统的运行流程。开始时用户输入一个新的URL。然后呢？</p>
<p>忽略较多的可扩展性挑战，假设简单、明显的方法就可以，在系统设计时可能对你会有所帮助。你将在第4步中处理重大问题。</p>
<h4 id="step-4确定关键问题"><a class="header" href="#step-4确定关键问题">Step 4：确定关键问题</a></h4>
<p>一旦你心中有了一个基本的设计，接着就该专注于关键问题了。系统中的瓶颈或主要挑战是什么？</p>
<p>例如，如果你正在设计 TinyURL，你可能会考虑这样一种情况：虽然某些 URL 很少被访问，但是其他 URL 可能会突然达到峰值。如果一个 URL 被发布在 Reddit 或其他流行论坛上，就可能会发生这种情况。你不一定希望经常访问数据库。</p>
<p>你的面试官可能会提供一些指导。如果是这样，就接受指导并加以使用。</p>
<h4 id="step-5根据关键问题重新设计"><a class="header" href="#step-5根据关键问题重新设计">Step 5：根据关键问题重新设计</a></h4>
<p>一旦确定了关键问题，就可以根据需要调整设计。你可能会发现它将涉及很多的重新设计，或者只是一些小的调整（如使用缓存）。</p>
<p>待在白板前，随着你的设计更改及时更新你的图。</p>
<p>对设计中的任何边界你都要讲出来。面试官可能会注意到它们，所以你要跟面试官讲清楚你也考虑到这些边界问题，这一点很重要。</p>
<h3 id="可扩展的算法-step-by-step"><a class="header" href="#可扩展的算法-step-by-step">可扩展的算法： Step-By-Step</a></h3>
<p>在某些情况下，并不要求你设计整个系统。你只是被要求设计一个单一的功能或算法，但你必须以可扩展的方式进行设计。或者，可能有一个算法部分是更广泛的设计问题的“真正”焦点。</p>
<p>在这些情况下，尝试以下方法。</p>
<h4 id="step-1-提问"><a class="header" href="#step-1-提问">Step 1 ：提问</a></h4>
<p>与之前的方法一样，提问以确保你真正理解了面试官的问题。面试官可能会（有意或无意）遗漏掉一些细节。如果你不能确切地理解问题是什么，则无法解决问题。</p>
<h4 id="step-2假装"><a class="header" href="#step-2假装">Step 2：假装</a></h4>
<p>假装所有数据都可以放在一台机器上，并且没有内存限制。你将如何解决这个问题？这个问题的答案将为你的解决方案提供一个大致的轮廓。</p>
<h4 id="step-3回到现实"><a class="header" href="#step-3回到现实">Step 3：回到现实</a></h4>
<p>现在回到原来的问题。你可以在一台计算机上安装多少数据，以及拆分数据时会出现什么问题？ 常见问题包括弄清楚如何在逻辑上划分数据，以及一台机器如何确定在哪里查找不同的数据。</p>
<h4 id="step-4解决问题"><a class="header" href="#step-4解决问题">Step 4：解决问题</a></h4>
<p>最后，考虑一下如何解决你在 Step 2 中确定的问题。请记住，每个问题的解决方案可能是实际完全移除问题，也可能只是为了缓解问题。你可以继续（带有修改地）使用 Step 1 中概述的方法，但有时你需要从根本上改变方法。</p>
<p>请注意，迭代方法通常很有用。也就是说，一旦你解决了 Step 3 中的问题，就可能出现新问题，你也必须处理这些问题。</p>
<p>你的目标不是重构一个公司花费数百万美元构建的复杂系统，而是要证明你可以分析和解决问题。深挖你自己的解决方案中是展示这一点的绝佳方式。</p>
<h3 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h3>
<p>虽然系统设计问题并不是对你所知道的内容的真正测试，但了解一些概念可以使事情变得更加容易。我们将在这里给出一个简要的概述。所有这些都是深刻而复杂的主题，因此我们鼓励你使用在线资源进行更多的研究。</p>
<h4 id="水平扩展-vs-垂直扩展"><a class="header" href="#水平扩展-vs-垂直扩展">水平扩展 vs. 垂直扩展</a></h4>
<p>一个系统可以用以下两种方法之一来扩展。</p>
<ul>
<li>
<p>垂直扩展意味着增加特定节点的资源。例如，你可以向服务器添加额外的内存，以提高其处理负载更改的能力。</p>
</li>
<li>
<p>水平扩展意味着增加节点的数量。例如，你可以添加额外的服务器，从而减少任何一台服务器上的负载。</p>
</li>
</ul>
<p>垂直缩放通常比水平缩放容易，但它是有限的。你只能添加这么多的内存或磁盘空间。</p>
<h4 id="负载均衡"><a class="header" href="#负载均衡">负载均衡</a></h4>
<p>通常，可扩展网站的一些前端部分将被抛到一个负载均衡器之后。这就允许了系统能够均匀地分配负载，因而就不会出现某个服务器会崩溃并导致整个系统宕机的情况。当然，要做到这一点，你必须构建一个由克隆服务器（cloned servers）组成的网络，这些服务器本质上具有相同的代码并访问相同的数据。</p>
<h4 id="数据库反模式和-nosql"><a class="header" href="#数据库反模式和-nosql">数据库反模式和 NoSQL</a></h4>
<p>随着系统变得越来越大，加入 SQL 等关系数据库会变得非常慢。因此，你通常会避免使用它们。</p>
<p>反模式是其中一种解决方案。反模式意味着向数据库中添加冗余信息以加快读取速度。例如，想象一个描述项目和任务的数据库（其中一个项目可以有多个任务）。你可能需要获取项目名称和任务信息。你可以将项目名称存储在任务表中（除了项目表之外），而不是跨这些表进行连接。</p>
<p>或者，你可以使用 NoSQL 数据库。NoSQL 数据库不支持连接，并且可能以不同的方式构造数据。它被设计为更好地实现扩展。</p>
<h4 id="数据库分区分片sharding"><a class="header" href="#数据库分区分片sharding">数据库分区（分片，Sharding）</a></h4>
<p>分片意味着将数据分割到多台机器上，同时确保你有办法确定哪台机器上有哪些数据。</p>
<p>一些常见的分区方法包括：</p>
<ul>
<li>
<p><strong>垂直分区</strong>：这基本上是按功能分区。例如，如果你正在构建一个社交网络，你可能有一个分区存储用于与配置文件相关的表，另一个分区用于消息，等等。这样做的一个缺点是，如果其中一个表变得非常大，你可能需要重新分区该数据库（可能使用不同的分区方案）。</p>
</li>
<li>
<p><strong>基于 key（或基于 hash）的分区</strong>：使用数据的某些部分（例如 ID）对其进行分区。一个非常简单的方法是分配 N 台服务器，并将数据根据key 计算 mod(key, n) 放在相应服务器上。与此相关的一个问题是，你拥有的服务器数量实际应该是固定的。添加额外的服务器意味着重新分配所有数据——这是一项非常昂贵的任务。</p>
</li>
<li>
<p><strong>基于目录的分区</strong>：在此方案中，你维护一个查找表，用于查找数据所在的位置。这使得添加额外的服务器相对容易，但是它有两个主要缺点。首先，查找表可能出现单点故障。其次，经常访问这个表会影响性能。</p>
</li>
</ul>
<p>许多架构实际上最终使用多个分区方案。</p>
<h4 id="缓存"><a class="header" href="#缓存">缓存</a></h4>
<p>内存缓存可以非常快速地返回结果。它是一个简单的 key-value 对，通常位于应用程序层和数据存储之间。</p>
<p>当应用程序请求一条信息时，它首先尝试缓存。如果缓存不包含这个 key，那么它将在数据存储中查找数据。（此时，数据可能存储在数据存储中，也可能不存储在数据存储中。）</p>
<p>缓存时，你可以直接缓存一次查询请求及其结果。或者，你也可以缓存特定对象（例如，网站某个部分的渲染版本，或者最近的博客文章列表）。</p>
<h4 id="异步处理--队列"><a class="header" href="#异步处理--队列">异步处理 &amp; 队列</a></h4>
<p>理想情况下，应该异步完成执行速度较慢的操作。否则，用户可能会一直等待进程完成。</p>
<p>在某些情况下，我们可以提前做到这一点（即我们可以预处理）。例如，我们可能有一个工作队列要更新网站的某些部分。如果我们正在运行论坛，其中一个工作可能是重新渲染一个列出最热门帖子和评论数量的页面。这个列表可能会有点过时，但这也许没有关系。这比用户仅仅因为某人添加了一条新评论使得缓存的页面无效，而在网站上等待加载要好得多。</p>
<p>在其他情况下，我们可能会告知用户等待，并在流程完成时通知他们。你之前可能已经在网站上看过这个。或许是当你开启了网站的某个新部分，它说需要几分钟才能导入你的数据，但是一旦完成，你就会收到通知。</p>
<h4 id="网络指标"><a class="header" href="#网络指标">网络指标</a></h4>
<p>关于网络的一些最重要的指标包括：</p>
<ul>
<li>
<p><strong>带宽</strong>：这是在单位时间内可以传输的最大数据量。它通常以每秒比特（或类似的方式，如每秒千兆字节）表示。</p>
</li>
<li>
<p><strong>吞吐量</strong>：带宽是单位时间内可以传输的最大数据，而吞吐量是实际传输的数据量。</p>
</li>
<li>
<p><strong>延迟</strong>：这是数据从一端到另一端所需的时间。也就是说，它是发送方发送信息（即使是非常小的数据块）到接收方接收信息之间的延迟。</p>
</li>
</ul>
<p>想象一下，你有一条传送带可以在工厂内传送物品。延迟是物品从一边到另一边所需的时间。吞吐量是每秒从传送带上滚落的物品数量。</p>
<p>建造一个更宽的传送带不会改变延迟。然而，它将改变吞吐量和带宽。你可以在传送带上放更多的物品，从而在给定的时间单位内传输更多的物品。
缩短传送带会降低延迟，因为物品在运输过程中花费的时间变得更少了。它不会改变吞吐量或带宽。因为每单位时间内从带上滚落的物品的数量是相同的。</p>
<p>制造更快的传送带将改变这三者。物品穿越工厂所需的时间缩短了。每单位时间，也会有更多的物品从传送带上滚下来。</p>
<p>带宽是指在最佳条件下每单位时间可以传输的物品数。吞吐量是机器运行不顺畅时实际花费的时间。</p>
<p>延迟很容易被忽视，但在特定的情况下，它可能非常重要。例如，如果你正在玩某些在线游戏，延迟可能是一个非常大的问题。如果你不能很快被告知对手的动向，你怎么能玩一款典型的在线体育游戏（比如双人足球游戏）呢？此外，与吞吐量不同，吞吐量至少可以通过数据压缩来加快速度，但对于延迟，你通常无能为力。</p>
<h4 id="mapreduce"><a class="header" href="#mapreduce">MapReduce</a></h4>
<p>MapReduce 通常与 Google 联系在一起，但它的用途要广泛得多。MapReduce 程序通常用于处理大量数据。</p>
<p>顾名思义，MapReduce 程序要求你编写 Map 步骤和 Reduce 步骤。其余的由系统处理。</p>
<ul>
<li>
<p><strong>Map</strong> 接收一些数据并发出一个 &lt;key, value&gt; 对。</p>
</li>
<li>
<p><strong>Reduce</strong> 接受一个 key 和一组关联的 value，并以某种方式“减少（reduces）”它们，发出一个新的 key 和 value。这一结果可能会返回给 Reduce 程序以进一步减少。</p>
</li>
</ul>
<p>MapReduce 允许我们并行地进行大量处理，这使得处理大量数据的可扩展性更高。</p>
<p>有关更多信息，请参见 642 页的 “MapReduce”。</p>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<p>除了前面要学习的概念之外，在设计系统时还应该考虑以下问题。</p>
<ul>
<li>
<p><strong>故障</strong>：系统的任何部分都可能发生故障。你需要为许多或所有这些失败做计划。</p>
</li>
<li>
<p><strong>可用性和可靠性</strong>：可用性是系统运行时间百分比的函数。可靠性是系统在一定单位时间内运行的概率的函数。</p>
</li>
<li>
<p><strong>Read-heavy vs. Write-heavy</strong>：应用程序是否会执行大量读操作或大量写操作，这将影响设计。如果写多（write-heavy），你可以考虑排队写入（但是这里要考虑潜在的失败！）。如果读多（read-heavy），你可能需要缓存。其他设计决策也可能发生变化。</p>
</li>
<li>
<p><strong>安全</strong>：当然，安全威胁对系统来说是毁灭性的。考虑系统可能面临的问题类型，并围绕这些问题进行设计。</p>
</li>
</ul>
<p>这只是让你开始了解一个系统的潜在问题。记住，在面试中要开诚布公地谈论你的权衡。</p>
<h3 id="没有完美的系统"><a class="header" href="#没有完美的系统">没有“完美”的系统</a></h3>
<p>对于 TinyURL 或 Google Maps 或任何其他的系统，都没有一个单一的设计能够使它们完美运行（尽管有许多系统的工作非常糟糕）。总是有权衡的。对于一个系统，两个人可以有本质上不同的设计，在不同的假设下，他们都是优秀的。</p>
<p>在这些问题中，你的目标是能够理解使用场景、确定问题的范围、做出合理的假设、基于这些假设创建一个可靠的设计，同时对你的设计中的弱点保持开放的态度。不要指望它是完美。</p>
<h3 id="例题"><a class="header" href="#例题">例题</a></h3>
<p>给定一个包含数百万个文档的列表，如何找到包含单词列表的所有文档？单词可以以任何顺序出现，但必须是完整的单词。也就是说，“book” 跟 “bookkeeper” 是不匹配的。</p>
<p>在开始解决问题之前，我们需要明确这是一次性操作，还是可以重复调用 <code>findWords</code> 过程的操作。假设我们将为同一组文档多次调用 <code>findWords</code>，因此，我们可以接受预处理的负担。</p>
<h4 id="step-1"><a class="header" href="#step-1">Step 1</a></h4>
<p>第一步是假装我们只有几十个文档。在这种情况下，我们如何实现 <code>findWords</code> ？（提示：在继续阅读之前，先停下来尝试自己解决这个问题。）</p>
<p>一种方法是预先处理每个文档并创建一个哈希表索引。这个哈希表将从一个单词映射到包含该单词的文档列表。</p>
<pre><code>"books" -&gt; {doc2, doc3, doc6, doc8}
"many" -&gt; {doc1, doc3, doc7, doc8, doc9}
</code></pre>
<p>要搜索 “many books”，我们只需在 “books” 和“ many ”的值上做一个交集,并返回结果为 <code>{doc 3, doc8}</code>。</p>
<h4 id="step-2"><a class="header" href="#step-2">Step 2</a></h4>
<p>现在回到最初的问题。数百万个文档会带来什么问题？首先，我们可能需要在多台机器上划分文档。此外，根据各种因素，例如可能的单词数量和文档中单词的重复，我们可能无法在一台机器上拼装完整的哈希表。让我们假设情况就是这样。</p>
<p>划分过程引入了以下主要关注点：</p>
<ol>
<li>我们如何划分哈希表？ 我们可以通过关键字对其进行划分，这样指定的机器就包含了给定单词的完整文档列表。或者，我们可以按文档划分，这样一台机器只包含一个文档子集的关键字映射。</li>
<li>一旦我们决定如何划分数据，我们可能需要在一台机器上处理一个文档，并将结果推给其他机器。这个过程是什么样的？（注意：如果我们按文档划分哈希表，则可能不需要此步骤。）</li>
<li>我们需要一种方法来知道哪台机器保存着一段数据。这个查找表是什么样子的？它存储在哪里？</li>
</ol>
<p>这里只列了三个问题。可能还有很多其他的。</p>
<h4 id="step-3"><a class="header" href="#step-3">Step 3</a></h4>
<p>在 Step 3 中，我们寻找这些问题的解决方案。一种解决方案是按关键字的字母顺序划分单词，这样每台机器都控制一系列单词（例如，从 “after” 到 “apple”）。</p>
<p>我们可以实现一个简单的算法，按字母顺序遍历关键字，在一台机器上存储尽可能多的数据。当那台机器满了，我们可以移动到下一台机器。</p>
<p>这种方法的优点是查找表小而简单（因为它只能指定一定范围的值），并且每台机器都可以存储查找表的副本。然而，缺点是如果添加新文档或单词，我们可能需要执行昂贵的关键字迁移。</p>
<p>要查找与字符串列表匹配的所有文档，我们首先对列表进行排序，然后向每台机器发送一个查询请求，以查找该机器拥有的字符串。例如，如果我们的字符串是 “after builds boat amaze banana”，则机器 1 将获得 <code>{"after", "amaze"}</code> 的查找请求。</p>
<p>机器 1 查找包含 “after” 和 “amaze” 的文档，并在这些文档列表上取交集。机器 3 对 <code>{"banana", "boat", "build"}</code> 执行相同的操作，并对其列表取交集。</p>
<p>在最后一步中，初始机器将对机器 1 和机器 3 的结果取交集。</p>
<p>下图说明了此过程。</p>
<div align=center><img src="img/ch9_1.png"/></div>
<hr />
<h3 id="interview-questions-9"><a class="header" href="#interview-questions-9">Interview Questions</a></h3>
<hr />
<p>这些问题旨在反映真实的面试情况，因此不一定总是能被明确地定义。考虑一下你会问面试官什么问题，然后做出合理的假设。你可能会做出与我们不同的假设，这将导致你进行非常不同的设计。这没关系！</p>
<ul>
<li>
<p><strong>9.1 股票数据（Stock Data）</strong>：假设你正在构建某种服务，该服务将被多达1000个客户端应用程序调用，以获取简单的当日股票价格信息（开盘价，收盘价，最高价，最低价）。你可以假设你已经有了数据，并且可以将其存储为你希望的任何格式。你将如何设计将信息提供给客户端应用程序的面向客户端的服务？你负责需求的开发、发布、持续监控和维护。描述你考虑过的不同方法，以及为什么你会推荐你的方法。你的服务可以使用你想用的任何技术，并且可以按照你选择的任何机制将信息分发到客户端应用程序。</p>
<p><em>提示：#385, #396</em></p>
</li>
<li>
<p><strong>9.2 社交网络（Social Network）</strong>：你会如何设计一个非常大的社交网络（如Face­book 或 LinkedIn）的数据结构？描述如何设计算法来显示两个人之间的最短路径（例如，Me-&gt; Bob-&gt; Susan-&gt; Jason-&gt; You）。</p>
<p><em>提示：#270, #285, #304, #321</em></p>
</li>
<li>
<p><strong>9.3 网络爬虫（Web Crawler）</strong>：如果你正在设计一个网络爬虫，你将如何避免陷入无限循环？</p>
<p><em>提示：#334, #353, #365</em></p>
</li>
<li>
<p><strong>9.4 重复的 URL（Duplicate URLs）</strong>：你有 100 亿个 URL。你如何检测重复的文档？在本例中，假设“”重复意味着 是URL 相同的。</p>
<p><em>提示：#326, #347</em></p>
</li>
<li>
<p><strong>9.5 缓存（Cache）</strong>：假设有一个精简的搜索引擎的网络服务器。该系统有 100 台机器来响应搜索查询，然后可以使用 <code>processSearch(string query) </code> 调用另一组机器以实际获得结果。响应给定查询的机器是随机选择的，因此不能保证相同的机器总是响应相同的请求。processSearch 方法使用代价很高。为最近的查询设计缓存机制。请务必说明当数据更改时如何更新缓存。</p>
<p><em>提示：#259, #274, #293, #311</em></p>
</li>
<li>
<p><strong>9.6 销售排名（Sales Rank）</strong>：一家大型电子商务公司希望按类别和整体列出最畅销的产品。例如，一种产品在总体上可能是第 1056 名最畅销产品，但在“运动器材”项下却是第 13 名最畅销产品，在“安全”项下是第 24 名最畅销产品。描述如何设计这个系统。</p>
<p><em>提示：#142, #158, #176, #189, #208, #223, #236, #244</em></p>
</li>
<li>
<p><strong>9.7 个人财务管理程序（Personal Financial Manager）</strong>：说明如何设计个人财务管理程序（例如 Mint.com）。该系统将连接到你的银行帐户，分析你的消费习惯并提出建议。</p>
<p><em>提示：#762, #180, #199, #212, #247, #276</em></p>
</li>
<li>
<p><strong>9.8 Pastebin</strong>：设计一个类似 Pastebin 的系统，用户可以输入一段文本，并获得一个随机生成的 URL 来访问它。</p>
<p><em>提示：#165, #184, #206, #232</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：面向对象的设计 (#7.7)</p>
<p>提示从第 662 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-10--排序与搜索"><a class="header" href="#chapter-10--排序与搜索">Chapter 10 | 排序与搜索</a></h1>
<p>理解常见的排序和搜索算法是非常有价值的，因为许多排序和搜索问题都是对经典算法的细微调整。因此，在处理排序相关的问题时，一个好的方法是运行不同的排序算法，看看是否有一个特别适用。</p>
<p>例如，假设你被问到以下问题：给定一个非常大的 Person 对象数组，按年龄递增的顺序对人进行排序。</p>
<p>在这种场景下我们默认有两个很有趣的条件：</p>
<ol>
<li>这是一个很大的数组，所以效率非常重要。</li>
<li>因为根据年龄排序的，所以我们知道值在一个小范围内。</li>
</ol>
<p>通过浏览各种排序算法，我们可能会注意到桶排序（或基数排序）是这个问题的完美候选方案。实际上，我们可以将桶变小（每个桶仅1年），这样运行时间即为 O(n)。</p>
<h3 id="常见的排序算法"><a class="header" href="#常见的排序算法">常见的排序算法</a></h3>
<p>学习（或重新学习）常见的排序算法是提高能力的好方法。下面介绍的五种算法中，归并排序（Merge Sort）、快速排序（Quick Sort）和桶排序（Bucket Sort）是面试中最常用的算法。</p>
<h4 id="冒泡排序--运行时平均和最坏情况均为-on2内存o1"><a class="header" href="#冒泡排序--运行时平均和最坏情况均为-on2内存o1">冒泡排序 | 运行时：平均和最坏情况均为 O(n^2)。内存：O(1)。</a></h4>
<p>在冒泡排序中，我们从数组的开头开始，如果第一个元素大于第二个元素，则交换前两个元素。然后，我们转到下一对，以此类推，不断扫描数组，直到数组完全排序。在这样做时，较小的项会慢慢“冒泡”到列表的开头。</p>
<h4 id="选择排序--运行时平均和最坏情况均为-on2内存o1"><a class="header" href="#选择排序--运行时平均和最坏情况均为-on2内存o1">选择排序 | 运行时：平均和最坏情况均为 O(n^2)。内存：O(1)。</a></h4>
<p>选择排序是孩子的算法（child's algorithm）：简单，但效率低下。使用线性扫描找到最小元素并将其移动到前面（与前面的元素交换）。然后，找到第二个最小的并移动它，再次进行线性扫描。继续这样做，直到所有的元素都就位。</p>
<h4 id="归并排序--运行时平均和最坏情况均为-on-logn内存视情况而定"><a class="header" href="#归并排序--运行时平均和最坏情况均为-on-logn内存视情况而定">归并排序 | 运行时：平均和最坏情况均为 O(n log(n))。内存：视情况而定。</a></h4>
<p>归并排序将数组分成两半，对每一半进行排序，然后将它们重新合并在一起。每一半都使用了相同的排序算法。最后，只合并两个元素数组。繁重的工作都是在“归并（merge）”阶段完成。</p>
<p>merge 方法会将目标数组段中的所有元素复制到辅助（helper）数组中，跟踪左半部分和右半部分的起始位置（helperLeft 和 helperRight）。</p>
<p>然后我们对 helper 进行迭代，将每一半的较小元素复制到数组中。最后，将所有剩余的元素复制到目标数组中。</p>
<pre><code class="language-java">1 	void mergesort(int[] array) {
2 		int[] helper = new int[array.length];
3 		mergesort(array, helper, 0, array.length - 1);
4 	}
5 
6 	void mergesort(int[] array, int[] helper, int low, int high) {
7 		if (low &lt; high) {
8 			int middle = (low + high)/ 2;
9 			mergesort(array, helper, low, middle); // Sort left half
10 			mergesort(array, helper, middle+l, high); // Sort right half
11 			merge(array, helper, low, middle, high); // Merge them
12 		}
13 	}
14
15 	void merge(int[] array, int[] helper, int low, int middle, int high) {
16 		/* Copy both halves into a helper array*/
17 		for (int i = low; i &lt;= high; i++) {
18 			helper[i] = array[i];
19 		}
20
21 		int helperleft = low;
22 		int helperRight = middle + l;
23 		int current = low;
24
25 		/* Iterate through helper array. Compare the left and right half, copying back
26  	 * the smaller element from the two halves into the original array. */
27 		while (helperLeft &lt;= middle &amp;&amp; helperRight &lt;= high) {
28 			if (helper[helperleft] &lt;= helper[helperRight]) {
29 				array[current] = helper[helperleft];
30 				helperleft++;
31 			} else {//If right element is smaller than left element
32 				array[current] = helper[helperRight];
33 				helperRight++;
34 			}
35 			current++;
36 		}
37
38 		/* Copy the rest of the left side of the array into the target array*/
39 		int remaining = middle - helperleft;
40 		for (int i= 0; i &lt;= remaining; i++) {
41 			array[current + i] = helper[helperleft + i];
42 		}
43 	}
</code></pre>
<p>你可能会注意到，只有 helper 数组左半部分中的剩余元素被复制到目标数组中。为什么不是右半部分呢？右半部分不需要复制，是因为它已经在那里了。</p>
<p>例如，考虑一个像 [1、4、5 || 2、8、9] 这样的数组（“11”表示分区点）。在合并这两部分之前，helper 数组和目标数组段都以 [8, 9] 结尾。一旦我们将四个元素（1, 4, 5 和 2）复制到目标数组中，[8,9] 仍然在两个数组中都存在。没有必要复制它们。</p>
<p>归并排序的空间复杂度为 O(n)，这部分是用于归并数组部分的辅助空间。</p>
<h4 id="快速排序--运行时平均情况为-on-logn最坏情况均为-on2内存on-logn"><a class="header" href="#快速排序--运行时平均情况为-on-logn最坏情况均为-on2内存on-logn">快速排序 | 运行时：平均情况为 O(n log(n))，最坏情况均为 O(n^2)。内存：O(n log(n))。</a></h4>
<p>在快速排序中，我们选择一个随机元素并对数组进行分区（partition ），这样所有小于分区元素的数都在大于分区元素的数之前。可以通过一系列交换（见下文）有效地执行分区。</p>
<p>如果我们围绕一个元素反复地对数组（及其子数组）进行分区，那么该数组最终将被排序。但是，由于分区元素不能保证是中位数（或接近中位数的任何位置），我们的排序可能会非常慢。这是最坏情况运行时为 O(n^2) 的原因。</p>
<pre><code class="language-java">1 	void quickSort(int[] arr, int left, int right) {
2 		int index = partition(arr, left, right);
3 		if (left &lt; index - 1) { // Sort left half
4 			quickSort(arr, left, index - 1);
5 		}
6 		if (index &lt; right) { // Sort right half
7 			quickSort(arr, index, right);
8 		}
9 	}
10
11 	int partition(int[] arr, int left, int right) {
12 		int pivot = arr[(left + right) / 2]; // Pick pivot point
13 		while (left &lt;= right) {
14 			// Find element on left that should be on right
15 			while (arr[left] &lt; pivot) left++;
16
17 			// Find element on right that should be on left
18 			while (arr[right] &gt; pivot) right--;
19
20 			// Swap elements, and move left and right indices
21 			if (left &lt;= right) {
22 				swap(arr, left, right); // swaps elements
23 				left++;
24 				right--;
25 			}
26 		}
27 		return left;
28 	}
</code></pre>
<h4 id="基数排序--运行时okn见下文"><a class="header" href="#基数排序--运行时okn见下文">基数排序 | 运行时：O(kn)（见下文）</a></h4>
<p>基数排序是整数（和一些其他数据类型）的排序算法，它利用了整数具有有限位数的事实。在基数排序中，我们从低到高遍历数字的每一位，按每一位对数字进行排序。例如，如果我们有一个整数数组，我们可能首先根据数字的第一位（译者注，即个位）进行排序，这样 0 就被分组在一起了。然后，我们根据下一位对每个分组进行排序。我们重复这个过程，根据每个后续的位进行排序，直到最后整个数组被排序。</p>
<p>与比较排序算法不同，比较排序算法在平均情况下的运行时间为 O(n log(n)) ，而基数排序的运行时间为 O(kn)，其中 n 是元素的数量，k 是该算法中排序的执行次数（the number of passes）。</p>
<h3 id="搜索算法"><a class="header" href="#搜索算法">搜索算法</a></h3>
<p>当我们考虑搜索算法时，我们通常会想到二分搜索（binary search）。事实上，这是一个非常有用的算法。</p>
<p>在二分搜索中，我们通过首先将 x 的数值与数组的中点值进行比较，以查找排序数组中的元素 x。</p>
<p>如果 x 小于中点，那么我们搜索数组的左半部分。如果 x 大于中点，那么我们搜索数组的右半部分。然后我们重复这个过程，将左右两半作为子数组处理。再次，我们将 x 与这个子数组的中点进行比较，然后搜索该中点左侧或右侧。重复这个过程，直到 x 被找到或子数组的大小变为 0。</p>
<p>注意，尽管这个概念相当简单，但是要正确处理所有细节要比你想象的困难得多。在学习下面的代码时，请注意加号和减号。</p>
<pre><code class="language-java">1 	int binarySearch(int[] a, int x) {
2 		int low = 0;
3 		int high = a.length - 1;
4 		int mid;
5
6 		while (low &lt;= high) {
7 			mid = (low + high) / 2;
8 			if (a[mid] &lt; x) {
9 				low = mid + 1;
10 			} else if (a[mid] &gt; x) {
11 				high = mid - 1;
12 			} else {
13 				return mid;
14 			}
15 		}
16 		return -1; // Error
17 	}
18
19 	int binarySearchRecursive(int[] a, int x, int low, int high) {
20 		if (low &gt; high) return - 1; // Error
21
22 		int mid (low + high)/ 2;
23 		if (a[mid] &lt; x) {
24 			return binarySearchRecursive(a, x, mid + 1, high);
25 		} else if (a[mid] &gt; x) {
26 			return binarySearchRecursive(a, x, low, mid - 1);
27 		} else {
28 			return mid;
29 		}
30 	}
</code></pre>
<p>搜索数据结构的潜在方法可以扩展到二分搜索之外，最好不要将自己局限于此选项。例如，你可以使用二叉树或 hash table 来搜索节点。Think beyond binary search!</p>
<hr />
<h3 id="interview-questions-10"><a class="header" href="#interview-questions-10">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>10.1 有序合并（Sorted Merge）</strong>：给你两个有序数组A和B，其中 A 的末尾有足够大的缓冲区来容纳 B。编写一种将 B 按排序的顺序合并到 A 中的方法。 10.1（排序合并）**：给你两个排序的数组A和B，其中 A 的末尾有足够大的缓冲区来容纳 B。编写一种将 B 按排序的顺序合并到 A 中的方法。</p>
<p><em>提示：#332</em></p>
</li>
<li>
<p><strong>10.2 异位词分组（Group Anagrams）</strong>：写一个方法来排序一个字符串数组，使所有的异位词是相邻的。</p>
<p><em>提示：#717, #182, #263, #342</em></p>
</li>
<li>
<p><strong>10.3 在旋转数组中搜索（Search in Rotated Array）</strong>：给定一个 n 个整数的有序数组，该数组已旋转了未知次数，请编写代码以在该数组中找到一个元素。你可以假定该数组最初是按升序排序的。</p>
<p>EXAMPLE</p>
<pre><code>Input: find 5 in{l5, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14}
Output: 8 (the index of 5 in the array)
</code></pre>
<p><em>提示：#298, #370</em></p>
</li>
<li>
<p><strong>10.4 排序搜索，无 size（Sorted Search, No Size）</strong>：你得到一个类似数组的数据结构 Listy，它缺少 <code>size</code> 方法。但是，它确实有一个 <code>elementAt(i)</code> 方法，该方法在 O(1) 时间内返回索引 i 处的元素。如果 i 超出了数据结构的范围，则返回 -1。（因此，该数据结构只支持正整数。）给定一个包含有序的正整数的 Listy，找到元素 x 所在的索引。如果 x 出现多次，则可以返回任何索引。</p>
<p><em>提示：#320, #337, #348</em></p>
</li>
<li>
<p><strong>10.5 稀疏搜索（Sparse Search）</strong>：给定一个有序的字符串数组，其中穿插着空字符串，编写一个方法来查找给定字符串的位置。</p>
<p>EXAMPLE</p>
<pre><code>Input: ball, {"at", "", "", "", "ball", "", "", "car", "", "", "dad", "", ""}
Output: 4
</code></pre>
<p><em>提示：#256</em></p>
</li>
<li>
<p><strong>10.6 大文件排序（Sort Big File）</strong>：假设你有一个 20 GB 的文件，每行一个字符串。说明如何对文件进行排序。</p>
<p><em>提示：#207</em></p>
</li>
<li>
<p><strong>10.7 缺少整数（Missing Int）</strong>：给定一个包含 40 亿个非负整数的输入文件，请提供一个算法来生成文件中未包含的整数。假设你有 1 GB 的内存可用来完成此任务。</p>
<p>FOLLOW UP</p>
<p>如果你只有 10 MB 的内存怎么办？ 假设所有值都是不同的，并且我们现在有不超过十亿个非负整数。</p>
<p><em>提示：#235, #254, #281</em></p>
</li>
<li>
<p><strong>10.8 查找重复项（Find Duplicates）</strong>：你有一个包含从 1 到 N 的所有数字的数组，其中 N 最大为 32,000。数组可能有重复的项，而你不知道 N 是什么。在只有4 KB的可用内存的情况下，如何打印数组中所有重复的元素？</p>
<p><em>提示：#289, #315</em></p>
</li>
<li>
<p><strong>10.9 排序矩阵搜索（Sorted Matrix Search）</strong>：给定一个 M x N 矩阵，其中每一行和每一列都按升序排序，编写一个方法来查找一个元素。</p>
<p><em>提示：#193, #211, #229, #251, #266, #279, #288, #297, #303, #317, #330</em></p>
</li>
<li>
<p><strong>10.10 流的排名（Rank from Stream）</strong>：假设你正在读取一个整数流。你希望能够定期地查找数字 x 的排名（小于或等于 x 的值的数量）。实现数据结构和算法来支持这些操作。也就是说，实现方法 <code>track(int x)</code> 和方法 <code>getRankOfNumber(int x)</code>，前者在生成每个数字时调用，后者返回小于或等于 x 的值的数量（不包括 x 本身）。</p>
<p>EXAMPLE</p>
<pre><code>Stream (in order of appearance): 5, 1, 4, 4, 5, 9, 7, 13, 3
getRankOfNumber(1) = 0
getRankOfNumber(3) = 1
getRankOfNumber(4) = 3
</code></pre>
<p><em>提示：#301, #376, #392</em></p>
</li>
<li>
<p><strong>10.11 峰和谷（Peaks and Valleys）</strong>：在整数数组中，“峰”是大于或等于相邻整数的元素，“谷”是小于或等于相邻整数的元素。例如，在数组 <code>{5, 8, 6, 2, 3, 4, 6}</code> 中，<code>{8, 6}</code> 是峰，<code>{5, 2}</code> 是谷。给定一个整数数组，将数组排序为一个峰和谷交替序列。</p>
<p>EXAMPLE</p>
<pre><code>Input: {5, 3, 1, 2, 3}
Output: {5, 1, 3, 2, 3}
</code></pre>
<p><em>提示：#196, #219, #231, #253, #277, #292, #316</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：数组和字符串(#1.2)，递归(#8.3)，中等问题(#16.1 O, #16.16, #16.21, #16.24)，困难问题(#17.11, #17.26)。</p>
<p>提示从第 662 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-11--测试"><a class="header" href="#chapter-11--测试">Chapter 11 | 测试</a></h1>
<p>当你一边说“我又不是测试人员”，一边准备跳过本章时，请先停下来想一想。事实上，测试对于软件工程师来说是一项重要的工作，因此 ，在面试中可能会出现测试问题。当然，如果你正在申请测试的工作（或者测试开发工程师），那么你就更有理由注意这方面的问题。</p>
<p>测试问题通常可以分为四类：（1）测试真实世界的对象（比如一支笔）；（2）测试一个软件； （3）编写一个功能的测试代码； （4）对存在的问题进行故障排除。下面我们将介绍这四类情况的解决方法。</p>
<p>请记住，这四种情况下你最好不要假设输入或者用户会正常表现。对滥用的情况有心里准备，并为此做好计划。</p>
<h3 id="面试官看重的是什么"><a class="header" href="#面试官看重的是什么">面试官看重的是什么</a></h3>
<p>从表面上看，测试问题似乎只是在提出大量测试用例。在某种程度上，这是对的。你确实需要拿出一个合理的测试用例列表。</p>
<p>但除此之外，面试官还想测试以下几个方面：</p>
<ul>
<li>
<p><strong>全局理解</strong>：你是否了解软件的真正含义？ 你能否正确确定测试用例的优先级？ 例如，假设你被要求测试一个像 Amazon 这样的电商系统。确保在正确的位置显示产品图片非常重要，但更重要的是，付款应能可靠地工作，将产品添加到发货队列中，并且客户永远不会被重复收费。</p>
</li>
<li>
<p><strong>了解各个部分如何组合在一起</strong>：你是否了解软件是如何工作的，以及如何将其融入更大的生态系统中？ 假设要求你测试 Google Spreadsheets，对打开、保存和编辑文档进行测试很重要。但是，Google Spreadsheets 是更大的软件生态的一部分。你需要测试它与 Gmail、插件以及其他组件的集成。</p>
</li>
<li>
<p><strong>组织</strong>：你是用一种结构化的方式来处理问题，还是对你想到的任何东西只是脱口而出？有些求职者，当被要求给出一个相机的测试用例时，只会想到什么就说什么。一个好的候选人会将这些部分细分成几类，比如拍照、图像管理、设置等等。这种结构化方法还将帮助你更全面地创建测试用例。</p>
</li>
<li>
<p><strong>实用性</strong>：你真的能创建合理的测试计划吗？例如，如果用户报告说，当他们打开特定的图像时，软件崩溃了，而如果你只是告诉他们要重新安装软件，这通常是不太实际的。你的测试计划对于公司而言必须切实可行的。</p>
</li>
</ul>
<p>展示这些方面将证明你有能力成为测试团队中有价值的一员。</p>
<h3 id="测试真实世界的对象"><a class="header" href="#测试真实世界的对象">测试真实世界的对象</a></h3>
<p>有些应聘者被问到诸如如何测试一支笔之类的问题时会感到惊讶。毕竟，你应该测试软件，对吗？也许吧，但这些“现实世界”的问题仍然很常见。让我们通过一个例子来完成这个过程。</p>
<p>问题：你如何测试一个回形针？</p>
<h4 id="step-1谁会使用它-又为什么呢"><a class="header" href="#step-1谁会使用它-又为什么呢">Step 1：谁会使用它？ 又为什么呢？</a></h4>
<p>你需要与面试官讨论谁正在使用该产品，以及出于什么目的。答案可能不是你想的那样。答案可能是“老师，为了把文件放在一起”，也可以是“艺术家，为了弯曲成动物的形状”，或者是两者兼有。这个问题的答案将决定你如何处理剩下的问题。</p>
<h4 id="step-2有哪些用例"><a class="header" href="#step-2有哪些用例">Step 2：有哪些用例？</a></h4>
<p>对你来说，列出用例列表是很有用的。在当前情况下，用例可能只是简单地以不损坏纸张的方式将纸张固定在一起。</p>
<p>对于其他问题，可能有多个用例。例如，产品可能需要能够发送和接收内容，或者编写和删除内容，等等。</p>
<h4 id="step-3使用范围是什么"><a class="header" href="#step-3使用范围是什么">Step 3：使用范围是什么？</a></h4>
<p>使用范围可能意味着在一次使用中最多可持有 30 张纸而不会造成永久性损坏（例如，弯曲），以及 30 至 50 张纸只允许产生最小程度的永久性弯曲。</p>
<p>这个范围也可以扩展到到环境方面的因素。例如，回形针在非常温暖的温度（90~110 华氏度）下能够工作吗？那极度寒冷的情况下呢？</p>
<h4 id="step-4压力故障情况有哪些"><a class="header" href="#step-4压力故障情况有哪些">Step 4：压力/故障情况有哪些？</a></h4>
<p>没有产品是防故障（fail-proof）的，所以分析故障条件需要成为测试的一部分。和你的面试官好好谈谈什么时候产品故障是可以接受的（甚至是必要的），以及故障的含义是什么。</p>
<p>例如，如果要测试一台洗衣机，则可能会决定该洗衣机至少应能处理 30 件衬衫或裤子。装载 30~45 件衣服可能会导致轻微故障，例如衣服没有被充分清洗。如果衣服超过 45 件，极端的故障可能是可以接受的。但是，这种情况下的极端故障可能只是意味着机器永远不会打开水工作，这当然不应该意味着洪水或火灾。</p>
<h4 id="step-5你将如何执行测试"><a class="header" href="#step-5你将如何执行测试">Step 5：你将如何执行测试？</a></h4>
<p>在某些情况下，讨论执行测试的细节可能也很重要。例如，如果你需要确保一把椅子可以正常使用五年，你可能不能把它放在家里等五年。相反，你需要定义什么是“正常”使用（每年有多少人“坐在”这个座位上？扶手呢？）然后，除了进行一些手动测试之外，你可能还需要一台机器来自动化执行某些使用。</p>
<h3 id="测试一个软件"><a class="header" href="#测试一个软件">测试一个软件</a></h3>
<p>测试软件实际上与测试现实世界对象非常相似。主要区别在于，软件测试通常更加注重执行测试的细节。</p>
<p>请注意，软件测试有两个核心方面：</p>
<ul>
<li>
<p><strong>手动测试与自动化测试</strong>：在理想的情况下，我们可能希望使所有内容实现自动化，但这几乎是不可行的。有些东西用手工测试会更好，因为有些特性太定性，计算机无法有效地检查（比如内容是否是代表色情）。此外，尽管计算机通常只能识别被告知要查找的问题，但人类的观察可能会发现尚未专门检查的新问题。人和计算机都是测试过程的重要组成部分。</p>
</li>
<li>
<p><strong>黑盒测试与白盒测试</strong>：这一区别指的是我们对软件的访问程度。在黑盒测试中，我们只是按原样获得该软件，并需要对其进行测试。通过白盒测试，我们可以通过其他编程方式来测试各个功能。我们还可以自动化一些黑盒测试，尽管这肯定要困难得多。</p>
</li>
</ul>
<p>让我们从头到尾逐步介绍一种解决方法。</p>
<h4 id="step-1我们要进行黑盒测试还是白盒测试"><a class="header" href="#step-1我们要进行黑盒测试还是白盒测试">Step 1：我们要进行黑盒测试还是白盒测试？</a></h4>
<p>虽然这个问题通常可以推迟到后面的步骤，但我喜欢尽早解决它。询问面试官你是在做黑盒测试还是白盒测试，或者两者都做。</p>
<h4 id="step-2谁会使用它-又为什么呢"><a class="header" href="#step-2谁会使用它-又为什么呢">Step 2：谁会使用它？ 又为什么呢？</a></h4>
<p>软件通常具有一个或多个目标用户，并且在设计功能时考虑了这一点。例如，如果要求你在 Web 浏览器上测试用于家长控制的软件，则目标用户既包括父母（正在实施件屏蔽），也包括孩子（作为件屏蔽的接收者）。你可能还会有“客人”（既不应实施也不应该接受件屏蔽的人）。</p>
<h4 id="step-3有哪些用例"><a class="header" href="#step-3有哪些用例">Step 3：有哪些用例？</a></h4>
<p>在软件屏蔽场景中，针对父母的用例包括安装软件、更新控件、删除控件，当然还有他们自己的网络使用情况。对于儿童，用例包括访问合法内容和“非法”内容。</p>
<p>请记住，并不是由你来神奇地决定用例。这应该是你和面试官对话的结果。</p>
<h4 id="step-4使用范围是什么"><a class="header" href="#step-4使用范围是什么">Step 4：使用范围是什么？</a></h4>
<p>现在我们已经定义了模糊的用例，我们需要弄清楚这到底意味着什么。一个网站被屏蔽意味着什么？应该只屏蔽“非法”页面还是整个网站？应用程序应该“学习”什么是不良内容，还是基于白名单或黑名单？如果它想知道什么是不合适的内容，什么程度的误报（false positives）或漏报（false negatives）是可以接受的？</p>
<h4 id="step-5压力故障情况有哪些"><a class="header" href="#step-5压力故障情况有哪些">Step 5：压力/故障情况有哪些？</a></h4>
<p>当软件发生故障时（发生故障是不可避免的），故障应该是什么样的呢？显然，软件故障不应该使计算机崩溃。相反，软件应该只允许一个被屏蔽的站点，或者禁止一个被允许的站点。在后一种情况下，你可能需要讨论使用父母密码进行选择性覆盖的可能性。</p>
<h4 id="step-6有哪些测试用例-您将如何执行测试"><a class="header" href="#step-6有哪些测试用例-您将如何执行测试">Step 6：有哪些测试用例？ 您将如何执行测试？</a></h4>
<p>这就是手动测试和自动测试、黑盒测试和白盒测试之间的区别真正发挥作用的地方。</p>
<p>step 3 和 4 应该大致定义了用例。在 step 6 中，我们进一步定义它们，并讨论如何执行测试。你测试的具体情况是什么？这些步骤中哪些可以自动化？哪些需要人工干预？</p>
<p>请记住，虽然自动化可以让你进行一些非常强大的测试，但它也有一些明显的缺点。手动测试通常应该是测试程序的一部分。</p>
<p>当你浏览这张清单时，不要一口气说出你能想到的每一个场景。它是杂乱无章的，你肯定会错过主要类别。相反，应该以结构化的方式处理这个问题。将你的测试分解为主要组件，然后从那里开始。这样你不仅可以给出一个更完整的测试用例列表，而且还会显示出你是一个结构化、有条理的人。</p>
<h3 id="测试一个功能"><a class="header" href="#测试一个功能">测试一个功能</a></h3>
<p>在许多方面，测试一个功能是最简单的测试类型。由于测试通常仅限于验证输入和输出，所以对话通常更简短，也不那么模糊。</p>
<p>但是，请不要忽略与面试官交谈的价值。您应该与面试官讨论任何假设，特别是关于如何处理特定情况。</p>
<p>假设你被要求编写代码来测试 sort(int[] array)，该方法对整数数组进行排序。你可以按照以下步骤进行。</p>
<h4 id="step-1-定义测试用例"><a class="header" href="#step-1-定义测试用例">Step 1： 定义测试用例</a></h4>
<p>通常，你应该考虑以下类型的测试用例：</p>
<ul>
<li>
<p><strong>正常情况</strong>：它为典型输入生成正确的输出吗？记住，这里要考虑潜在的问题。例如，由于排序通常需要某种类型的划分，因此可以合理地认为该算法可能会在元素数量为奇数的数组上失败，因为它们无法均匀划分。你的测试用例应列出这两个例子。</p>
</li>
<li>
<p><strong>极端情况</strong>：传入空数组时会发生什么？或者一个非常小的（一个元素）数组？如果你传入一个很大的呢？</p>
</li>
<li>
<p><strong>Null 和“非法”输入</strong>：当给定非法输入时，代码应该如何表现是值得考虑的。例如，如果你测试一个可以生成第n个斐波那契数的功能，那么你的测试用例应该包括 n 为负的情况。</p>
</li>
<li>
<p><strong>奇怪的输入</strong>：有时会出现第四种输入：奇怪的输入。当传入一个已经排序的数组时会发生什么？或者是一个倒序排列的数组？</p>
</li>
</ul>
<p>生成这些测试确实需要你了解正在编写的功能。如果你不清楚这些限制，你需要先问面试官。</p>
<h4 id="step-2定义预期的结果"><a class="header" href="#step-2定义预期的结果">Step 2：定义预期的结果</a></h4>
<p>通常，预期的结果是显而易见的：正确的输出。然而，在某些情况下，你可能希望验证其他方面。例如，如果 sort 方法返回数组的新排序副本，则你可能应该验证原始数组是否没有被修改。</p>
<h4 id="step-3编写测试代码"><a class="header" href="#step-3编写测试代码">Step 3：编写测试代码</a></h4>
<p>一旦定义了测试用例和结果，编写用于实现测试用例的代码就应该非常简单。你的代码可能是这样的：</p>
<pre><code class="language-java">1 	void testAddThreeSorted() {
2 		Mylist list = new Mylist();
3 		list.addThreeSorted(3, 1, 2); // Adds 3 items in sorted order
4 		assertEquals(list.getElement(0), 1);
5 		assertEquals(list.getElement(1), 2);
6 		assertEquals(list.getElement(2), 3);
7 	}
</code></pre>
<h3 id="故障排除问题"><a class="header" href="#故障排除问题">故障排除问题</a></h3>
<p>最后一种问题是说明如何调试或解决现有问题。许多候选人都对这样的问题不屑一顾，给出了不切实际的答案，例如“重新安装软件”。实际上你可以像对待其他事情一样，用一种结构化的方式来处理这些问题。</p>
<p>让我们通过一个例子来解决这个问题：当你在 Google Chrome 团队中工作时，收到了一个bug报告：Chrome 在启动时崩溃。你会怎么做？</p>
<p>重新安装浏览器可能会解决该用户的问题，但对其他可能遇到相同问题的用户没有帮助。你的目标应该是了解实际发生了什么，以便开发人员可以对其进行修复。</p>
<h4 id="step-1了解情况"><a class="header" href="#step-1了解情况">Step 1：了解情况</a></h4>
<p>你应该做的第一件事是问问题，尽可能多地了解情况。</p>
<ul>
<li>
<p>用户遇到这个问题有多久了？</p>
</li>
<li>
<p>这是什么版本的浏览器？什么操作系统？</p>
</li>
<li>
<p>这个问题经常发生吗？或者多久发生一次？什么时候发生？</p>
</li>
<li>
<p>是否有启动错误报告？</p>
</li>
</ul>
<h4 id="step-2-解决问题"><a class="header" href="#step-2-解决问题">Step 2： 解决问题</a></h4>
<p>既然你已经了解了该场景的详细信息，您就可以将问题分解为可测试的单元。在这种情况下，你可以想象情况的流程如下：</p>
<ol>
<li>
<p>进入 Windows 开始菜单。</p>
</li>
<li>
<p>单击 Chrome 图标。</p>
</li>
<li>
<p>浏览器实例启动。</p>
</li>
<li>
<p>浏览器加载设置。</p>
</li>
<li>
<p>浏览器发出 HTTP 主页请求。</p>
</li>
<li>
<p>浏览器获得 HTTP 响应。</p>
</li>
<li>
<p>浏览器解析网页。</p>
</li>
<li>
<p>浏览器显示内容。</p>
</li>
</ol>
<p>在此过程中的某个时刻，某些操作会失败，并导致浏览器崩溃。一个强大的测试人员将遍历可能导致此场景的各个因素以诊断问题。</p>
<h4 id="step-3创建特定的可管理的测试"><a class="header" href="#step-3创建特定的可管理的测试">Step 3：创建特定的，可管理的测试</a></h4>
<p>以上每个组件都应具有切合实际的说明——你可以要求用户执行的操作或可以自己执行的操作（例如，在自己的计算机上复制步骤）。在现实世界中，你将与客户打交道，并且你不能给他们下达他们不能或不愿做的指示。。</p>
<hr />
<h3 id="interview-questions-11"><a class="header" href="#interview-questions-11">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>11.1 错误（Mistake）</strong>：找出下列代码中的错误:</p>
<pre><code class="language-c++">unsigned int i;
for (i = 100; i &gt;= 0; --i)
printf("%d\n", i);
</code></pre>
<p><em>提示：#257, #299, #362</em></p>
</li>
<li>
<p><strong>11.2 随机崩溃（Random Crashes）</strong>：给定一个在运行时崩溃的应用源代码。在调试器中运行十次之后，你会发现它不会在同一个地方崩溃。应用程序是单线程的，并且只使用 C 标准库。哪些编程错误可能导致这个崩溃？你将如何测试每一个？</p>
<p><em>提示：#325</em></p>
</li>
<li>
<p><strong>11.3 象棋测试（ChessTest）</strong>：我们在国际象棋游戏中使用以下方法：<code>boolean canMoveTo(int x, int y)</code>。此方法是 Piece 类的一部分，并返回棋子是否可以移动到位置 <code>(x, y)</code>。解释如何测试这个方法。</p>
<p><em>提示：#329, #401</em></p>
</li>
<li>
<p><strong>11.4 没有测试工具（No Test Tools）</strong>：不使用任何测试工具，如何对网页进行负载测试？</p>
<p><em>提示：#313, #345</em></p>
</li>
<li>
<p><strong>11.5 测试笔（Test a Pen）</strong>：你将如何测试一支笔？</p>
<p><em>提示：#140, #164, #220</em></p>
</li>
<li>
<p><strong>11.6 测试ATM（Test an ATM）</strong>：你将如何测试分布式银行系统中的 ATM ？</p>
<p><em>提示：#210, #225, #268, #349, #393</em></p>
</li>
</ul>
<p>提示从第 662 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-12--c-和-c"><a class="header" href="#chapter-12--c-和-c">Chapter 12 | C 和 C++</a></h1>
<p>一个好的面试官不会要求你用自己不懂的语言来写代码。希望，如果你被要求使用 C++ 进行编码，其本身已在你的简历中列出。如果你不记得所有的 APl，不要担心，因为大多数面试官（虽然不是所有）都不太在意。但是，我们建议你学习基本的 C++ 语法，这样你就可以轻松地处理这些问题。</p>
<h3 id="类和继承"><a class="header" href="#类和继承">类和继承</a></h3>
<p>虽然 C++ 类具有与其他语言类似的特性，但我们将在下面回顾一些语法。</p>
<p>下面的代码演示了带有继承的基本类的实现。</p>
<pre><code class="language-java">1 	#include &lt;iostream&gt;
2 	using namespace std;
3
4 	#define NAME_SIZE 50 // Defines a macro
5
6 	class Person {
7 		int id; // all members are private by default
8 		char name[NAME_SIZE];
9
10 	 public:
11 		void aboutMe() {
12 			cout &lt;&lt; "I am a person.";
13		}
14 	};
15
16 	class Student : public Person {
17 	 public:
18 		void aboutMe() {
19 			cout &lt;&lt; "I am a student.";
20		}
21 	};
22
23 	int main() {
24 		Student * p = new Student();
25 		p-&gt;aboutMe(); // prints "I am a student."
26 		delete p; // Important! Make sure to delete allocated memory.
27 		return 0;
28 	}
</code></pre>
<p>在 C++ 中，所有数据成员和方法在默认情况下都是私有的。可以通过引入关键字 public 来对此进行修改。</p>
<h3 id="构造函数与析构函数"><a class="header" href="#构造函数与析构函数">构造函数与析构函数</a></h3>
<p>类的构造函数在对象创建时自动调用。如果没有定义构造函数，编译器将自动生成一个称为默认构造函数的构造函数。或者，我们可以定义自己的构造函数。</p>
<p>如果你只需要初始化基本类型，一个简单的方法是：</p>
<pre><code class="language-java">1 	Person(int a) {
2 		id = a;
3 	}
</code></pre>
<p>这适用于基本类型，但你可能想要这样做：</p>
<pre><code class="language-java">1 	Person(int a) : id(a) {
2 		...
3 	}
</code></pre>
<p>在创建实际对象之前，以及调用构造函数代码的其余部分之前，分配数据成员 id。当字段是常量或 class 类型时，这种方法是必要的。</p>
<p>析构函数在对象删除时进行清理，并在对象被销毁时自动调用。它不能接受参数，因为我们没有显式地调用析构函数。</p>
<pre><code class="language-java">1 	~Person() {
2 		delete obj; // free any memory allocated within class
3 	}
</code></pre>
<h3 id="虚函数"><a class="header" href="#虚函数">虚函数</a></h3>
<p>在前面的示例中，我们将 p 定义为 Student 类型：</p>
<pre><code class="language-java">1 	Student * p = new Student();
2 	p-&gt;aboutMe();
</code></pre>
<p>如果像这样将 p 定义为 Person *，会发生什么？</p>
<pre><code class="language-java">1 	Person * p = new Student();
2 	p-&gt;aboutMe();
</code></pre>
<p>在这种情况下，将改为打印 “I am a person”。这是因为 aboutMe 函数是在编译时通过一种称为静态绑定的机制解析的。</p>
<p>如果要确保调用 Student 的 aboutMe 实现，可以在 Person 类中将aboutMe 定义为 virtual。</p>
<pre><code class="language-java">1 	class Person {
2		...
3 		virtual void aboutMe() {
4 			cout &lt;&lt; "I am a person.";
5		}
6	};
7
8 	class Student : public Person {
9 	 public:
10 		void aboutMe() {
11 			cout &lt;&lt; "I am a student.";
12		}
13 	};
</code></pre>
<p>虚拟函数的另一种用法是当我们不能（或不想）为父类实现方法时。例如，想象一下，我们希望 Student 和 Teacher 从 Person 继承，以便我们可以实现诸如 addCourse(string s) 之类的通用方法。但是，对 Person 调用 addCourse 并没有多大意义，因为实现取决于对象是 Student 还是 Teacher。</p>
<p>在这种情况下，我们可能希望 addCourse 是在 Person 中定义的虚函数，实现留给子类处理。</p>
<pre><code class="language-java">1 	class Person {
2 		int id;// all members are private by default
3 		char name[NAME_SIZE];
4 	 public:
5 		virtual void aboutMe() {
6 			cout &lt;&lt; "I am a person." &lt;&lt; endl;
7		}
8 		virtual bool addCourse(string s) = 0;
9	};
10
11 	class Student : public Person {
12 	 public:
13 		void aboutMe() {
14 			cout &lt;&lt; "I am a student." &lt;&lt; endl;
15		}
16
17 		bool addCourse(string s) {
18 			cout &lt;&lt; "Added course " &lt;&lt; s &lt;&lt; "to student." &lt;&lt; endl;
19 			return true;
20		}
21 	};
22
23 	int main() {
24		Person * p = new Student();
25		p-&gt;aboutMe(); // prints "I am a student."
26		p-&gt;addCourse("History");
27		delete p;
28 	}
</code></pre>
<p>请注意，通过将 addCourse 定义为”纯虚函数“，Person 现在是抽象类，我们无法实例化它。</p>
<h3 id="虚析构函数"><a class="header" href="#虚析构函数">虚析构函数</a></h3>
<p>虚函数自然会引入“虚析构函数”的概念。假设我们想为 Person 和 Student 实现一个析构函数方法。一个简单的解决方案可能是这样的：</p>
<pre><code class="language-java">1 	class Person {
2 	 public:
3 		~Person() {
4 			cout &lt;&lt; "Deleting a person." &lt;&lt; endl;
5		}
6	};
7
8 	class Student public Person {
9 	 public:
10 		~Student() {
11 			cout &lt;&lt; "Deleting a student." &lt;&lt; endl;
12		}
13	};
14
15 	int main() {
16 		Person * p new Student();
17 		delete p; // prints "Deleting a person."
18 	}
</code></pre>
<p>与前面的示例一样，由于 p 是一个 Person，所以调用 Person 类的析构函数。这是有问题的，因为可能无法清除 Student 的内存。</p>
<p>要解决这个问题，我们只需将 Person 的析构函数定义为 virtual。</p>
<pre><code class="language-java">1 	class Person {
2 	 public:
3 		virtual ~Person() {
4 			cout &lt;&lt; "Deleting a person." &lt;&lt; endl;
5		}
6	};
7
8 	class Student : public Person {
9 	 public:
10 		~Student() {
11 			cout &lt;&lt; "Deleting a student." &lt;&lt; endl;
12		}
13 	};
14
15 	int main() {
16 		Person * p new Student();
17 		delete p;
18	
</code></pre>
<p>这将输出以下内容：</p>
<pre><code>Deleting a student.
Deleting a person.
</code></pre>
<h3 id="缺省值"><a class="header" href="#缺省值">缺省值</a></h3>
<p>函数可以指定默认值，如下所示。请注意，所有默认参数都必须在函数声明的右侧，因为没有其他方法可以指定参数的排列方式。</p>
<pre><code class="language-java">1 	int func(int a, int b = 3) {
2 		X = a;
3 		y = b;
4 		return a + b;
5 	}
6
7 	w = func(4);
8 	z = func(4, 5);
</code></pre>
<h3 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h3>
<p>运算符重载使我们能够将 <code>+</code> 等运算符应用于原本不支持这些运算的对象。例如，如果我们想将两个 BookShelves 合并为一个，可以按如下方式重载 <code>+</code> 运算符。</p>
<pre><code class="language-java">1 Bookshelf BookShelf::operator+(BookShelf &amp;other) { ... }
</code></pre>
<h3 id="指针与引用"><a class="header" href="#指针与引用">指针与引用</a></h3>
<p>指针保存变量的地址，并可用于执行允许直接在变量上执行的任何操作，比如访问和修改变量。</p>
<p>两个指针可以彼此相等，因此更改其中一个指针的值也将更改另一个指针的值（因为它们实际上指向相同的地址）。</p>
<pre><code class="language-java">1 	int * p new int;
2 	*p = 7;
3 	int * q = p;
4 	*p = 8;
5 	cout &lt;&lt; * q; // prints 8
</code></pre>
<p>请注意，指针的大小根据体系结构而有所不同：32位计算机上为32位，而64位计算机上为64位。请注意这种差异，因为面试官通常会问数据结构到底占多大的空间。</p>
<h4 id="引用"><a class="header" href="#引用">引用</a></h4>
<p>引用是预先存在（pre-existing）的对象的另一个名称（别名），它没有自己的内存。例如：</p>
<pre><code class="language-java">1 	int a = 5;
2 	int &amp; b = a;
3 	b = 7;
4 	cout &lt;&lt; a; // prints 7
</code></pre>
<p>在上面第 2 行，b 是对 a 的引用，修改 b 也会修改 a。</p>
<p>如果不指定引用在内存中的位置，则无法创建引用。但是，你可以创建如下所示的独立参考：</p>
<pre><code class="language-java">1	/* allocates memory to store 12 and makes b a reference to this
2 	 * piece of memory.*/
3 	const int &amp; b = 12;
</code></pre>
<p>与指针不同，引用不能为 null，也不能重新分配给另一块内存。</p>
<h4 id="指针算法"><a class="header" href="#指针算法">指针算法</a></h4>
<p>人们经常会看到程序员在指针上执行加法运算，例如下面所示：</p>
<pre><code class="language-java">1 	int * p = new int[2];
2 	p[0] = 0;
3 	p[1] = 1;
4 	p++;
5 	cout &lt;&lt; *p; // Outputs 1
</code></pre>
<p>执行 p++ 将向前跳过 sizeof(int) 个字节，这样代码输出为 1。如果 p 是不同类型的，它将跳过与数据结构大小相同的字节。</p>
<h3 id="模板"><a class="header" href="#模板">模板</a></h3>
<p>模板是一种重用代码的方法，可以将相同的类应用于不同的数据类型。例如，我们可能有一个类似列表的数据结构，我们希望将其用于各种类型的列表。下面的代码使用 Shiftedlist 类实现了这一点。</p>
<pre><code class="language-java">1 	template &lt;class T&gt;class ShiftedList {
2 		T* array;
3 		int offset, size;
4 	public:
5 		Shiftedlist(int sz) : offset(0), size(sz) {
6 			array= new T[size];
7		}
8
9 		~Shiftedlist() {
10 			delete [] array;
11		}
12
13 		void shiftBy(int n) {
14 			offset = (offset + n) % size;
15		}
16
17 		T getAt(int i) {
18 			return array[convertindex(i)];
19		}
20
21 		void setAt(T item, int i) {
22 			array[convertindex(i)] = item;
23		}
24
25 	private:
26 		int convertlndex(int i) {
27 			int index = (i - offset) % size;
28 			while (index &lt; 0) index += size;
29 			return index;
30		}
31	};
</code></pre>
<hr />
<h3 id="interview-questions-12"><a class="header" href="#interview-questions-12">Interview Questions</a></h3>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-13--java"><a class="header" href="#chapter-13--java">Chapter 13 | Java</a></h1>
<p>虽然在本书中可以找到与 Java 相关的问题，但本章还讨论了有关语言和语法的问题。这类问题在大公司面试中更不常见，因为大公司更看重测试求职者的能力，而不是求职者的知识（而且他们有时间和资源培训求职者使用一种特定的语言）。然而，在其他公司，这些烦人的问题可能相当常见。</p>
<h3 id="如何处理-2"><a class="header" href="#如何处理-2">如何处理</a></h3>
<p>由于这些问题过于关注知识，因此谈论解决这些问题的方法似乎有些愚蠢。毕竟，这不就只是知道正确的答案就可以了吗？</p>
<p>当然，要掌握这些问题，最好的方法是彻底地学习Java。</p>
<p>但是，如果你真的被难住了，你可以试着用下面的方法来解决：</p>
<ol>
<li>
<p>创建一个场景示例，并问自己事情应该如何发展。</p>
</li>
<li>
<p>问问自己其他语言如何处理这种情况。</p>
</li>
<li>
<p>考虑一下，如果你是语言设计师，你将如何设计这种情况。每种选择的含义是什么？</p>
</li>
</ol>
<p>如果你能推导出答案而不是机械地记忆答案，那么你的面试官可能会对你的表现留下同样的或更深刻的印象。不过，不要试图虚张声势。你可以告诉面试官：“我不确定我是否能回忆起答案，但让我看看能否弄明白。假设我们有这个代码......”</p>
<h3 id="重载-vs-重写"><a class="header" href="#重载-vs-重写">重载 vs 重写</a></h3>
<p>重载（Overloading）是一个术语，用于描述两个方法具有相同的名称，但是参数的类型或数量不同。</p>
<pre><code class="language-java">1 	public double computeArea(Circle c) { ... }
2 	public double computeArea(Square s) { ... }
</code></pre>
<p>但是，当方法与其超类中的另一个方法具有相同的名称和函数签名时，就会发生覆盖（Overriding）。</p>
<pre><code class="language-java">1 	public abstract class Shape {
2 		public void printMe() {
3 			System.out.println("I am a shape.");
4		}
5 		public abstract double computeArea();
6 	}
7
8 	public class Circle extends Shape {
9 		private double rad= 5;
10 		public void printMe() {
11 			System.out.println("I am a circle.");
12		}
13
14 		public double computeArea() {
15 			return rad * rad * 3.15;
16		}
17 	}
18
19 	public class Ambiguous extends Shape {
20 		private double area= 10;
21 		public double computeArea() {
22 			return area;
23		}
24	}
25
26 	public class IntroductionOverriding {
27 		public static void main(String[] args) {
28 			Shape[] shapes = new Shape[2];
29 			Circle circle = new Circle();
30 			Ambiguous ambiguous = new Ambiguous();
31
32			shapes[0] = circle;
33			shapes[l] = ambiguous;
34
35 			for (Shape s : shapes) {
36 				s.printMe();
37 				System.out.println(s.computeArea());
38			}
39		}
40	}
</code></pre>
<p>上面的代码运行结果打印如下：</p>
<pre><code>1 I am a circle.
2 78.75
3 I am a shape.
4 10.0
</code></pre>
<p>注意，Circle 类中覆盖了 printMe( )，而 Ambiguous 类中则保留了这个方法的原样。</p>
<h3 id="集合框架"><a class="header" href="#集合框架">集合框架</a></h3>
<p>Java的集合框架非常有用，你将在本书中看到它的使用。以下是一些最有用的几项：
ArrayList：ArrayList 是一个动态调整大小的数组，在插入元素时会增长。</p>
<pre><code class="language-java">1 	Arraylist&lt;String&gt; myArr = new Arraylist&lt;String&gt;();
2 	myArr.add("one");
3 	myArr.add("two");
4 	System.out.println(myArr.get(0)); /* prints &lt;one&gt; */
</code></pre>
<p>Vector：Vector 与 Arraylist 非常相似，只是它是同步的（synchronized）。它们的语法也几乎相同。</p>
<pre><code class="language-java">1 	Vector&lt;String&gt; myVect new Vector&lt;String&gt;();
2 	myVect.add("one");
3 	myVect.add("two") ;
4 	system.out.printin(myVect.get(0));
</code></pre>
<p>LinkedList：LinkedList 指的就是 Java 的内置 LinkedList 类。虽然很少在面试中出现，但是学习它很有用，因为它演示了迭代器（iterator）的一些语法。</p>
<pre><code class="language-java">1 	Linkedlist&lt;String&gt; mylinkedlist = new Linkedlist&lt;String&gt;();
2 	mylinkedlist.add("two");
3 	myLinkedList.addFirst("one");
4 	Iterator&lt;String&gt; iter = mylinkedlist.iterator();
5 	while (iter.hasNext()) {
6 		System.out.println(iter.next());
7 	}
</code></pre>
<p>HashMap：HashMap 集合无论是在面试中，还是在实际工作中都被广泛地使用。我们提供了以下语法的片段。</p>
<pre><code class="language-java">1 	HashMap&lt;String, String&gt; map= new HashMap&lt;String, String&gt;();
2 	map.put("one", "uno");
3 	map.put("two", "dos");
4 	System.out.println(map.get("one"));
</code></pre>
<p>在面试之前，确保你对上面的语法非常熟悉。你会需要它。</p>
<hr />
<h3 id="interview-questions-13"><a class="header" href="#interview-questions-13">Interview Questions</a></h3>
<hr />
<p>请注意，由于本书中几乎所有的解决方案都是用 Java 实现的，因此本章我们仅选择了少数问题。此外，这些问题中的大多数都是关于语言的“琐事（trivia）”，因为本书的其余部分都是关于 Java 编程的问题。</p>
<ul>
<li>
<p><strong>13.1 私有构造函数（Private Constructor）</strong>：在继承方面，保持构造函数私有的作用是什么？</p>
<p><em>提示：#404</em></p>
</li>
<li>
<p><strong>13.2 从 Finally 返回（Return from Finally）</strong>：在 Java 中，如果我们在 try-catch- Finally 的 try 块中插入一个 return 语句，那么 Finally 块会被执行吗？</p>
<p><em>提示：#409</em></p>
</li>
<li>
<p><strong>13.3 Final等（Final, etc.）</strong>：final、finally 和 finalize 的区别是什么？</p>
<p><em>提示：#412</em></p>
</li>
<li>
<p><strong>13.4 泛型与模板（Generics vs. Templates）</strong>：解释 C++ 中的模板与 Java 中的泛型的区别。</p>
<p><em>提示：#416, #425</em></p>
</li>
<li>
<p><strong>13.5 TreeMap, HashMap, LinkedHashMap</strong>：解释 TreeMap、HashMap 和 LinkedHashMap 之间的区别。提供一个例子，说明什么时候使用哪个是最好的。</p>
<p><em>提示：#420, #424, #430, #454</em></p>
</li>
<li>
<p><strong>13.6 对象反射（Object Reflection）</strong>：解释 Java 中什么是对象反射以及为什么有用。</p>
<p><em>提示：#435</em></p>
</li>
<li>
<p><strong>13.7 Lambda表达式（Lambda Expressions）</strong>：有一个 Country 类，它有方法 <code>getContinent()</code> 和 <code>getPopulation()</code>。编写一个函数 <code>int getPopulation(List&lt;Country&gt; countries, String continent)</code>，计算给定大陆的总人口，并给出所有国家/地区的列表以及大陆的名称。</p>
<p><em>提示：#448, #467, #464</em></p>
</li>
<li>
<p><strong>13.8 Lambda Random</strong>：使用 Lambda 表达式，编写一个函数 <code>List&lt;Integer&gt; getRandomSubset ( List&lt; Integer&gt; list)</code>， 以返回任意大小的随机子集。所有的子集（包括空集）被选择的概率都应该是相同的。</p>
<p><em>提示：#443, #450, #457</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：数组和字符串(#1.3)，面向对象设计(#7.12)，线程和锁(#15.3)</p>
<p>提示从第 676 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-14--数据库"><a class="header" href="#chapter-14--数据库">Chapter 14 | 数据库</a></h1>
<p>如果你了解数据库知识，则可能会被问到一些有关数据库的问题。本章我们将回顾一些关键概念，并概述如何解决这些问题。在阅读这些查询语句时，不要对语法上的细微变化感到惊讶。SQL有多种风格，你可能只是使用了稍微不同的一种。本书中的示例已针对 Microsoft SQL Server 进行了测试。</p>
<h3 id="sql-语法和变体"><a class="header" href="#sql-语法和变体">SQL 语法和变体</a></h3>
<p>隐式连接（implicit join）和显式连接（explicit join）如下所示。这两种说法是等价的，选择哪一种是个人偏好的问题。为了保持一致，我们将坚持使用显式连接。</p>
<div class="table-wrapper"><table><thead><tr><th>显式连接</th><th>隐式连接</th></tr></thead><tbody>
<tr><td>1 SELECT CourseName, TeacherName <br/>2 FROM Courses INNER JOIN Teachers<br/>3 ON Courses.TeacherID = Teachers.TeacherID</td><td>1 SELECT CourseName, TeacherName<br/>2 FROM   Courses, Teachers<br/>3 WHERE Courses.TeacherID =<br/>4               Teachers.TeacherID</td></tr>
</tbody></table>
</div>
<h3 id="反规范化数据库与规范化数据库"><a class="header" href="#反规范化数据库与规范化数据库">反规范化数据库与规范化数据库</a></h3>
<p>规范化数据库（Normalized Databases ）旨在最大程度地减少冗余，而反规范化数据库（Denormalized databases ，译者注，即反模式）旨在优化读取时间。</p>
<p>在传统的规范化数据库中，例如有 Courses 和 Teachers 两个数据库表，Courses 可能包含一个名为TeacherID 的列，它是 Teacher 的外键。这样做的一个好处是，关于老师的信息（姓名、地址等）只在数据库中存储一次。缺点是许多常见查询需要昂贵的连接。</p>
<p>相反，我们可以通过存储冗余数据来对数据库进行反规范化。例如，如果我们知道必须经常重复这个查询，我们可能会将老师的名字存储在 Courses 表中。反规范化通常用于创建高度可扩展的系统。</p>
<h3 id="sql-语句"><a class="header" href="#sql-语句">SQL 语句</a></h3>
<p>让我们以前面提到的数据库为例，回顾一下基本的 SQL 语法。该数据库具有以下简单结构（*表示主键）：</p>
<pre><code class="language-sql">Courses： CourseID*, CourseName, TeacherID 
Teachers： TeacherID*, TeacherName 
Students： StudentID*, StudentName
StudentCourses： CourseID*, StudentID*
</code></pre>
<p>使用上面的表，实现以下查询。</p>
<h4 id="查询-1学生注册人数"><a class="header" href="#查询-1学生注册人数">查询 1：学生注册人数</a></h4>
<p>实现一个查询来获得所有学生的列表以及每个学生注册了多少门课程</p>
<p>首先，我们可以尝试如下操作：</p>
<pre><code class="language-sql">1 /* Incorrect Code */
2 SELECT Students.StudentName, count（*）
3 FROM Students INNER JOIN StudentCourses
4 ON Students.StudentID = StudentCourses.StudentID 
5 GROUP BY Students.StudentID
</code></pre>
<p>这有三个问题：</p>
<ol>
<li>我们排除了未注册任何课程的学生，因为 StudentCourses 仅包括已注册的学生。我们需要将其更改为左连接（LEFT JOIN）。</li>
<li>即使我们将其更改为左连接（LEFT JOIN），查询仍然不太正确。进行 count(*) 将返回给定的一组StudentID 中有多少个项目。选修零门课程的学生在他们的小组里仍然有一个项目。我们需要将其更改成计算每个组中的 CourseID 的数量：count(StudentCourses.CourseID)。</li>
<li>我们已经按 Student.StudentID 分组了，但是每个组中仍然有多个 StudentName。数据库将如何知道要返回哪个 StudentName？ 当然，它们可能都具有相同的值，但是数据库是不知道这一点的。我们需要对此应用一个聚合函数，例如 first(Students.StudentName)。</li>
</ol>
<p>解决这些问题后，我们可以执行以下查询：</p>
<pre><code class="language-sql">1 /* Solution 1： Wrap with another query */
2 SELECT StudentName, Students.StudentID, Cnt
3 FROM(
4 	SELECT Students.StudentID, count(StudentCourses.CourseID) as [Cnt]
5 	FROM Students LEFT JOIN StudentCourses
6 	ON Students.StudentID = StudentCourses.StudentID
7 	GROUP BY Students.StudentID
8 ) T INNER JOIN Students on T.studentID = Students.StudentID
</code></pre>
<p>查看这段代码，有人可能会问，为什么我们不直接在第 3 行中选择学生名，以避免必须使用另一个查询来包装第 3 到第 6 行。这种（不正确的）解决方案如下所示。</p>
<pre><code class="language-sql">1 /* Incorrect Code */
1 SELECT StudentName, Students.StudentID, count（StudentCourses.CourseID） as [Cnt]
2 FROM Students LEFT JOIN StudentCourses
3 ON Students.StudentID = StudentCourses.StudentID
4 GROUP BY Students.StudentID
</code></pre>
<p>答案是，我们不能那样做——至少不能完全像上面展示的那样。我们只能选择聚合函数或 GROUP BY 子句中的值。</p>
<p>或者，我们可以通过以下两种方法之一解决上述问题：</p>
<pre><code class="language-sql">1 /* Solution 2： Add StudentName to GROUP BY clause. */
2 SELECT StudentName, Students.StudentID, count(StudentCourses.CourseID) as [Cnt]
3 FROM Students LEFT JOIN StudentCourses
4 ON Students.StudentID = StudentCourses.StudentID
5 GROUP BY Students.StudentID, Students.StudentName
</code></pre>
<p>或</p>
<pre><code class="language-sql">1 /* Solution 3： Wrap with aggregate function. */
2 SELECT max(StudentName) as [StudentName], Students.StudentID,
3 		count(StudentCourses.CourseID) as [Count]
4 FROM Students LEFT JOIN StudentCourses
5 ON Students.StudentID = StudentCourses.StudentID
6 GROUP BY Students.StudentID
</code></pre>
<h4 id="查询-2教师班级规模"><a class="header" href="#查询-2教师班级规模">查询 2：教师班级规模</a></h4>
<p>实现一个查询，以获得所有教师和每个教师教多少学生的列表。如果一个老师教同一个学生两门课，你应该重复计算这个学生。按老师所教学生人数的降序排列。</p>
<p>我们可以逐步构建这个查询。首先，让我们获取 TeacherID 的列表以及与每个 TeacherID 关联的学生人数。这与先前的查询非常相似。</p>
<pre><code class="language-sql">1 SELECT TeacherID, count(StudentCourses.CourseID) AS [Number]
2 FROM Courses INNER JOIN StudentCourses
3 ON Courses.CourseID = StudentCourses.CourseID
4 GROUP BY Courses.TeacherID
</code></pre>
<p>请注意，这个内连接（INNER JOIN）不会选择不上课的老师。当我们将其与所有教师列表连接时，我们将在下面的查询中进行处理。</p>
<pre><code class="language-sql">1 SELECT TeacherName, is null(StudentSize.Number, 0)
2 FROM Teachers LEFT JOIN
3 		(SELECT TeacherID, count(StudentCourses.CourseID) AS [Number]
4 		FROM Courses INNER JOIN StudentCourses
5 		ON Courses.CourseID = StudentCourses.CourseID
6 		GROUP BY Courses.TeacherID) StudentSize
7 ON Teachers.TeacherID = StudentSize.TeacherID
8 ORDER BY StudentSize.Number DESC
</code></pre>
<p>注意上面我们是如何处理 SELECT 语句中的 NULL 值以将 NULL 值转换为零的。</p>
<h3 id="小型数据库设计"><a class="header" href="#小型数据库设计">小型数据库设计</a></h3>
<p>此外，可能会要求你设计自己的数据库。我们将为你介绍一种方法。你可能会注意到此方法与面向对象设计方法之间的相似性。</p>
<h4 id="step-1处理歧义"><a class="header" href="#step-1处理歧义">Step 1：处理歧义</a></h4>
<p>数据库问题常常有意或无意地有一些歧义。在进行设计之前，你必须确切地了解设计需求。</p>
<p>假设你被要求设计一个代表公寓租赁公司的系统。你需要知道这个中介机构是在多个地点还是只有一个。你也应该和你的面试官讨论该系统的使用情况应该有多普遍。例如，一个人在同一栋楼里租两套公寓是非常罕见的。但这是否意味着你不需要有能力处理这些情况呢？也许是，也许不是。一些非常罕见的情况最好通过工作来处理（例如，在数据库中复制此人的联系信息）。</p>
<h4 id="step-2定义核心对象"><a class="header" href="#step-2定义核心对象">Step 2：定义核心对象</a></h4>
<p>接下来，我们应该看一下系统的核心对象。这些核心对象通常每个都转换为一个表。在这种情况下，我们的核心对象可能是 Property、Building、Apartment、Tenant 和 Manager。</p>
<h4 id="step-3分析关系"><a class="header" href="#step-3分析关系">Step 3：分析关系</a></h4>
<p>列出核心对象可以让我们更好地了解表应该是什么。这些表是如何相互关联的？他们是多对多的吗？一对多吗？</p>
<p>如果 Building 与 Apartment 是一对多关系（一栋 Building 有很多 Apartment），那么我们可以这样表示：</p>
<div align=center><img src="img/ch14_1.png"/></div>
请注意，Apartments 表通过一个 BuildingID 列连接到 Buildings 表。
<p>如果我们要考虑一个人租多套公寓的可能性，我们可能需要实现多对多关系，如下所示：</p>
<div align=center><img src="img/ch14_2.png"/></div>
TenantApartments 表存储了 Tenants 和 Apartments 之间的关系。
<h4 id="step-4研究操作"><a class="header" href="#step-4研究操作">Step 4：研究操作</a></h4>
<p>最后，我们完成细节。逐步执行将要采取的常见操作，并了解如何存储和检索相关数据。我们将需要处理租赁条款、搬迁、租金支付等操作。这些操作都需要新的表和列。</p>
<h3 id="大型数据库设计"><a class="header" href="#大型数据库设计">大型数据库设计</a></h3>
<p>设计大型可伸缩数据库时，连接（在上面的示例中是必需的）通常非常慢。因此，你必须对数据进行反规范化。仔细考虑如何使用数据——你可能需要将数据复制到多个表中。</p>
<hr />
<h3 id="interview-questions-14"><a class="header" href="#interview-questions-14">Interview Questions</a></h3>
<hr />
<p>问题 1 至 3 涉及本章末尾的 database schema。每个 apartment 可以有多个 tenant，每个 tenant 可以有多个 apartment。每个 apartment 属于一个 building，每个 building 属于一个 complex。</p>
<ul>
<li>
<p><strong>14.1 多个公寓（Multiple Apartments）</strong>：编写一个 SOL 查询，以获取租用多个公寓的租户列表。</p>
<p><em>提示：#408</em></p>
</li>
<li>
<p><strong>14.2 Open Requests</strong>：编写一个 SQL 查询，来获得所有 building 的列表以及 Open Requests 的数量（status 等于 Open 的 Requests）。</p>
<p><em>提示：#411</em></p>
</li>
<li>
<p><strong>14.3 关闭所有请求（Close All Requests）</strong>：Building #11 正在进行重大装修。实现一个查询来关闭此大楼中公寓的所有请求。</p>
<p><em>提示：#431</em></p>
</li>
<li>
<p><strong>14.4 连接（Joins）</strong>：连接的类型有哪些？ 请说明它们之间的区别以及为什么某些类型在某些情况下会更好。</p>
<p><em>提示：#451</em></p>
</li>
<li>
<p><strong>14.5 反范式（Denormalization）</strong>：什么是反范式？解释利弊。</p>
<p><em>提示：#444, #455</em></p>
</li>
<li>
<p><strong>14.6 E-R 图（Entity-Relationship Diagram）</strong>：绘制一个包含公司（companies）、人员（people）和专业人员（professionals，在公司工作的人员）的数据库的 E-R 图。</p>
<p><em>提示：#436</em></p>
</li>
<li>
<p><strong>14.7 设计成绩数据库（Design Grade Database）</strong>：想象一个简单的存储学生成绩信息的数据库。设计这个数据库可能的样子，并提供一个 SQL 查询来返回一个优等生（前10%）的列表，按他们的平均成绩排序。</p>
<p><em>提示：#428, #442</em></p>
</li>
</ul>
<p><strong>附加问题</strong>：面向对象的设计(#7.7)，系统设计和可伸缩性(#9.6)</p>
<p>提示从第 676 页开始。</p>
<div align=center><img src="img/ch14_3.png"/></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-15--线程和锁"><a class="header" href="#chapter-15--线程和锁">Chapter 15 | 线程和锁</a></h1>
<p>在 Microsoft、Google 或 Amazon 的面试中，被要求使用线程实现算法并不是非常普遍（除非你在一个团队中，对该团队来说这是一项特别重要的技术）。但是，对任何公司的面试官来说，评估你对线程的总体理解，尤其是对死锁的理解，都是是相对常见的。</p>
<p>本章将介绍该主题。</p>
<h3 id="java中的线程"><a class="header" href="#java中的线程">Java中的线程</a></h3>
<p>Java 中的每个线程都是由 <code>java.lang.Thread</code> 类的唯一对象创建和控制的。运行独立应用程序时，会自动创建一个用户线程来执行 main() 方法。该线程称为主线程。</p>
<p>在 Java 中，我们可以通过以下两种方式之一实现线程：</p>
<ul>
<li>
<p>通过实现 <code>java.lang.Runnable</code> 接口</p>
</li>
<li>
<p>通过扩展 <code>java.lang.Thread</code> 类</p>
</li>
</ul>
<p>我们将在下面介绍这两个方面。</p>
<h4 id="实现-runnable-接口"><a class="header" href="#实现-runnable-接口">实现 Runnable 接口</a></h4>
<p>Runnable 接口具有以下非常简单的结构。</p>
<pre><code class="language-java">1 	public interface Runnable {
2 		void run();
3 	}
</code></pre>
<p>要使用这个接口创建和使用线程，我们需要执行以下操作：</p>
<ol>
<li>
<p>创建一个实现 Runnable 接口的类。该类的对象是一个 Runnable 对象。</p>
</li>
<li>
<p>通过将 Runnable 对象作为参数传递给 Thread 构造函数，创建 Thread 类型的对象。Thread 对象现在有一个 Runnable 对象，它实现了 run() 方法。</p>
</li>
<li>
<p>在上一步中创建的 Thread 对象上调用 start() 方法。</p>
</li>
</ol>
<p>例如：</p>
<pre><code class="language-java">1 	public class RunnableThreadExample implements Runnable {
2 		public int count = 0;
3
4 		public void run() {
5 		System.out.println("RunnableThread starting.");
6 			try {
7 				while (count&lt; 5) {
8 					Thread.sleep(500);
9 					count++;
10				}
11 			} catch (InterruptedException exc) {
12 				System.out.println("RunnableThread interrupted.");
13			}
14 			system.out.println("RunnableThread terminating.");
15		}
16 	}
17
18 	public static void main(String[] args) {
19 		RunnableThreadExample instance = new RunnableThreadExample();
20 		Thread thread = new Thread(instance);
21 		thread.start();
22
23 		/* waits until above thread counts to 5 (slowly) */
24 		while (instance.count != 5) {
25 			try {
26 				Thread.sleep(250);
27			} catch (InterruptedException exc) {
28 				exc.printStackTrace();
29 			}
30		}
31 	}
</code></pre>
<p>在上面的代码中，可以看到我们真正需要做的是让类实现 run() 方法（第4行）。然后另一种方法可以将类的实例传递给新的 new Thread(obj) （第19 - 20行)，并在线程上调用 start() （第21行）。</p>
<h4 id="继承-thread-类"><a class="header" href="#继承-thread-类">继承 Thread 类</a></h4>
<p>或者，我们可以通过继承 Thread 类来创建一个线程。 这几乎总是意味着我们需要重写 run() 方法，并且子类也可以在其构造函数中显式调用线程构造函数。</p>
<p>以下代码提供了一个示例。</p>
<pre><code class="language-java">1 	public class ThreadExample extends Thread {
2 		int count = 0;
3
4 		public void run() {
5 			System.out.println("Thread starting.");
6 			try {
7 				while (count &lt; 5) {
8 					Thread.sleep(500);
9 					System.out.println("In Thread, count is " + count);
10					count++;
11				}
12 			} catch (InterruptedException exc) {
13 				System.out.println("Thread interrupted.");
14			}
15 			System.out.println("Thread terminating.");
16		}
17 	}
18
19 	public class ExampleB {
20 		public static void main(String args[]) {
21 			ThreadExample instance = new ThreadExample();
22 			instance.start();
23
24 			while (instance.count != 5) {
25 				try {
26 					Thread.sleep(250);
27 				} catch (InterruptedException exc) {
28 					exc.printStackTrace();
29				}
30			}
31		}
32	}
</code></pre>
<p>这段代码与第一种方法非常相似。不同之处在于，由于我们正在继承 Thread 类，而不是仅仅实现一个接口，所以我们可以在类本身的实例上调用 start() 方法。</p>
<h4 id="继承-thread-类-vs-实现-runnable-接口"><a class="header" href="#继承-thread-类-vs-实现-runnable-接口">继承 Thread 类 vs. 实现 Runnable 接口</a></h4>
<p>在创建线程时，实现 Runnable 接口可能比扩展 Thread 类更好，有两个原因可以解释：</p>
<ul>
<li>
<p>Java 不支持多重继承。因此，继承 Thread 类意味着子类不能继承任何其他类。实现 Runnable 接口的类将能够继承另一个类。</p>
</li>
<li>
<p>一个类可能只对可运行（runnable）感兴趣，因此，继承 Thread 类的全部开销将是过度的。</p>
</li>
</ul>
<h3 id="synchronization-和-lock"><a class="header" href="#synchronization-和-lock">Synchronization 和 Lock</a></h3>
<p>给定进程中的线程共享同一内存空间，这既有正面影响也有负面的。它使线程能够共享数据，这可能很有价值。但是，当两个线程同时修改一个资源时，它也会产生问题。Java 提供同步，以便控制对共享资源的访问。</p>
<p>关键字 <code>synchronized</code> 和 <code>lock</code> 构成了实现代码同步执行的基础。</p>
<h4 id="synchronized-方法"><a class="header" href="#synchronized-方法">Synchronized 方法</a></h4>
<p>最常见的是，我们通过使用 synchronized 关键字来限制对共享资源的访问。它可以应用于方法和代码块，并限制多个线程在同一对象上同时执行代码。</p>
<p>为澄清最后一点，请思考以下代码：</p>
<pre><code class="language-java">1 	public class MyClass extends Thread {
2 		private String name;
3 		private MyObject myObj;
4
5 		public MyClass(MyObject obj, String n) {
6 			name = n;
7 			myObj = obj;
8		}
9
10 		public void run() {
11 			myObj.foo(name);
12 		}
13	}
14
15	public class MyObject {
16		public synchronized void foo(String name) {
17			try {
18				System.out.println("Thread " + name + ".foo(): starting");
19				Thread.sleep(3000);
20				System.out.println("Thread " + name + ".foo(): ending");
21			} catch (InterruptedException exc) {
22				System.out.println("Thread " + name + ": interrupted.");
23 			}
24 		}
25	}
</code></pre>
<p>两个 MyClass 实例可以同时调用 foo 吗？视情况而定。如果他们有相同的MyObject 实例，那么不可以。但是，如果他们有不同的引用，那么是可以的。</p>
<pre><code class="language-java">1 	/* Difference references - both threads can call MyObject.foo() */
2 	MyObject obj1 = new MyObject();
3 	MyObject obj2 = new MyObject();
4 	MyClass thread1 = new MyClass(obj1, "1");
5 	MyClass thread2 = new MyClass(obj2, "2");
6 	thread1.start();
7 	thread2.start();
8
9 	/* Same reference to obj. Only one will be allowed to call foo,
10 	 * and the other will be forced to wait. */
11 	MyObject obj = new MyObject();
12 	MyClass thread1 = new MyClass(obj, "1");
13 	MyClass thread2 = new MyClass(obj, "2");
14 	thread1.start();
15 	thread2.start();
</code></pre>
<p>静态方法在 <em>class lock</em> 上同步。 上面的两个线程不能同时在同一个类上执行同步静态方法，即使一个调用 foo，而另一个调用 bar。</p>
<pre><code class="language-java">1 	public class MyClass extends Thread {
2
3 		public void run() {
4 			if (name.equals("!")) MyObject.foo(name);
5 			else if (name.equals("2")) MyObject.bar(name);
6 		}
7 	}
8
9 	public class MyObject {
10 		public static synchronized void foo(String name) {/* same as before */}
11 		public static synchronized void bar(String name) {/* same as foo */}
12 	}
</code></pre>
<p>如果运行这段代码，你会看到以下打印：</p>
<pre><code>Thread 1.foo(): starting
Thread 1.foo(): ending
Thread 2.bar(): starting
Thread 2.bar(): ending
</code></pre>
<h4 id="synchronized-块"><a class="header" href="#synchronized-块">Synchronized 块</a></h4>
<p>类似地，一段代码可以被同步。这与同步方法的操作非常相似。</p>
<pre><code class="language-java">1 	public class MyClass extends Thread {
2		...
3 		public void run() {
4 			myObj.foo(name);
5		}
6	}
7 	public class MyObject {
8 		public void foo(String name) {
9 			synchronized(this) {
10			...
11			}
12		}
13	}
</code></pre>
<p>与同步方法一样，每个MyObject实例只有一个线程可以执行 synchronized 块中的代码。这意味着如果 thread1 和 thread2 具有相同的 MyObject 实例，则一次只允许执行一个代码块。</p>
<h3 id="locks"><a class="header" href="#locks">Locks</a></h3>
<p>为了更细粒度的控制，我们可以使用锁。锁（或 monitor）用于通过将资源与锁相关联来同步对共享资源的访问。线程首先获取与资源关联的锁，从而获得对共享资源的访问权。在任何给定时间，最多一个线程可以持有锁，因此，只有一个线程可以访问共享资源。</p>
<p>锁的一个常见使用从场景是，从多个位置访问资源，但是一次只能由一个线程访问。下面的代码演示了这种情况。</p>
<pre><code class="language-java">1 	public class LockedATM {
2 		private Lock lock;
3 		private int balance = 100;
4
5 		public LockedATM() {
6 			lock = new Reentrantlock();
7		}
8
9 		public int withdraw(int value) {
10 			lock.lock();
11 			int temp = balance;
12 			try {
13 				Thread.sleep(100);
14 				temp = temp - value;
15 				Thread.sleep(100);
16 				balance = temp;
17			} catch (InterruptedException){		}
18 			lock.unlock();
19			return temp;
20		}
21
22 		public int deposit(int value) {
23 			lock.lock();
24 			int temp = balance;
25 			try {
26 				Thread.sleep(100);
27				temp = temp + value;
28				Thread.sleep(300);
29				balance = temp;
30			} catch (InterruptedException e) {		}
31			lock.unlock();
32			return temp;
33		}
34 	}
</code></pre>
<p>当然，我们添加了一些代码来故意放慢 <code>withdraw</code> 和 <code>deposit</code> 的执行速度，因为这有助于说明可能发生的潜在问题。你可能不会像这样编写完全相同的代码，但是它所反映的情况是非常非常真实的。使用锁将有助于保护共享资源不被意外地修改。</p>
<h3 id="死锁和死锁的预防"><a class="header" href="#死锁和死锁的预防">死锁和死锁的预防</a></h3>
<p>死锁是这样一种情况：一个线程正在等待另一个线程持有的对象锁，而第二个线程正在等待第一个线程持有的对象锁（或者具有多个线程的等效情况）。因为每个线程都在等待另一个线程释放一个锁，因此它们都会一直等待。这些线程被称为死锁。</p>
<p>若要发生死锁，必须满足以下四个条件:</p>
<ol>
<li>
<p><em>互斥</em>：在给定的时间内，只有一个进程可以访问资源。（或者，更准确地说，对资源的访问是有限的。如果资源的数量有限，也可能发生死锁。）</p>
</li>
<li>
<p><em>持有和等待</em>：已经拥有资源的进程可以请求其他资源，而不会放弃其当前资源。</p>
</li>
<li>
<p><em>无抢占</em>：一个进程不能强制删除另一个进程的资源。</p>
</li>
<li>
<p><em>循环等待</em>：两个或多个进程组成一个循环链，其中每个进程正在等待链中的另一个资源。</p>
</li>
</ol>
<p>死锁预防需要删除上面的任何条件，但是由于其中许多条件难以满足，所以它变得很棘手。例如，删除#1很困难，因为很多资源一次只能由一个进程使用(例如打印机)。大多数死锁预防算法都侧重于避免条件#4:循环等待。</p>
<p>死锁预防需要消除上述的任何条件，但是由于其中许多条件难以满足，所以这变得很棘手。例如，删除 ＃1 是困难的，因为许多资源一次只能由一个进程使用（例如，打印机）。大多数死锁预防算法专注于避免条件 ＃4：循环等待。</p>
<hr />
<h3 id="interview-questions-15"><a class="header" href="#interview-questions-15">Interview Questions</a></h3>
<hr />
<ul>
<li>
<p><strong>15.1 线程与进程（Thread vs. Process）</strong>：线程与进程的区别是什么？</p>
<p><em>提示：#405</em></p>
</li>
<li>
<p><strong>15.2 上下文切换（Context Switch）</strong>：你如何测量在上下文切换中花费的时间？</p>
<p><em>提示：#403, #407, #475, #447</em></p>
</li>
<li>
<p><strong>15.3 哲学家就餐问题（Dining Philosophers）</strong>：在著名的哲学家就餐问题中，一群哲学家围坐在一张圆桌旁，每人之间有一根筷子。哲学家需要用两根筷子吃饭，总是先拿起左手边的筷子再拿右手边的筷子。如果所有的哲学家同时伸手去拿起左边的筷子，则可能发生死锁。使用线程和锁，对哲学家就餐问题进行模拟，以防止死锁。</p>
<p><em>提示：#419, #437</em></p>
</li>
<li>
<p><strong>15.4 无死锁类（Deadlock-Free Class）</strong>：设计一个类，只有在没有可能的死锁时才提供锁。</p>
<p><em>提示：#422, #434</em></p>
</li>
<li>
<p><strong>15.5 按顺序调用（Call In Order）</strong>：假设我们有以下代码：</p>
<pre><code class="language-java">public class Foo {
	public Foo() { ... }
	public void first() { ... }
	public void second() { ... }
	public void third() { ... }
}
</code></pre>
<p><code>Foo</code> 的同一个实例将被传递给三个不同的线程。ThreadA 会调用 <code>first</code>，threadB 会调用 <code>second</code>，threadC 会调用 <code>third</code>。设计一种机制，确保在 <code>second </code>之前调用 <code>first</code>，在 <code>third</code> 之前调用<code>second</code>。</p>
<p><em>提示：#477, #433, #446</em></p>
</li>
<li>
<p><strong>15.6 同步方法（Synchronized Methods）</strong>：给定一个类，该类带有一个同步方法 A 和一个普通方法 B。如果在一个程序实例中有两个线程，它们可以同时执行 A 吗？他们可以同时执行 A 和 B 吗？</p>
<p><em>提示：#429</em></p>
</li>
<li>
<p><strong>15.7 FizzBuzz</strong>：在经典问题 FizzBuzz 中，你被告知打印1到n之间的数字。然而，当数字被3整除时，打印“Fizz”。当它能被5整除时，打印“Buzz”。当它被3和5整除时，打印“FizzBuzz”。在这个问题中，要求你以多线程的方式执行此操作。实现具有四个线程的FizzBuzz的多线程版本。一个线程负责检查是否能被 3 整除并打印 “Fizz”。另一个线程负责检查是否能被 5 整除并打印“Buzz”。第三个线程负责检查是否同时能被 3 和 5 整除并打印 “FizzBuzz”。第四个线程产生这些数字。</p>
<p><em>提示：#474, #439, #447, #458</em></p>
</li>
</ul>
<p>提示从第 676 页开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-16--中等"><a class="header" href="#chapter-16--中等">Chapter 16 | 中等</a></h1>
<ul>
<li>
<p><strong>16.1 数字翻转器（Number Swapper）</strong>：编写一个函数原地（即没有临时变量）翻转一个数字。</p>
<p><em>提示：#492, #716, #737</em></p>
</li>
<li>
<p><strong>16.2 单词频率（Word Frequencies）</strong>：设计一种方法来找出一本书中任何给定单词出现的频率。如果我们多次运行这个算法呢?</p>
<p><em>提示：#489, #536</em></p>
</li>
<li>
<p><strong>16.3 相交（Intersection）</strong>：给出两个直线段（以给定起点和终点的方式表示），计算相交点（如果有的话）。</p>
<p><em>提示：#465, #472, #497, #517, #527</em></p>
</li>
<li>
<p><strong>16.4 井字游戏（Tic Tac Win）</strong>：设计一个算法来判断某人是否赢得了一场井字游戏（tic-tac-toe）。</p>
<p><em>提示：#710, #732</em></p>
</li>
<li>
<p><strong>16.5 阶乘中的 0（Factorial Zeros）</strong>：编写一个算法，计算 n! 中尾随的 0 的数量。</p>
<p><em>提示：#585, #711, #729, #733, #745</em></p>
</li>
<li>
<p><strong>16.6 最小差值（Smallest Difference）</strong>：给定两个整数数组，计算出具有最小（非负）差值的一对值（每个数组中的一个值）。并返回这个差值。</p>
<p>EXAMPLE</p>
<pre><code>Input: {1, 3, 15, 11, 2}, {23, 127,235, 19, 8}
Output: 3. That is, the pair (11, 8).
</code></pre>
<p><em>提示：#632, #670, #679</em></p>
</li>
<li>
<p><strong>16.7 最大值（Number Max）</strong>：编写一个方法，找到两个数字中的最大值。不能使用 if-else 或任何其他比较运算符。</p>
<p><em>提示：#473, #513, #707, #728</em></p>
</li>
<li>
<p><strong>16.8 英文整数（English Int）</strong>：给定任意整数，打印一个描述该整数的英文短语（例如，"One Thousand, Two Hundred Thirty Four"）。</p>
<p><em>提示：#502, #588, #688</em></p>
</li>
<li>
<p><strong>16.9 运算（Operations）</strong>：编写方法来实现整数的乘除运算。所有这些的结果都是整数。只使用 add 运算符。</p>
<p><em>提示：#572, #600, #613, #648</em></p>
</li>
<li>
<p><strong>16.10 在世的人（Living People）</strong>：给定一份某些人的出生和死亡年份的列表，实现一个方法，计算在世人数最多的年份。你可以假设所有的人都出生在 1900 年到 2000 年之间。如果一个人在那一年的任何时候还活着，他应该被包括在那一年的统计中。例如，Person (birth = 1908, death = 1909) 被包含在 1908 年和 1909 年的计数中。</p>
<p><em>提示：#476, #490, #507, #514, #523, #532, #541, #549, #576</em></p>
</li>
<li>
<p><strong>16.11 跳水板（Diving Board）</strong>：你正在建造一个跳水板，把一堆木板首尾相连。有两种类型的木板，一种长度较短，一种长度较长。你必须正好用 K 块木板。写一个方法来生成跳水板的所有可能长度。</p>
<p><em>提示：#690, #700, #715, #722, #740, #747</em></p>
</li>
<li>
<p><strong>16.12 XML 编码（XML Encoding）</strong>：由于XML非常冗长，因此提供了一种编码方法，其中每个标签（tag）都映射到一个预定义的整数值。语言/语法如下:</p>
<pre><code>Element --&gt; Tag Attributes END Children END
Attribute --&gt; Tag Value
END --&gt; 0
Tag --&gt; some predefined mapping to int
Value --&gt; string value
</code></pre>
<p>例如，以下 XML 可以转换为下面的压缩字符串（假设映射为 family -&gt; 1，person -&gt; 2，firstName -&gt; 3，lastName -&gt; 4，state -&gt; 5）。</p>
<pre><code class="language-javascript">&lt;family lastName="McDowell" state="CA"&gt;
&lt;person firstName="Gayle"&gt;Some Message&lt;/person&gt;
&lt;/family&gt;
</code></pre>
<p>就变成:</p>
<pre><code>1 4 McDowell 5 CA 0 2 3 Gayle 0 Some Message 0 0
</code></pre>
<p>编写代码以打印 XML element 的编码版本（传入 Element 和 Attribute 对象）。</p>
<p><em>提示：#466</em></p>
</li>
<li>
<p><strong>16.13 平分正方形（Bisect Squares）</strong>：给定二维平面上的两个正方形，找出一条可以将这两个正方形对半切开的直线。假设正方形的顶部和底部平行于 x 轴。</p>
<p><em>提示：#468, #479, #528, #560</em></p>
</li>
<li>
<p><strong>16.14 最佳直线（Best Line）</strong>：给定一个二维图，图上有一些点，找出一条经过最多点的直线。</p>
<p><em>提示：#491, #520, #529, #563</em></p>
</li>
<li>
<p><strong>16.15 猜字游戏（Master Mind）</strong>：Master Mind 游戏玩法如下:</p>
<p>机器上有四个插槽，每个插槽将容纳一个球，其颜色可以是红色 (R)、黄色 (Y)、绿色 (G) 或蓝色 (B)。</p>
<p>例如，该机器可能有 RGGB（Slot #1是红色的，Slots #2 和 Slots #3 是绿色的，Slots #4 是蓝色的)。</p>
<p>假设你正在尝试猜测答案。例如，你可能会猜 YRGB。</p>
<p>当你猜对某个插槽上球的颜色时，你会得到一个“hit”。如果你猜的颜色存在，但是插槽的位置不对时，你会得到一个“伪命中”。注意，一个插槽被统计为 hit 后永远不可能被统计为 pseudo-hit。</p>
<p>例如，如果实际的答案是 RGBY，而你猜是 GGRR，那么你有一个 hit 和一个 pseudo-hit。编写一个方法，给定一个猜测和一个答案，返回 hit 次数和 pseudo-hit 次数。</p>
<p><em>提示：#639, #730</em></p>
</li>
<li>
<p><strong>16.16 子排序（Sub Sort）</strong>：给定一个整数数组，写一个方法来找到下标 m 和 n，这样，如果对元素 m 到 n 进行排序，则整个数组都将被排序。求 n~m 的最小值（即找到最小的此类序列）。</p>
<p>EXAMPLE</p>
<pre><code>Input: 1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19
Output: (3, 9)
</code></pre>
<p><em>提示：#482, #553, #667, #708, #735, #746</em></p>
</li>
<li>
<p><strong>16.17 连续序列（Contiguous Sequence）</strong>：给定一个整数数组（包括正数和负数）。找到总和最大的连续序列。返回总和。</p>
<p>EXAMPLE</p>
<pre><code>Input: 2, -8, 3, -2, 4, -10
Output: 5 ( i.e., {3, -2, 4})
</code></pre>
<p><em>提示：#537, #551, #567, #594, #614</em></p>
</li>
<li>
<p><strong>16.18 模式匹配（Pattern Matching）</strong>：给定两个字符串，即模式和值。模式字符串仅由字母 a 和 b 组成，它们描述了字符串中的模式。例如，字符串 catcatgocatgo 匹配模式 aabab （其中 cat 是 a，go 是 b），它还匹配 a，ab 和 b 之类的模式。编写一个方法来确定值是否与模式匹配。</p>
<p><em>提示：#631, #643, #653, #663, #685, #718, #727</em></p>
</li>
<li>
<p><strong>16.19 池塘大小（Pond Sizes）</strong>:你有一个整数矩阵，代表一块土地，其中该位置的值代表海拔高度。0 值表示水。池塘是横、竖或对角线相连的水域。池塘的大小是相连的水格（water cells）总数。编写一种方法来计算矩阵中所有池塘的大小。</p>
<p>EXAMPLE</p>
<pre><code>Input:
0 2 1 0
0 1 0 1
1 1 0 1
0 1 0 1
Output: 2, 4, 1 (in any order)
</code></pre>
<p><em>提示：#674, #687, #706, #723</em></p>
</li>
<li>
<p><strong>16.20 T9</strong>：在旧的手机上，用户在数字键盘上输入数字，手机将提供与这些数字匹配的单词列表。每个数字映射到一组 0~4 个字母。实现一个算法，给定一个数字序列，返回匹配的单词列表。你会得到一个有效单词的列表（以你想要的任何数据结构提供）。映射如下图所示：</p>
<div align=center><img src="img/ch16_1.png"/></div>
<p>EXAMPLE</p>
<pre><code>Input: 8733
Output: tree, used
</code></pre>
<p><em>提示：#477, #487, #654, #703, #726, #744</em></p>
</li>
<li>
<p><strong>16.21 和交换（Sum Swap）</strong>：给定两个整数数组，找到一对值（每个数组一个值），能够满足互换这些值以使两个数组具有相同的总和。</p>
<p>EXAMPLE</p>
<pre><code>Input: {4, 1, 2, 1, 1, 2} and {3, 6, 3, 3}
Output: {1, 3}
</code></pre>
<p><em>提示：#545, #557, #564, #577, #583, #592, #602, #606, #635</em></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-17--困难"><a class="header" href="#chapter-17--困难">Chapter 17 | 困难</a></h1>
<ul>
<li>
<p><strong>17.1 不用加号相加（Add Without Plus）</strong>：编写一个将两个数字相加的函数。不能使用 + 或任何算术运算符。</p>
<p><em>提示：#467, #544, #607, #628, #642, #664, #692, #772, #724</em></p>
</li>
<li>
<p><strong>17.2 洗牌（Shuffle）</strong>：写一个洗牌的方法。它必须是一次完美的洗牌——换句话说，<code>52!</code> 个牌组排列中每个出现的概率都是相同的。假设你有一个完美的随机数生成器。</p>
<p><em>提示：#483, #579, #634</em></p>
</li>
<li>
<p><strong>17.3 随机集合（Random Set）</strong>：写一个方法，从一个大小为 n 的数组中随机生成一组 m 个整数，每个元素被选中的概率必须相等。</p>
<p><em>提示：#494, #596</em></p>
</li>
<li>
<p><strong>17.4 缺失的数字（Missing Number）</strong>：数组 A 包含从 0 到 n 的所有整数，除了少了一个数字。在这个问题中，我们不能用单个操作访问 A 中的所有整数。A 的元素用二进制表示，我们可以用来访问它们的唯一操作是“获取 A[i] 的第 j 位”，这需要花费固定的时间。编写代码来查找丢失的整数。你能在 O(n) 时间内完成吗?</p>
<p><em>提示：#670, #659, #683</em></p>
</li>
<li>
<p><strong>17.5 字母和数字（Letters and Numbers）</strong>：给定一个由字母和数字组成的数组，找出字母和数字数目相等的最长的子数组。</p>
<p><em>提示：#485, #575, #679, #677, #773</em></p>
</li>
<li>
<p><strong>17.6 对 2 计数（Count of 2s）</strong>：写一个方法，对在 0 到 n（包括 n）之间的所有数字中出现的 2 的数量进行统计。</p>
<p>EXAMPLE</p>
<pre><code>Input: 25
Output: 9 (2, 12, 20, 21, 22, 23, 24 and 25. Note that 22 counts for two 2s.)
</code></pre>
<p><em>提示：#573, #672, #641</em></p>
</li>
<li>
<p><strong>17.7 婴儿名字（Baby Names）</strong>：每年，政府都会发布 10000 个最常用的婴儿名字及其频率（带有该名字的婴儿数量）的列表。唯一的问题是某些名称具有多种拼写。例如，“John” 和 “Jon” 本质上是相同的名字，但会在列表中分别单独列出。给定两个列表，一个是名称/频率，另一个是等效名字对，编写一个算法来打印每个名字的真实出现频率的新列表。请注意，如果 John 和 Jon 是同义词，而 Jon 和 Johnny 是同义词，则 John 和 Johnny 也是同义词（既可传递，也可对称）。在最后的列表中，任何名字都可以用作“真实”姓名。</p>
<p>EXAMPLE</p>
<pre><code>Input:
  	Names: John (15), Jon (12), Chris (13), Kris (4), Christopher (19)
  	Synonyms: (Jon, John), (John, Johnny), (Chris, Kris), (Chris, Christopher)
Output: John (27), Kris (36)
</code></pre>
<p><em>提示：#478, #493, #512, #537, #586, #605, #655, #675, #704</em></p>
</li>
<li>
<p><strong>17.8 马戏团塔（Circus Tower）</strong>：马戏团正在设计一种塔舞，人们站在彼此的肩膀上。出于实用和审美的原因，每个人都必须比他或她下面的人更矮、更轻。给定马戏团里每个人的身高和体重，写一个方法来计算这样一个塔里可能的最大人数。</p>
<p>EXAMPLE</p>
<pre><code>Input(ht,wt): (65, 100) (70, 150) (56, 90) (75, 190) (60, 95) (68, 110)
Output: The longest tower is length 6 and includes from top to bottom:
(56, 90) (60,95) (65,100) (68,110) (70,150) (75,190)
</code></pre>
<p><em>提示：#638, #657, #666, #682, #699</em></p>
</li>
<li>
<p><strong>17.9 第 k 个倍数（Kth Multiple）</strong>：设计一种算法来找到唯一因数是3、5 和 7 的数字排列中的第 k 个数。请注意，3、5 和 7 不一定是其因数，但它不应该有任何其他质因数。例如，前几个倍数是（按顺序）1、3、5、7、9、15、21。</p>
<p><em>提示：#488, #508, #550, #591, #622, #660, #686</em></p>
</li>
<li>
<p><strong>17.10 多数元素（Majority Element）</strong>：多数元素是一个数组中一半以上的元素。给定一个正整数数组，找到多数元素。如果没有多数元素，返回 -1。请在 O(N) 时间 和 O(1) 空间内完成此操作。</p>
<p>EXAMPLE</p>
<pre><code>Input: 1 2 5 9 5 9 5 5 5
Output: 5
</code></pre>
<p><em>提示：#522, #566, #604, #620, #650</em></p>
</li>
<li>
<p><strong>17.11 单词距离（Word Distance）</strong>：你有一个包含单词的大文本文件。给定任意两个单词，找出它们在文件中的最短距离（以单词数量为单位）。如果对同一个文件（但是不同的单词对）重复执行多次操作，你是否可以优化你的解决方案？</p>
<p><em>提示：#486, #501, #538, #558, #633</em></p>
</li>
<li>
<p><strong>17.12 BiNode</strong>：考虑一个名为 BiNode 的简单数据结构，其中有指向其他两个节点的指针。</p>
<pre><code class="language-java">public class BiNode {
  	public BiNode node1, node2;
	public int data;
  }
</code></pre>
<p>数据结构 BiNode 可用于表示二叉树（其中 node1 是左节点，node2 是右节点）或双向链表（其中 node1 是前一个节点，node2 是下一个节点）。实现一个方法，将二叉搜索树（由 BiNode 实现）转换为双链表。应该按顺序保存这些值，并且在原地（即在原始数据结构上）执行操作。</p>
<p><em>提示：#509, #608, #646, #680, #707, #779</em></p>
</li>
<li>
<p><strong>17.13 重新加空格（Re-Space）</strong>：哦，不！ 你不小心移除了长篇文档中的所有空格、标点和大写字母。像 “I reset the computer. It still didn't boot!” 这样的句子变成了 “iresetthecomputeritstilldidntboot” 。可以稍后再处理标点和大写，现在你只需要重新插入空格。大多数单词都在字典中，但也有一些不是。给定一个字典（字符串列表）和文档（字符串），设计一种算法，以使连接在一起的文档分开，并且保证使无法识别的字符数降到最小。</p>
<p>EXAMPLE:</p>
<p><code>Input: jesslookedjustliketimherbrother</code></p>
<p><code>Output:</code> <u><em>jess</em></u> looked just like <u><em>tim</em></u> her brother (7 unrecognized characters)</p>
<p><em>提示：#496, #623, #656, #677, #739, #749</em></p>
</li>
<li>
<p><strong>17.14 最小的 K（Smallest K）</strong>：设计一个算法，找出数组中最小的 K 个数字。</p>
<p><em>提示：#470, #530, #552, #593, #625, #647, #661, #678</em></p>
</li>
<li>
<p><strong>17.15 最长单词（Longest Word）</strong>：给定一个单词列表，编写一个程序，找出该列表中由其他单词组成的最长单词。</p>
<p>EXAMPLE</p>
<pre><code>Input: cat, banana, dog, nana, walk, walker, dogwalker
Output: dogwalker
</code></pre>
<p><em>提示：#475, #499, #543, #589</em></p>
</li>
<li>
<p><strong>17.16 女按摩师（The Masseuse）</strong>：一个很受欢迎的女按摩师收到了一连串的预约请求，正考虑应该接受哪些请求。她需要在预约之间有15分钟的休息时间，因此她不能接受任何相邻的请求。给定一个连续的预约请求序列（所有的请求的时长都是15分钟的倍数，没有重叠，并且都不能移动），找到按摩师可以接受的最佳设置（最高预订总分钟数）。并返回分钟数。</p>
<p>EXAMPLE</p>
<pre><code>Input: {30, 15, 60, 75, 45, 15, 15, 45}
Output:180 minutes ({30, 60, 45, 45}).
</code></pre>
<p><em>提示：#495, #504, #576, #526, #542, #554, #562, #568, #578, #587, #607</em></p>
</li>
<li>
<p><strong>17.17 多重搜索（Multi Search）</strong>：给定一个字符串 b 和一个较小的字符串组 T，设计一个方法来搜索 T 中的每个小字符串 b。</p>
<p><em>提示：#480, #582, #617, #743</em></p>
</li>
<li>
<p><strong>17.18 最短超序列（Shortest Supersequence）</strong>：给你两个数组，一个数组较短（其中所有元素都不同），另一个数组较长。在较长数组中，找到包含较短数组中所有元素的最短子数组。其中短数组中的这些项可以在子数组中按任何顺序出现。</p>
<p>EXAMPLE</p>
<p><code>Input: </code>{1, 5, 9} | {7, 5, 9, 0, 2, 1, 3, <u><em>5, 7, 9, 1,</em></u> 1, 5, 8, 8, 9, 7}</p>
<p><code>Output: </code>[7, 10] （上面划线部分）</p>
<p><em>提示：#645, #652, #669, #687, #697, #725, #731, #741</em></p>
</li>
<li>
<p><strong>17.19 缺失两个（Missing Two）</strong>：你将得到一个数组，其中从 1 到 N 的所有数字仅出现一次，但缺少一个数字。如何在 O(N) 时间 和 O(1) 空间内找到缺失的数字？ 如果缺少两个数字怎么办？</p>
<p><em>提示：#503, #590, #609, #626, #649, #672, #689, #696, #702, #717</em></p>
</li>
<li>
<p><strong>17.20 连续中数（Continuous Median）</strong>：随机生成数字并传递给方法。编写一个程序，在生成新值时查找并维护中值。</p>
<p><em>提示：#519, #546, #575, #709</em></p>
</li>
<li>
<p><strong>17.21 直方图的体积（Volume of Histogram）</strong>：想象一个直方图（柱状图）。设计一种算法来计算如果有人将水倒在顶部时，其可以容纳的水量。你可以假定每个直方图条的宽度为 1。</p>
<p>EXAMPLE （黑条是直方图。灰色是水。）</p>
<div align=center><img src="img/ch17_1.png"/></div>
  ```
  Input: {0, 0, 4, 0, 0, 6, 0, 0, 3, 0, 5, 0, 1, 0, 0, 0}
  Output: 26
  ```
<p><em>提示：#629, #640, #657, #658, #662, #676, #693, #734, #742</em></p>
</li>
<li>
<p><strong>17.22 单词变形器（Word Transformer）</strong>：给出字典中两个等长的单词，编写一个方法，一次只更改一个字母即可将一个单词转换为另一个单词。你在每个步骤中获得的新单词都必须在词典中。</p>
<p>EXAMPLE</p>
<pre><code>Input: DAMP, LIKE
Output: DAMP-&gt; LAMP-&gt; LIMP-&gt; LIME-&gt; LIKE
</code></pre>
<p><em>提示：#506, #535, #556, #580, #598, #618, #738</em></p>
</li>
<li>
<p><strong>17.23 最大黑色正方形（Max Black Square）</strong>：假设你有一个正方形矩阵，其中每个单元（像素）不是黑色就是白色。设计一种算法来查找最大子正方形，满足其四个边框都被黑色像素填充。</p>
<p><em>提示：#684, #695, #705, #714, #721, #736</em></p>
</li>
<li>
<p><strong>17.24 最大子矩阵（Max Submatrix）</strong>：给定一个正整数和负整数的 NxN 矩阵，编写代码以找到具有最大和数的子矩阵。</p>
<p><em>提示：#469, #511, #525, #539, #565, #581, #595, #615, #621</em></p>
</li>
<li>
<p><strong>17.25 单词矩形（Word Rectangle）</strong>：给定一个包含数百万个单词的列表，设计一个算法来创建尽可能大的字母矩形，这样每一行组成一个单词（从左到右读），每一列组成一个单词（从上到下读）。不需要从列表中连续地选择单词，但是所有行的长度必须相同，所有列的高度必须相同。</p>
<p><em>提示：#477, #500, #748</em></p>
</li>
<li>
<p><strong>17.26 稀疏相似度（Sparse Similarity）</strong>：两个文档（每个文档内的单词都不相同）的相似度定义为交集的大小除以并集的大小。例如，如果文档由整数组成，那么 {1、5、3} 和 {1、7、2、3} 的相似度是 0.4，因为交集的大小是 2，并集的大小是 5。</p>
<p>我们有一个很长的文档列表（每个文档内的值不同，且每个文档都有一个关联的ID），其中相似度被认为是“稀疏”的。也就是说，任意选择的两个文档的相似度很可能是 0。设计一个算法，使其返回一个内容为文档 ID 及其相关相似度对（pairs of document IDs and the associated similarity）的列表。</p>
<p>只打印相似度大于 0 的对。空的文档完全不需要打印。为简单起见，可以假设每个文档都表示为不同整数的数组。</p>
<p>EXAMPLE</p>
<pre><code>Input:
  13: {14, 15, 100, 9, 3}
  16: {32, 1, 9, 3, 5}
  19: {15, 29, 2, 6, 8, 7}
  24: {7, 10}
Output:
  ID1, ID2 : SIMILARITY
  13, 19   : 0.1
  13, 16   : 0.25
  19, 24   : 0.14285714285714285
</code></pre>
<p><em>提示：#484, #498, #510, #518, #534, #547, #555, #561, #569, #577, #584, #603, #611, #636</em></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="x-答案-1"><a class="header" href="#x-答案-1">X. 答案</a></h1>
<p>注：本书的 <code>X. 答案</code> 部分为编码答案，本项目中不做翻译收录，需要阅读的同学可以阅读英文原版，或者 <em>CareerCup</em> 的这个项目：<a href="https://github.com/careercup/CtCI-6th-Edition">https://github.com/careercup/CtCI-6th-Edition</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xii-代码库-1"><a class="header" href="#xii-代码库-1">XII. 代码库</a></h1>
<p>在实现本书的代码时出现了某些模式。我们通常试图包含解决方案的完整代码，但在某些情况下它会非常冗余。</p>
<p>本附录提供了几个最有用的代码块的代码。</p>
<p>本书的所有代码都可以从 <em>CrackingTheCodinglnterview.com</em> 下载。</p>
<h3 id="hashmaplistt-e"><a class="header" href="#hashmaplistt-e">HashMapList&lt;T, E&gt;</a></h3>
<p>HashMapList 类本质上是 HashMap &lt;T, Arraylist &lt;E&gt;&gt; 的简写。它允许我们从类型为 T 的项映射到类型为 E 的 Arraylist。</p>
<p>例如，我们可能需要一个从整数映射到字符串列表的数据结构。通常，我们会这样写：</p>
<pre><code class="language-java">1 	HashMap&lt;Integer, Arraylist&lt;String&gt;&gt; maplist =
2 		new HashMap&lt;Integer, Arraylist&lt;String&gt;&gt;();
3 	for (String s : strings) {
4 		int key = computeValue(s);
5 		if (!maplist.containsKey(key)) {
6 			maplist.put(key, new Arraylist&lt;String&gt;());
7 		}
8 		maplist.get(key).add(s);
9 	}
</code></pre>
<p>现在，我们可以这样写：</p>
<pre><code class="language-java">1 	HashMaplist&lt;Integer, String&gt; maplist new HashMapList&lt;Integer, String&gt;();
2 	for (String s : strings) {
3 		int key = computeValue(s);
4 		maplist.put(key, s);
5 	}
</code></pre>
<p>这不是一个很大的变化，但是它使我们的代码更简单了。</p>
<pre><code class="language-java">1 	public class HashMapList&lt;T, E&gt; {
2 		private HashMap&lt;T, Arraylist&lt;E&gt;&gt; map= new HashMap&lt;T, Arraylist&lt;E&gt;&gt;();
3
4 		/* Insert item into list at key. */
5 		public void put(T key, E item) {
6 			if (!map.containsKey(key)) {
7 				map.put(key, new Arraylist&lt;E&gt;());
8			}
9 			map.get(key).add(item);
10		}
11
12		/* Insert list of items at key. */
13		public void put(T key, Arraylist&lt;E&gt; items) {
14			map.put(key, items);
15		}
16
17	    /* Get list of items at key. */
18		public Arraylist&lt;E&gt; get(T key) {
19			return map.get(key);
20		}
21
22  	/* Check if hashmaplist contains key. */
23		public boolean containsKey(T key) {
24			return map.containsKey(key);
25		}
26
27		/* Check if list at key contains value. */
28		public boolean containsKeyValue(T key, E value) {
29			Arraylist&lt;E&gt; list = get(key);
30			if (list == null) return false;
31			return list.contains(value);
32		}
33
34		/* Get the list of keys. */
35		public Set&lt;T&gt; keySet() {
36			return map.keySet();
37		}
38
39		@Override
40		public String toString() {
41			return map.toString();
42		}
43	}
</code></pre>
<h3 id="treenode-binary-search-tree"><a class="header" href="#treenode-binary-search-tree">TreeNode (Binary Search Tree)</a></h3>
<p>虽然在可能的情况下使用内置的二叉树类非常好，甚至很好，但并不总是可行的。在许多问题中，我们需要访问节点或树类的内部（或需要调整这些内部），因此无法使用内置库。</p>
<p>TreeNode 类支持各种各样的功能，但我们并不一定希望每个问题/解决方案都使用这些功能。例如，TreeNode 类跟踪节点的父节点，尽管我们通常不使用它（或特别禁止使用它）。</p>
<p>为了简单起见，我们将此树实现为存储整型数据。</p>
<pre><code class="language-java">1 	public class TreeNode {
2 		public int data;
3 		public TreeNode left, right, parent;
4 		private int size = 0;
5
6 		public TreeNode(int d) {
7 			data d;
8 			size = 1;
9		}
10
11		public void insertinOrder(int d) {
12			if (d &lt;= data) {
13				if (left == null) {
14				setLeftChild(new TreeNode(d));
15				} else {
16					left.insertinOrder(d);
17				}
18 			} else {
19				if (right == null) {
20					setRightChild(new TreeNode(d));
21				} else {
22					right.insertlnOrder(d);
23				}
24			}
25			size++;
26 		}
27
28		public int size() {
29			return size;
30 		}
31
32		public TreeNode find(int d) {
33			if (d == data) {
34				return this;
35			} else if (d &lt;= data) {
36				return left != null? left.find(d) : null;
37			} else if (d &gt; data) {
38				return right != null? right.find(d) : null;
39			}
40			return null;
41		}
42
43		public void setLeftChild(TreeNode left) {
44			this.left = left;
45			if (left != null) {
46				left.parent = this;
47			}
48		}
49
50		public void setRightChild(TreeNode right) {
51			this.right = right;
52			if (right != null) {
53				right.parent = this;
54			}
55		}
56
57	}
</code></pre>
<p>该树被实现为二叉搜索树。但是，你可以将它用于其他目的。你只需要使用 <code>setLeftChild</code> / <code>setRightChild</code> 方法，或者左右子变量。</p>
<p>因此，我们将这些方法和变量保持为 <code>public</code>。我们需要这种方式来解决许多问题。</p>
<h3 id="linkedlistnode-linked-list"><a class="header" href="#linkedlistnode-linked-list">LinkedListNode (Linked List)</a></h3>
<p>与 TreeNode 类一样，我们经常需要以内置链表类不支持的方式访问链表的内部。出于这个原因，我们实现了自己的类并将其用于许多问题。</p>
<pre><code class="language-java">1 	public class LinkedListNode {
2 		public LinkedListNode next, prev, last;
3 		public int data; 
4 		public LinkedlistNode(int d, LinkedlistNode n, LinkedListNode p){
5			data = d;
6			setNext(n);
7			setPrevious(p);
8		}
9
10		public LinkedListNode(int d) {
11			data = d;
12		}
13
14		public LinkedListNode() {}
15
16		public void setNext(LinkedListNode n) {
17			next = n;
18			if (this == last) {
19				last = n;
20			}
21			if (n != null &amp;&amp; n.prev != this) {
22				n.setPrevious(this);
23			}
24		}
25
26		public void setPrevious(LinkedListNode p) {
27			prev = p;
28			if (p != null &amp;&amp; p.next != this) {
29				p.setNext(this);
30			}
31		}
32
33		public LinkedListNode clone() {
34			LinkedListNode next2 = null;
35			if (next != null) {
36				next2 = next.clone();
37			}
38			LinkedlistNode head2 = new LinkedListNode(data, next2, null);
39			return head2;
40		}
41	}
</code></pre>
<p>同样，我们将方法和变量保持为 <code>public</code>，因为我们经常需要这种访问。这将允许用户“销毁”链表，然而我们实际上需要这种功能来实现我们的目的。</p>
<h3 id="trie--trienode"><a class="header" href="#trie--trienode">Trie &amp; TrieNode</a></h3>
<p>在一些问题中使用了 trie 数据结构，以便更容易地在字典（或有效单词列表）中查找单词是否是任何其他单词的前缀。当我们递归地构造单词时，经常使用这种方法，这样当单词无效时，我们就可以短路。</p>
<pre><code class="language-java">1 	public class Trie {
2 		// The root of this trie.
3 		private TrieNode root;
4
5 		/* Takes a list of strings as an argument, and constructs a trie that stores
6 		 * these strings. */
7 		public Trie(Arraylist&lt;String&gt; list) {
8 			root = new TrieNode();
9 			for (String word : list) {
10 				root.addWord(word);
11			}
12		}
13
14
15 		/* Takes a list of strings as an argument, and constructs a trie that stores
16 		 * these strings. */
17 		public Trie(String[] list) {
18 			root = new TrieNode();
19 			for (String word : list) {
20 				root.addWord(word);
21			}
22		}
23
24 		/* Checks whether this trie contains a string with the prefix passed in as
25 		 * argument. */
26 		public boolean contains(String prefix, boolean exact) {
27 			TrieNode lastNode = root;
28 			int i= 0;
29 			for (i = 0; i &lt; prefix.length(); i++) {
30 				lastNode = lastNode.getChild(prefix.charAt(i));
31 				if (lastNode == null) {
32 					return false;
33				}
34			}
35 			return !exact || lastNode.terminates();
36		}
37
38 		public boolean contains(String prefix) {
39 			return contains(prefix, false);
40		}
41
42		public TrieNode getRoot() {
43 			return root;
44		}
45 	}
</code></pre>
<p>Trie 类的实现使用了 TrieNode 类，其实现如下。</p>
<pre><code class="language-java">1 	public class TrieNode {
2 		/* The children of this node in the trie.*/
3 		private HashMap&lt;Character, TrieNode&gt; children;
4 		private boolean terminates = false;
5
6 		/* The character stored in this node as data.*/
7 		private char character;
8
9 		/* Constructs an empty trie node and initializes the list of its children to an
10 		 * empty hash map. Used only to construct the root node of the trie. */
11		public TrieNode() {
12			children= new HashMap&lt;Character, TrieNode&gt;();
13		}
14
15		/* Constructs a trie node and stores this character as the node's value.
16		 * Initializes the list of child nodes of this node to an empty hash map. */
17		public TrieNode(char character) {
18			this();
19			this.character = character;
20		}
21
22		/* Returns the character data stored in this node. */
23		public char getChar() {
24			return character;
25		}
26
27		/* Add this word to the trie, and recursively create the child
28		 * nodes. */
29		public void addWord(String word) {
30			if (word== null || word.isEmpty()) {
31				return;
32			}
33
34			char firstChar word.charAt(0);
35
36			TrieNode child getChild(firstChar);
37			if (child== null) {
38				child= new TrieNode(firstChar);
39				children.put(firstChar, child);
40			}
41
42			if (word.length() &gt; 1) {
43				child.addWord(word.substring(l));
44			} else {
45				child.setTerminates(true);
46			}
47		}
48
49		/* Find a child node of this node that has the char argument as its data. Return
50		 * null if no such child node is present in the trie. */
51		public TrieNode getChild(char c) {
52			return children.get(c);
53		}
54
55		/* Returns whether this node represents the end of a complete word. */
56		public boolean terminates() {
57			return terminates;
58		}
59
60		/* Set whether this node is the end of a complete word.*/
61		public void setTerminates(boolean t) {
62			terminates= t;
63		}
64	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xiv-关于作者-1"><a class="header" href="#xiv-关于作者-1">XIV. 关于作者</a></h1>
<p>盖尔•拉克曼•麦克道尔（Gayle Laakmann McDowell）拥有深厚的软件开发背景，无论是作为求职者还是面试官，她都有丰富的经验。</p>
<p>她曾在 Microsoft，Apple 和 Google 担任软件工程师。 她在 Google 工作了三年，在那里她是最优秀的面试官之一，并在招聘委员会任职。她在美国和海外面试了数百名候选人，为招聘委员会评估了数千份候选人的 interview packets，并审阅了更多数量的简历。</p>
<p>作为候选人，她面试过 12 家科技公司，并最终都收到了它们的 offer，其中包括Microsoft、Google、Amazon、IBM 和 Apple。</p>
<p>Gayle 创立了 CareerCup，帮助求职者能在这些充满挑战的面试中有最佳的表现。<em>CareerCup.com</em> 网站提供了一个数据库，里面有来自各大公司的数千个面试问题，以及一个提供面试建议的论坛。</p>
<p>除了 <em>Cracking the Coding Interview</em>，Gayle 还写了另外两本书:</p>
<p><em>Cracking the Tech Career: Insider Advice on Landing a Job at Google, Microsoft, Apple, or Any Top Tech Company</em> 为大型科技公司的面试过程提供了一个更广阔的视角。它提供了无论是大学新生，还是营销专业人员，如何能够在这些公司中找到自己的职业定位的洞察力。</p>
<p><em>Cracking the PM Interview: How to Land a Product Manager Job in Technology</em> 关注的是初创公司和大型科技公司的产品管理职位。它提供了进入这些角色的策略，并指导求职者如何准备 PM 面试。</p>
<p>通过在 CareerCup 的工作，她与技术公司就招聘流程进行协商，领导技术面试培训研讨会，并为初创公司的工程师提供收购面试指导。</p>
<p>她拥有宾夕法尼亚大学的计算机科学学士学位和硕士学位以及沃顿商学院的 MBA 学位。</p>
<p>她住在 Palo Alto, California，与丈夫，两个儿子、一条狗以及计算机科学书籍生活在一起。她仍然坚持每天写代码。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
